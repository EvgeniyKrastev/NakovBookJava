 -----------------------------   -----------------------------  ------------ Обяснения за стека и хийпа  -----------------------------   -----------------------------  ------------

    -------------     -------------
   |   Stack     |   |    Heap     |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             | > |             |
   |             |   |             |
   |             | > |             |
   |             |   |             |
   |             | > |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
    -------------     -------------

 -----------------------------   -----------------------------  ----------- Глава 4. Вход и изход от конзолата  -----------------------------   -----------------------------   -----------------------------  --


 -----------------------------   -----------------------------  ----------- Глава 9. Методи  -----------------------------   -----------------------------   -----------------------------   -----------------------------  ---------

 -----------------------------   -----------------------------  -----------Глава 12. Обработка на изключения  -----------------------------   -----------------------------   -----------------------------  ----

Всяка програма на Java започва с main() метод. В него може да се извика 
друг метод да го наречем "Метод 1", който от своя страна извиква "Метод 
2" и т.н., докато се извика "Метод N".
Когато "Метод N" свърши работата си управлението на програмата се връща 
на предходния и т. н., докато се стигне до main() метода. След като се 
излезе от него свършва и програмата. Като се извиква нов метод той се 
добавя най-отгоре в стека, а като свърши изпълнението му метода се 
изважда от стека.


 -----------------------------   -----------------------------  ------------ Полезни тактики методи или др  -----------------------------   -----------------------------   -----------------------------  -------
System.out.println(Arrays.toString(reversed));
syso(Integer.MAX_VALUE)//2147483647
int smallest = Integer.MAX_VALUE;

-------------str 63
- Методите се отместват по-навътре от дефиницията на класа; 
- Съдържанието на методите се отмества по-навътре от дефиницията на 
метода; 
- Отварящата фигурна скоба { трябва да е на същия ред, на който е 
дефиниран класът или методът;
 - Затварящата фигурна скоба } трябва да е сама на ред, отместена на 
същото разстояние като началото на реда на отварящата;
 - Имената на класовете трябва да започват с главна буква; - Имената на променливите и имената на методите трябва да започват 
с малка буква.

Имената на файловете съответстват на класовете 
всеки клас да е в отделен файл,които е с името на класа.
ако не се спазва става грешка при компилация


Имената на променливите се образуват от буквите a-z, A-Z, цифрите 
0-9, както и символите $ и _. По принцип е допустимо да се ползват и 
букви от кирилицата, но това трябва да се избягва.
 - Имената на променливите не може да започват с цифра. 
 - Имената на променливите не могат да съвпадат със служебна дума
  - - - - 
Имената трябва да са описателни – да обясняват за какво служи 
дадената променлива. Примерно за име на човек подходящо име е 
personName, 

В Java e прието променливите да започват винаги с малка буква и 
всяка следваща дума да започва с главна буква. Примерно: firstName,
 
 Променливите трябва да имат име, което обяснява накратко за какво 
служат

Стойностните типове (value types) се съхраняват в стека за изпълнение 
на програмата и съдържат директно стойността си. Стойностни са 
примитивните числови типове, символният тип и булевият тип: byte, int, 
short, long, float, double, char, boolean. Такива променливи заемат 1, 2, 4 
или 8 байта в стека. Те се освобождават при излизане от обхват. 

Референтните типове (reference types) съхраняват в стека за изпъл
нение на програмата референция към динамичната памет (т. нар. heap), 
където се съхранява реалната им стойност. Референцията представлява 
указател (адрес на клетка от паметта), сочещ реалното местоположение на 
стойността в динамичната памет. Референцията има тип и може да има като 
стойност само обекти от своя тип, т.е. тя е типизиран указател. Всички 
референтни (обектни) типове могат да имат стойност null. Това е 
специална служебна стойност, която означава, че липсва стойност. 
Референтните типове заделят динамична памет при създаването си и се 
освобождават по някое време от системата за почистване на паметта 
(garbage collector), когато тя установи, че вече не се използват от 
програмата. Тъй като заделянето и освобождаването на памет е бавна 
операция, може да се каже, че референтните типове са по-бавни от 
стойностните. 
Референтни типове са всички класове, масивите, изброените типове и 
интерфейсите, например типовете: Object, String, Integer, byte[]. С 
обектите, символните низове, масивите и интерфейсите ще се запознаем в 
следващите глави на книгата. Засега е достатъчно да знаете, че всички 

типове, които не са стойностни, са референтни и се разполагат в дина
мичната памет. 


стоиностите зададени на една променлива се наричат - литерали

Целочислени литерали 
Целочислените литерали представляват поредица от цифри, наставки и 
представки. Можем да представим целите числа в сорс кода на програмата 
в десетичен, шестнадесетичен и осмичен формат. - 
"0" представка означава стойност в осмична бройна система, 
например 007;  
101 - - 
"0x" и "0X" представки означават шестнадесетична стойност, например 
0xA8F1; 
"l" и "L" наставки означават данни от тип long, например 357L. 
Символът "l" лесно се бърка с 1 (едно), затова препоръчително е да 
използваме символа "L". 

int numberInDec = 16; 
int numberInOcatal = 020; 
int numberInHex = 0x10; 

// This will cause an error, because the value 234L is not int 
int longInt = 234L; 

Реални литерали 
Реалните литерали, както целочислените, представляват поредица от 
цифри, знак (+, -), наставки и символа за десетична запетая. Използваме 
ги за стойности от тип float и double. Реалните литерали могат да бъдат 
представени и в експоненциален формат. - - - - 
"f"  и "F" наставки означават данни от тип float; 
"d"  и "D" наставки означават данни от тип double; 
"e" означава експонента, примерно "e-5" означава цялата част да се 
умножи по 10-5. 
По подразбиране реалните литерали са от тип double. 
Реални литерали – примери 
Ето няколко примера за използване на реални литерали: 
// The following is the correct way of assigning the value: 
float realNumber = 12.5f; 
// This is the same value in exponential format: 
realNumber = 1.25e+1f; 
// The following causes an error because 12.5 is double 
float realNumber = 12.5;


Escaping последователностите са литерали, които представят последо
вателност от специални символи, които задават символ, който по някаква 
причина не може да се изпише директно в сорс кода. Такъв е например 
символът за нов ред. Те ни дават заобиколен начин (escaping) да напишем 
някакъв символ. 
Примери за символи, които не могат да се изпишат директно в сорс кода, 
има много: двойната кавичка, табулация, нов ред, наклонена черта и други. 
Ето някои най-често използваните escaping последователности: - - - - - - 
\' – единична кавичка 
\" – двойна кавичка 
\\ – лява наклонена черта 
\n – нов ред 
\t – отместване (табулация) 
\uXXXX – силвол, зададен с Unicode номера си, примерно \u03A7.

Символът \ (лява наклонена черта) се нарича още екраниращ символ, 
защото той позволява да се изпишат на екрана символи, които имат 
специално значение или действие и не могат да се изпишат в сорс кода. 


Всички двуаргументни оператори са ляво-асоциативни, означава, че изра
зите, в които участват се изчисляват от ляво на дясно, освен операторите 
за назначаване на стойности. Всички оператори за присвояване на 
стойности и условният оператор (:?) са дясно-асоциативни (изчисляват се 
от дясно на ляво).

Когато използваме операторите ++ и -- като суфикс (поставяме операторът 
непосредствено пред променливата) първо се пресмята новата стойност, а 
после се връща резултата и програмата продължава с решението на израза, 
докато при използването на операторите като постфикс (поставяме 
оператора непосредствено след променливата) първо се връща ори
гиналната стойност на операнда, а после се добавя или изважда единица 
към нея.

int a=1; // ++а суфикс когато ++ са отпред а++ пост фикс

	
Конкатенацията (слепването на два низа) на стрингове е 
бавна операция и трябва да се използва внимателно. 
Препоръчва се използването на класовете StringBuilder 
или StringBuffer при нужда от итеративни (повтарящи се) 
операции върху символни низове. 


В главата "Символни низове" ще обясним в детайли защо при операции над 
символни низове, изпълнени в цикъл, задължително се използват 
гореспоменатите класове. 


 3 << 2 означава, че искаме да преместим два пъти наляво 
битовете на числото 3. Числото 3 представено в битове изглежда така: 
“0000 0011", когато го преместим два пъти в ляво неговата битова стойност 
ще изглежда така: “0000 1100", а на тези битове отговаря числото 12. Ако 
се вгледаме в примера можем да забележим, че реално сме умножили 
числото по 4. Самото побитово преместване може да се представи като 
умножение (побитово преместване вляво) или делене (преместване в 
дясно) на променливата на числото 2. Това явление е следствие от 
природата на двоичната бройна система.

оператори за присвояване са +=
операнд е променливата 


Условен оператор ?: 
връща булева стоиност
операнд1 ? операнд2 : операнд3 

Ако операнд1 има стойност true, операторът връща резултат операнд2. Ако 
операнд1 има стойност false, операторът връща резултат операнд3. 

По време на изпълнение се пресмята стойността на първия аргумент. Ако 
той има стойност true, тогава се пресмята втория (среден) аргумент и той 
се връща като резултат. Обаче, ако пресметнатият резултат от първия 
аргумент е false, то тогава се пресмята третия (последния) аргумент и той 
се връща като резултат. 

Операторът instanceof се използва за проверка дали даден обект е 
съвместим с даден тип. 

 -----------------------------   -----------------------------   -----------------------------  ---------стр 118 -----------------------------   -----------------------------   -----------------------------  ------

Неявно (implicit) преобразуване на типове
Преобразуване от тип int към long може да се извърши без проверка 
по време на изпълнението, защото няма опасност от загуба на данни.
 
Преобразуване от тип double към long изисква преобразуване от 64
битова плаваща стойност към 64-битова целочислена. В зависимост 
от стойността, може да се получи загуба на данни, заради това е 
необходимо изрично преобразуване на типа.

Изрично (explicit) преобразуване на типове 

Изричното преобразуване на типове е нужно, когато има вероятност за 
загуба на данни. Когато конвертираме тип с плаваща запетая към цело
числен тип, винаги има загуба на данни, идваща от плаващата запетая и е 
задължително използването на изрично преобразуване (double към long). 
За да направим такова конвертиране е нужно изрично да използваме 
оператора за преобразуване на данни (cast оператора): (type). Възможно е 
да има загуба на данни също, когато конвертираме от тип с по-голям обхват 
към тип с по-малък (double към float или long към int).


double myDouble = 5.1d; 
System.out.println(myDouble); // 5.1 

long myLong = (long)myDouble;  
System.out.println(myLong); // 5 


myDouble = 5e9d; // 5 * 10^9  присвояваме на 
променливата myDouble стойност 5 милиарда.
System.out.println(myDouble); // 5.0E9 

int myInt = (int) myDouble; 
System.out.println(myInt); // 2147483647 
System.out.println(Integer.MAX_VALUE); // 2147483647
 MAX_VALUE, това е 
така, защото myDouble съдържа в себе си по-голяма стойност от обхвата на 
int. 

float heightInMeters = 1.74f;    
// Explicit conversion 
double maxHeight = heightInMeters;          
// Implicit 
double minHeight = (double) heightInMeters; // Explicit 
float actualHeight = (float) maxHeight;     
// Explicit 
float maxHeightFloat = maxHeight; // Compilation error! 

Възможни изрични преобразования 
Това са възможните явни (изрични) преобразувания и при всички тях има 
възможност за загуба на данни, така че внимавайте:
 - short към byte или char
 - char към byte или short
 - int към byte, short или char 
 - long към byte, short, char или int
 - float към byte, short, char, int или long
 - double към byte, short, char, int, long или float
 
 int a = 5; 
int b = ++a; 
 
System.out.println(a); // 6 
System.out.println(b); // 6



long myLong = Long.MAX_VALUE; 
int myInt = (int)myLong; 
System.out.println(myLong); // 9223372036854775807 
System.out.println(myInt); // -1


С главна буква почват сложните типове Object и String 

Примитивните типове са с малка буква byte,short,int,long,float,double,bool,char - почват с малка буква.

Не всички реални числа имат точно представяне в типовете float и double.
Примерно 0.1 се представя закръглено в float като 0.099999994.
За съжаление няма примитивен тип данни които съхранява примитивните типове с плаваща запетая при които няма такава загуба на данни.

Грешки при пресмятане с реални типове.
- При пресмятане с реални типове данни може да наблюдаваме странно поведение. Заради невъзможността някои числа 1/3 . 2/7 и други
да се представят в двоичен вид.

float sum = 0.1f; При записване в тип float знака f задава стойност литерал. За него повече в секция реални Литерали.

Име на променлива почва с малка буква и всяка следваща дума е прилепена и почва с голяма firstName.

Примитивните променливи се съхраняват в стека и се чистят от паметта като излезнат от обхват. Те са стойностни типове.

Референтни типове се съхраняват в стека за съхранение на програмата heap(референция към динамичната памет)
 където се съхранява реалната стойност.

При сравняване на два String Променливи се сравнява не стойността а мястото в паметта. 

Референцията е указател, адрес на кклетка от паметта сочи реалното меясто на стойността.

Като стойност има само обекти от своя тип. Тя е типизиран указател.

Референтния тип като е празен е null.
Референтния тип заделя памет и се освобождава от garbage collector.
Референтни типове са всички класове масиви, изброените типове , интерфеисите. например Object, String, Integer, byte[].

Литерал - стойността която се дава на променлива.

е- означава експонента тоест цялата част да се умнижи по 10 на -5 float number = 1.25e.

\(ляво наклонена е екраниращ символ, помага за изобразяването на други символи \t \n \")

Дясно асоциативни са от дясно наляво

а++  - постфикс първо смята после добавя
++а - първо добавя после смята 

Конкатенация - слепването на 2 низа е бана операция затова се препоръчва ползването на класовете StringBuilder Или StringBuffer.
(При нужда от повтарящи се операции върху символни низове)

syso(s instance of String); // true

От double към long се изисква изрично представяне за да няма загуба на данни

5е9д // 5*10 na 9ta

syso(myInt)// 2147483647
syso(Integer.MAX_VALUE)//2147483647

Implicit - неявно
Explicit - явно
 Събирането ставя от ляво надясно да внимавам при събиране на низове
 
  -----------------------------   -----------------------------  ----------- Глава 4. Вход и изход от конзолата  -----------------------------   -----------------------------   -----------------------------  --

Класът Scanner 
Този клас е въведен от Java 5.0 насам, за да улесни четенето на текст и 
числови данни от конзолата, както и от файлове. Класът представлява 
опростяване (абстракция) на сложното до скоро четене през потоци и 
буфери. Класът java.util.Scanner има различни методи улесняващи 
форматирания вход от конзолата: - - - - 
nextInt() / nextLong() за четене на целочислени типове 
nextFloat() / nextDouble() за четене на числа с плаваща запетая 
nextLine() за четене на цял символен низ, връща String 
hasNext***() проверява дали съществува съответния тип (long, float, 
…) 
Всеки от методите може да хвърли IllegalStateException, ако Scanner 
класът е вече затворен "scanner.close()". Подробно на изключенията, като


В почти никоя книга за програмиране няма да видите 
коректна обработка на изключения. Освобождаването на 
използваните ресурси също не винаги е дадено правилно. 

Една от причините за това е запазване на кода лесен за 
четене. Затова, НЕ копирайте код от учебни примери 
директно във вашата продукционна програма! 
В реални програми, правилно обработване на изключения 
и пълно освобождаване на ресурси често са подценявани! 
Това е много тежка част от програмирането, в която често 
ГРЕШАТ и най-добрите! 
 -----------------------------   -----------------------------  PRINTF -----------------------------   -----------------------------  
System.out.printf("%s is %d years old from %s!\n", name, age, town);

 -----------------------------   -----------------------------  ----------- Глава 5. Условни конструкции  -----------------------------   -----------------------------   -----------------------------  ---------
float value = 1.0f; 
float sum = 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 
 0.1f + 0.1f + 0.1f + 0.1f + 0.1f; 
System.out.println("Exact compare: " +  
 (sum==value)); 
System.out.println("Rounded compare: " +  
 (Math.abs(sum-value) < 0.000001)); 
 Резултатът от горния код показва, че сравнението с точност работи по
добре при реални числа, отколкото точното сравнение:

Exact compare: false 
Rounded compare: true

Логически оператори 
В настоящата секция ще разгледаме логическите оператори за сравнение. 
Те биват шест вида: &, |, ^, !, && и ||. 
Логически оператори && и || 
Тези логически оператори се използват само върху boolean стойност. За да 
бъде резултатът от сравняването на два израза с оператор && true (истина), 
то и двата операнда трябва да имат стойност true. Например: 

Този израз е истина, когато и двата операнда: (2 < 3) и (3 < 4) са true. 
Логическият оператор && се нарича още и съкратен оператор, тъй като той 
не губи време за допълнителни изчисления. Той изчислява лявата част на 
израза (първи операнд) и ако резултатът е false, то операторът && не губи 
време за изчисляването на втория операнд, тъй като е невъзможно 
крайният резултат да е "истина", ако и двата операнда не са "истина". По 
тази причина той се нарича още съкратен логически оператор "и". Ето 
един пример: 

 
boolean b = true && false; 
System.out.println("b = " + b); 

b = false 

Логически оператори & и | 
Операторите за сравнение & и | са подобни, съответно на && и ||. Разликата 
се състои във факта, че се изчисляват и двата операнда един след друг, 
независимо от това, че крайния резултат е предварително ясен. Затова и 
тези оператори за сравнение се наричат още несъкратени логически 
оператори. 
Например, когато се сравняват два операнда със & и първият операнд се 
сведе до "лъжа" въпреки това се продължава с изчисляването на вторият 
операнд. Резултатът е ясно, че ще бъде сведен до "лъжа". По същия начин, 
когато се сравняват два операнда със | и първия операнд се сведе до 
"истина", независимо от това се продължава с изчисляването на втория 
операнд и резултатът въпреки всичко се свежда до "истина".

Логически оператори ^ и !
System.out.println("Изключващо ИЛИ: " + ((2<3) ^ (4>3)));
Изключващо ИЛИ: false
Предходният израз е сведен до лъжа, защото и двата операнда: (2 < 3) и 
(4 > 3) са истина. 

Побитови операции върху цели числа 
 Това са операторите: &, | и ^. 

byte b1 = 6 & 5; // 00000110 & 00000101 = 00000100 
byte b2 = 7 | 9; // 00000111 | 00001001 = 00001111 
byte b3 = 5 ^ 4; // 00000101 ^ 00000100 = 00000001 
System.out.println(b1 + " " + b2 + " " + b3); //4  15  1 

Вложени if конструкции – добри практики
Поставяйте условните ситуации, които желаете да бъдат изпълнени 
първи на първо място;
Форматирайте винаги програмния код, с цел да бъде лесно четим и да 
не позволява двусмислие; 
 По-добре е използването на switch-case конструкция вместо вложени 
if конструкции, когато това е възможно; 

Правила за израза в switch
Тя изисква селектор, който се изчислява до цяло число от 
типа int, byte, char или enum.
 например, низ или 
число с плаваща запетая като селектор, това няма да работи в switch
 За нецелочислени типове данни трябва да използваме пос
ледователност от if конструкции.


Използването на множество етикети е удачно, когато искаме да бъде 
изпълнена една и съща конструкция в повече от един случай.

int number = 6; 
switch (number) { 
case 1: 
case 4: 
case 6: 
case 8: 
case 10: System.out.println("Числото не е просто!"); break; 
case 2: 
case 3: 
case 5: 
case 7: System.out.println("Числото е просто!"); break; 
default: System.out.println("Не знам какво е това число!");

Добри практики при използване на switch-case - Добра практика при използването на конструкцията за избор на 
вариант switch е default конструкцията да бъде поставяна на 
последно място, с цел програмния код да бъде по-лесно четим.
 
Добре е на първо място да бъдат поставяни онези case конструкции, 
които обработват най-често възникващите ситуации. 
Добре е да се използва default конструкция за ситуации, които не 
могат да бъдат обработени при нормално изпълнение на програмата.


int smallest = Integer.MAX_VALUE;  -----------------------------   -----------------------------  --------- слага големината на инт insert biggest int
 -----------------------------   -----------------------------  ----------- Глава 6. Цикли  -----------------------------   -----------------------------   -----------------------------   -----------------------------  
(while и do-while цикли) и for

Операторът break се използва за излизане от цикъла.
Kато кода след break не се изпълнява

Оператор continue 
Операторът continue спира текущата итерация на най-вътрешния цикъл, но 
не излиза от него.

Оператор break 
Операторът break се използва за излизане от цикъла. Операциите в цикъла 
се изпълняват в съответния им ред и при достигане на оператора break, 
независимо дали условието за излизане от цикъла е изпълнено, 
изпълнението на цикъла се прекратява, като кода след break не се 
изпълнява. 

foreach конструкция, наричана още разширен 
for-цикъл. Тази конструкция служи за обхождане на всички елементи на 
даден масив, списък или колекция от елементи.

Отпечатването на масив правим като се възползваме от помощния клас 
java.util.Arrays и метода му toString()
String[] array = { "one", "two", "three", "four" }; 
System.out.println(java.util.Arrays.toString(array)); 

foreach - се ползва само за четене на елементи от маси и е по бърз от for и се ползва когато няма да променяме елементите на масива

 -----------------------------   -----------------------------  ----------- Глава 7 Масиви  -----------------------------   -----------------------------   -----------------------------   -----------------------------  ---------
При декларация името на променливата, която е от тип масив, пред
ставлява референция (reference), която сочи към null, тъй като още не е 
заделена памет за елементите на масива. 

int[] myArray; - декларирана но не и създаднеа променлива, има я в стека но не и в хиипа
int[] myArray = new int[6]; - създаден масив, в хиипа вече има заделена памет за 6 елемента
в стека има адрес които показва къде се намира в паметта масива, а в хиипа(динамичната памет) пише стойността

	Деклариране на масив
	Масиви в Java декларираме по следния начин:
	int[] myArray;
	
	В Java масивите имат фиксирана дължина, която се указва при инициализирането му и определя броя на елементите му
	
	
		Kато правя масив от елементи масива се декларира ( Cat[] listofCats) 
		и после иницлиализира = (new Cat[10];)
		и после  всеки един елемент също се инициализира (listofCats[i] = new Cat();)

		Cat[] listofCats = new Cat[10];

        for (int i = 0; i < 10; i++) {
            listofCats[i] = new Cat();
            listofCats[i].setName("Cat "+ Sequence.nextValue());
            listofCats[i].sayMiau();
        }

 -----------------------------   -----------------------------  ----------- Глава 8 Бройни Системи  -----------------------------   -----------------------------   -----------------------------   -----------------------------  -

str 218
Типовете int и long в Java 
Типът long е най-големият целочислен тип със знак в Java. Той има 
размерност 64 бита (8 байта). При присвояване на стойности на промен
ливите от тип long се използват латинските букви "l" или "L", които се 
поставят в края на целочисления литерал. Поставен на това място, този 
модификатор означава, че литералът има стойност от тип long. Това се 
прави, защото по подразбиране целочислените литерали са от тип int.

long longValue = 9223372036854775807L; 
long newLongValue = 932145699054323689l;

Ето един пример: числото A8B6EA72(16) се представя в двете наредби на 
байтовете по следния начин: 
0x72
 0x72
 0xEA
 0xEA
 0xB6
 0xB6
 Little-Endian (LE)
 for 0xA8B6EA72
 0xA8
 0xA8
 0xA8
 0xA8
 0xB6
 0xB6
 0xEA
 0xEA
 Big-Endian (BE)
 for 0xA8B6EA72
 0x72
 0x72
 Java използва Big-Endian представянето, което е типично за хардуера на 
Sun Microsystems, и това трябва да се съобразява при обмяната на числови 
данни с други системи, които не са Java базирани. 

Типовете float и double в Java
При тип float имаме мантиса, която съхранява 8-9 значещи цифри, докато 
при тип double тя съхранява 16-17 значещи цифри.

Важно е да се знае, че в Java по подразбиране числата с плаваща запетая 
са от тип double.

double d = 0; 
System.out.println(d); 0.0 

System.out.println(1/d); Infinity 
System.out.println(-1/d); -Infinity 
System.out.println(d/d); NaN

Ако изпълним горния код с тип int вместо double, ще получим java.lang. 
ArithmeticException, защото целочисленото деление на 0 е непозволена 
операция.

Стриктен режим на изчисленията с плаваща запетая 
Изчисленията с плаваща запетая могат да се изпълняват и в стриктен 
режим. Стриктната аритметика при числата с плаваща запетая следва 
строги правила за операциите, които гарантират, че ще получим един и същ 
резултат от изчисленията при изпълнение на програмата на различни 
версии на виртуалната машина. 
Ако се налага да гарантирате побитова еднаквост на резултата във всяка 
реализация на виртуалната машина, трябва да ползвате модификатора 
strictfp. Той може да се приложи към клас, интерфейс или метод. Повече 
информация относно този въпрос, може да се намери в "The Java Language 
Specification": http://java.sun.com/docs/books/jls/.

Точност на числата с плаваща запетая 
double sum = 0.0;   
for(int i=1; i<=10; i++) { 
sum += 0.1; 
} 
System.out.println(sum); //0.9999999999999999

Причината за това е, че числото 0.1 няма точно представяне в типа double 
и се представя със закръгляне. Нека заменим double с float: 

float sum = 0.0f;   
for(int i=1; i<=10; i++) { 
sum += 0.1f; 
} 
System.out.println(sum);//1.0000001

Всичко изглежда коректно с изключение на мантисата, която има стойност, 
малко по-голяма от 1.6, а не точно 1.6, защото това число не може да се 
представи като сума от степени на 2. Грешката настъпва не при събирането, 
а още преди това – при записването на 0.1 в типа float. 

Числа с фиксирана запетая 
В някои езици за програмиране съществуват и числа с фиксирана 
запетая, например типът decimal в C#, типът money в SQL Server и типът 
number(10,2) в Oracle. В Java за съжаление няма такъв примитивен тип. 

Ако се нуждаем от точни изчисления (например за счетоводни или 
финансови цели), можем да ползваме класа BigDecimal, който не губи 
точност при пресмятанията, но за сметка на това работи чувствително по
бавно от float и double. Ето как изглежда в нов вариант нашата програма, 
която правеше грешки при сумиране на числа: 


import java.math.BigDecimal; 
public class Precision { 
public static void main(String[] args) {   
double sum = 0.0d; 
BigDecimal bdValue = new BigDecimal("0.1");  
BigDecimal bdSum = new BigDecimal("0.0"); 
for(int i=1; i<=10; i++) { 
sum += 0.1d; 
bdSum = bdSum.add(bdValue); 
} 
System.out.println("Double sum is: " + sum); 
System.out.println("BigDecimal sum is: " + bdSum); 
} 
} 

Double sum is: 0.9999999999999999 
BigDecimal sum is: 1.0

 -----------------------------   -----------------------------  ----------- Глава 9. Методи  -----------------------------   -----------------------------   -----------------------------   -----------------------------  ---------
 

Решенията на тези подзадачи 
наричаме подпрограми (subroutines).
В някои езици за програмиране подпрограмите могат да се срещнат под 
наименованията функции (functions) или процедури (procedures). В Java, те 
се наричат методи (methods). 

methodName(); -Тези два елемента определят така наречената спецификация 
на метода (някъде в литературата се среща и като сигнатура на метода). 

Правила за създаване на име на метод
- - 
-Името на метода трябва да започва с малка буква. 
-Трябва да се прилага правилото camelCase, т.е. всяка нова дума, която 
се долепя в задната част на името на метода, започва с главна буква. 
-Имената на методите е добре да бъдат съставени от глагол или от 
глагол и съществително име. 

Нека отбележим, че тези правила не са задължителни, а препоръчителни.
Но принципно, ако искаме форматирането на кода ни да е като на всички 
Java-програмисти по света е добре да спазваме конвенциите на Sun. 

Ето няколко примера:
print 
getName 
playMusic 
setUserName 

Освен това, името на метода трябва да описва неговата цел. Идеята е, ако 
човек, който не е запознат с програмата ни, прочете името на метода, да 
добие представа какво прави този метод, без да се налага да разглежда 
кода му. 

При определяне на името на метод се препоръчва да се 
спазват следните правила: - - 
-Името на метода трябва да описва неговата цел. 
-Името на метода трябва да започва с малка буква. - - 
-Трябва да се прилага правилото camelCase. 
-Името на метода трябва да е съставено от глагол или 
от двойка - глагол и съществително име.

Модификатори (modifiers)
Модификаторите, с които срещнахме до момента са public и static.

public -извикването на метода може да става от кой да е Java-клас, независимо къде се намира той.
private -  то този метод не може да бъде извикан извън класа, в който е деклариран.

Когато един метод притежава ключовата дума static, в декларацията си, 
наричаме метода статичен. Това означава, че този метод може да бъде 
извикан от кой да е друг метод, независимо дали другият метод е статичен 
или не. 

 при декларирането на метода, елементите на списъка от параметрите му, ще наричаме параметри 
 стойностите, които подаваме на метода,  наричаме аргументи
 
 str 248
 
 public static void main(String[] args) { 
 int[] arrArg = new int[] { 1, 2, 3 }; 
 
 System.out.print("Before modifyArr() the argument is: "); 
 System.out.println(Arrays.toString(arrArg)); 
 
 // Modifying the array's argument 
 modifyArr(arrArg); 
 
 System.out.print("After modifyArr() the argument is: "); 
 System.out.println(Arrays.toString(arrArg)); 
} 
Before modifyArr() the argument is: [1, 2, 3] 
In modifyArr() the param is: [5, 2, 3] 
After modifyArr() the argument is: [5, 2, 3] 

Причината за този резултат е, че при подаването на аргумент от референ
тен тип, се копира единствено стойността на променливата, която пази 
референция към обекта, но не се прави копие на самия обект.

Подаване на изрази като аргументи на метод

float oldQuantity = 3; 
float quantity = 2; 
printMax(oldQuantity * 5, quantity * 2);

public static void printNumber(float number) { 
System.out.println("The float number is: " + number); 
} 
public static void main(String[] args) { 
printNumber(5); 
} 

В примера, при извикването на метода printNumber() в метода main(), първо 
целочисления литерал 5, който по подразбиране е от тип int, се 
преобразува до съответната стойност с десетична запетая 5f. Така 
преобразувана, тази стойност се подава на метода printNumber(). 
The float number is: 5.0 

Деклариране на метод с параметър за променлив брой аргу
менти
public static long calcSum(int ... elements) { 
 long sum = 0; 
 for (int element : elements) { 
  sum += element; 
 } 
 return sum; 
} 
 
public static void main(String[] args) { 
long sum = calcSum(2, 5); 
 System.out.println(sum); 
  
 long sum2 = calcSum(4, 0, -2, 12); 
 System.out.println(sum2); 
 
 long sum3 = calcSum(); 
 System.out.println(sum3);   
} 

7 
14 
0 

Елементът от списъка от параметри на един метод, който 
позволява подаването на произволен брой аргументи при 
извикването на метода, трябва да се декларира винаги на 
последно място в списъка от параметри на метода.

 в декларацията на един метод не може да 
имаме повече от един параметър, който позволява подаването на 
променлив брой аргументи при извикването на метода


Варианти на методи (method overloading)

За еднозначното деклариране на метод в Java, по отноше
ние на списъка с параметри на метода, единствено имат 
значение: - типът на параметъра - последователността на типовете в списъка от пара
метри 
Имената на параметрите не се вземат под внимание. 

Характеристики на оператора return 
При изпълнението си операторът return извършва две неща: - - 
Прекратява изпълнението на метода. 
Връща резултата от изпълнението на метода на извикващия метод.

Когато методът има тип на връщана стойност void, тогава след return, не 
трябва да има израз, който да бъде върнат. В този случай употребата на 
return е единствено за прекратяване на метода:

public void printPositiveNumber(int number) { 
 if (number <= 0) { 
  // If the number is NOT positive, terminate the method 
  return; 
 } 
 System.out.println(number); 
} 

public int compareTo(int number1, int number2) { 
 if (number1 > number2) { 
  return 1; 
 } else if (number1 == number2) { 
  return 0; 
 } else { 
  return -1;
  } 
} 

Утвърдени практики при работа с методи 
Въпреки че в главата "Качествен програмен код" ще обясним повече за 
това, нека прегледаме едни някои основни правила при работа с методи, 
които показват добър стил на програмиране. Ето някои от тях: - - - - - 
Всеки метод трябва да решава самостоятелна, добре дефинирана 
задача. Това свойство се нарича strong cohesion. Фокусирането 
върху една, единствена задача позволява кодът да бъде по-лесен за 
разбиране и да се поддържа по-лесно. Един метод не трябва да 
решава няколко задачи едновременно! 
Един метод трябва да име, което описва какво прави той. Примерно 
метод, който сортира числа, трябва да се казва sortNumbers(), а не 
number() или processing() или method2(). Ако не можете да измислите 
подходящо име за даден метод, то най-вероятно методът решава 
повече от една задачи и трябва да се раздели на няколко отделни 
метода. 
Имената на методите е препоръчително да бъдат съставени от глагол 
или от глагол и съществително име (евентуално с прилагателно, което 
пояснява съществителното), примерно findSmallestElement() или 
sort(int[] arr) или readInputData(). 
Имената на методите в Java е прието да започват с малка буква. 
Използва се правилото camelCase, т.е. всяка нова дума, която се 
долепя в задната част на името на метода, започва с главна буква. 
Един метод или трябва да свърши работата, която е описана от името 
му, или трябва да съобщи за грешка. Не е коректно методите да 
връщат грешен или странен резултат при некоректни входни данни. 
Методът или решава задачата, за която е предназначен, или връща 
грешка. Всякакво друго поведение е грешно. Ще обясним в детайли 
по какъв начин методите могат да съобщават за грешки в главата 
"Обработка на изключения". 
Глава 9. Методи  281 - - - 
Един метод трябва да бъде минимално обвързан с обкръжаващата го 
среда (най-вече с класа, в който е дефиниран). Това означава, че 
методът трябва да обработва данни, идващи като параметри, а не 
данни, достъпни по друг начин и не трябва да има странични ефекти 
(например да промени някоя глобално достъпна променлива). Това 
свойство на методите се нарича loose coupling. 
Трябва да се избягват методи, които са по-дълги от "един екран". За 
да се постигне това, логиката имплементирана в метода, се разделя 
по функционалност на няколко по-малки метода и след това тези 
методи се извикват в "дългия" до момента метод. 
Понякога, за да се подобри четимостта и прегледността на кода, е 
добре функционалност, която е добре обособена логически, да се 
отделя в метод. Например, ако имаме метод за намиране на лице на 
квадрат, процесът на пресмятане на квадрат на едно число може да 
се дефинира в отделен метод и след това, този нов метод, да се извика 
от метода, който пресмята лицето на фигурата квадрат. Разбира се, 
това ще ни даде възможност да преизползваме метода за намиране на 
квадрата на едно число и на други места, когато ни е нужно. 


 -----------------------------   -----------------------------  ----------- Глава 10. Рекурсия  -----------------------------   -----------------------------   -----------------------------   -----------------------------  -----

Пряка и косвена рекурсия 
Когато в тялото на метод се извършва обръщение към същия метод, 
казваме, че методът е пряко рекурсивен. 
Ако метод A се обръща към метод B, B към C, а С отново към А, казваме, че 
методът А, както и методите В и C са непряко (косвено) рекурсивни или 
взаимно-рекурсивни.

Дъно на рекурсията
Дъно на рекурсията 
Реализирайки рекурсия, трябва да сме сигурни, че след краен брой стъпки 
ще получим конкретен резултат. Затова трябва да имаме поне един случай, 
чието решение можем да намерим директно, без рекурсивно извикване. 
Тези случаи наричаме дъно на рекурсията. 
В примера с числата на Фибоначи, дъното на рекурсията е случаят, когато 
n e по-малко или равно на 2. При него можем директно да върнем резултат, 
без да извършваме рекурсивни извиквания, тъй като по дефиниция първите 
два члена на редицата на Фибоначи са равни на 1. 


Рекурсия или итерация 
В конкретния случай, реализацията на итеративно решение е също толкова 
кратка, но по-ефективна: 
public static long factorial(int n) { 
	long result = 1; 
		for (int i = 1; i <= n; i++) { 
		result = result * i; 
		} 
	return result; 
} 

Кога да използваме рекурсия и кога итерация?
Трябва да се ползва този метод които е по лесен за четене и разбиране и не дърпа много ресурси.

Още за рекурсията и итерацията

По принцип, когато имаме линеен изчислителен процес, не трябва да 
използваме рекурсия, защото итерацията може да се реализира изключи
телно лесно и води до прости и ефективни изчисления.

void recursion(parameters) { 
do some calculations; 
recursion(some parameters); 
do some calculations; 
} 

При такъв процес, когато имаме само едно рекурсивно извикване с тялото 
на рекурсивния метод, не е нужно да ползваме рекурсия, защото итера
цията е очевидна.


Понякога, обаче имаме разклинен или дървовиден изчислителен 
процес. Например имитацията на N вложени цикъла не може лесно да се 
замени с итерация. Вероятно сте забелязали, че нашият итеративен 
алгоритъм, който имитира вложените цикли работи на абсолютно различен 
принцип. 

По принцип всяка рекурсия може да се сведе до итерация чрез използване 
на стек на извикванията (какъвто се създава по време на изпълнение на 
програмата), но това е сложно и от него няма никаква полза. Рекурсията 
трябва да се ползва, когато дава просто, лесно за разбиране и ефективно 
решение на даден проблем, за който няма очевидно итеративно решение. 

При дървовидните изчислителни процеси на всяка стъпка от рекурсията, се 
извършват няколко на брой рекурсивни извиквания и схемата на 
извършване на изчисленията може да се визуализира като дърво (а не като 
списък, както при линейните изчисления). Например при изчислението на 
числата на Фибоначи видяхме какво дърво на рекурсивните извиквания се 
получава. 

Типичната схема на дървовидния изчислителен процес можем да опишем 
чрез псевдокод така:

void recursion(parameters) { 
do some calculations; 
recursion(some parameters); 
... 
recursion(some other parameters); 
do some calculations; 
} 

Дървовидните изчислителни процеси не могат директно да бъдат сведени 
до рекурсивни (за разлика от линейните). Случаят с числата на Фибоначи 
е простичък, защото всяко следващо число се изчислява чрез предходните, 
които можем да изчислим предварително. Понякога, обаче всяко следващо 
число се изчислява не само чрез предходните, а и чрез следващите и 
рекурсивната зависимост не е толкова проста. В такъв случай рекурсията 
се оказва особено ефективна. 
Ще илюстрираме последното твърдение с един класически пример.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Внимавайте, когато пишете рекурсивен код. 
Рекурсията е много мощен метод за решаване на комбинаторни задачи 
(задачи, в които изчерпваме варианти), но не е за всеки.

Лесно можете да накарате програмата да "зависне" или 
да препълните стека с бездънна рекурсия. 

 Винаги търсете итеративните 
решения, освен, ако не разбирате в голяма дълбочина как да ползвате 
рекурсията!

Applications of Merge Sort:
//        Sorting large datasets
//        External sorting (when the dataset is too large to fit in memory)
//        Inversion counting
//        Merge Sort and its variations are used in library methods of programming languages. For example its variation TimSort is used in Python, Java Android and Swift. The main reason why it is preferred to sort non-primitive types is stability which is not there in QuickSort. For example Arrays.sort in Java uses QuickSort while Collections.sort uses MergeSort.
//        It is a preferred algorithm for sorting Linked lists.
//        It can be easily parallelized as we can independently sort subarrays and then merge.
//        The merge function of merge sort to efficiently solve the problems like union and
//        https://www.geeksforgeeks.org/merge-sort/

Колкото до задачата за търсене на най-къс път в лабиринт, можете да я 
решите елегантно без рекурсия с т.нар. метод на вълната, известен още 
като BFS (breadth-first search), който се реализира елементарно с една 
опашка. Повече за алгоритъма "BFS" можете да прочетете на неговата 
страница в Уикипедия: http://en.wikipedia.org/wiki/Breadth-first_search. 

https://en.wikipedia.org/wiki/Breadth-first_search
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

 -----------------------------   -----------------------------  ----------- Глава 11 Създаване и  използване на обекти -----------------------------   -----------------------------  ---------------------
Ще вмъкнем само, че програмните техники на ООП 
често включват капсулация, модулност, полиморфизъм и наследяване. Тези 
техники са извън целите на настоящата тема, затова ще ги разгледаме по
късно в главата "Принципи на обектно-ориентираното програмиране". Сега 
ще се спрем на обектите като основно понятие в ООП.

Софтуерните обекти 
моделират обекти от реалния свят или абстрактни концепции (които също 
разглеждаме като обекти). 

 Абстрактните 
обекти са понятия в някоя предметна област, които се налага да 
моделираме и използваме в компютърна програма. Примери за абстрактни 
обекти са структурите от данни стек, опашка, списък и дърво. Те не са 
предмет на настоящата тема, но ще ги разгледаме в детайли по-нататък.

Член-данни (data members) – представляват променливи, вградени в 
обектите, които описват състоянията им. - Методи (methods) – вече сме ги разглеждали в детайли. Те са 
инструментът за изграждане на поведението на обектите.

Състояния (states) – това са характеристики на обекта, които по 
някакъв начин го определят и описват по принцип или в конкретен 
момент. 
 Състояния на кучето 
могат да бъдат "име", "цвят на козината" и "порода", а негови поведения – 
"лаене", "седене" и "ходене".

 характеристиките на даден обект (които ще наричаме 
атрибути) и неговото поведение 

 Атрибутите на класа се дефинират като собствени променливи 
в тялото му (наречени член-променливи). 
 Поведението на обектите се 
моделира чрез дефиниция на методи в класовете.

 -----------------------------   -----------------------------  -----------str317 -----------------------------   -----------------------------   -----------------------------   -----------------------------  ----------------------

Всеки обект е инстанция на конкретен клас. Тази инстанция се характе
ризира със състояние (state) – множество от стойности, асоциирани с 
атрибутите на класа. 

В контекста на така въведените понятия, обектът се състои от две неща: 
моментното състояние и поведението, дефинирано в класа на обекта. 
Състоянието е специфично за инстанцията (обекта), но поведението е общо 
за всички обекти, които са представители на този клас. 

Какво представляват класовете в Java?
Класовете в Java могат да съдържат следните елементи:
 - Полета (fields) – член-променливи от определен тип;
 - Свойства (properties) – това са специален вид елементи, които 
разширяват функционалността на полетата като дават възможност за 
допълнителна обработка на данните при извличането и записването 
им. Ще се спрем по-подробно на тях в темата "Дефиниране на 
класове"; 
- Методи – реализират манипулацията на данните

!!!!!!!!!!!!!!!!!!!!!!за програмиста е от  значение какво правят методите, а не как го правят. !!!!!!!!!!!!!!!!!!!!!!

Създаването на обекти от предварително дефинирани класове по време на 
изпълнението на програмата става чрез оператора new.

На променливата someCat от тип Cat присвояваме новосъздадена инстанция 
на класа Cat. Променливата someCat стои в стека, а нейната стойност 
(инстанцията на класа Cat) стои в динамичната памет: 

Cat myBrownCat = new Cat("Johnny", "brown"); // taka se davat stoinosti na konstruktora na klasa

myBrownCat = null; // rucno osvobojdavane na obekt

myCat.name = "Alfred"; // dostup do pole na obekt

методите на класовете имат модификатори за достъп public, private или protected,

Статични полета и методи
 В ООП 
има специална категория полета и методи, които се асоциират с тип данни 
(клас), а не с конкретна инстанция (обект). Наричаме ги статични 
членове (static members), защото са независими от конкретните обекти. 
Нещо повече – те се използват, без да има създадена инстанция на класа, 
в който са дефинирани. Ще разгледаме накратко статичните членове в Java – това могат да бъдат полета, методи и конструктори. 
Статично поле или метод се дефинира чрез ключовата дума static, пос
тавена преди типа на полето или типа на връщаната стойност на метода. 
При дефинирането на статичен конструктор думата static се поставя преди 
името на конструктора. 

Кога да използваме статични полета и методи? 

Вече обяснихме основната разлика между двата вида членове. Нека 
интерпретираме класа като категория, а обекта като елемент, попадащ в
тази категория. Тогава статичните членове отразяват състояния и поведе
ния на самата категория, а нестатичните – състояния и поведения на 
отделните елементи на категорията.

Сега ще обърнем по-специално внимание на инициализацията на статич
ните и нестатичните полета. Вече знаем, че нестатичните полета се ини
циализират заедно с извикването на конструктор на класа при създаването 
на негова инстанция – или в тялото на конструктора, или извън него. 
Инициализацията на статичните полета, обаче, не може да става при 
създаването на обект от класа, защото те могат да бъдат използвани, без 
да има създадена инстанция на този клас. Важно е да се знае следното: 

Статичните полета се инициализират, когато типът данни 
(класът) се използва за пръв път по време на изпъл
нението на програмата.


Клас, който има само private конструктори не може да 
бъде инстанциран. Такъв клас обикновено има само ста
тични членове и се нарича utility клас. 

Класът String -  представя символни низове 
Класът Math -Съдържа методи за извършването на основни числови операции като 
повдигане в степен, логаритмуване, коренуване и тригонометрични 
функции. 


 Константите в Java се изписват само с главни букви, като за 
разделител между думите се ползва символът "_" (долна черта). 

Понеже тази променлива rnd е 
дефинирана в самия клас (не в main() метода), тя е достъпна от целия клас 
(от всички негови методи) и понеже е обявена за статична, тя е достъпна и 
от статичните методи.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!ДА РАЗГЛЕДАМ StringBuilder класа!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Какво представляват пакетите в Java? 
Пакетите (packages) в Java представляват именувани групи класове, 
които са логически свързани и се съхраняват в отделни файлове в една и 
съща директория във файловата система. Прието е името на папката да 
съвпада с името на пакета и имената на файловете да съвпадат с имената 
на класовете, които се съхраняват в тях. Трябва да отбележим, че в някои 
езици за програмиране компилацията на изходния код на даден пакет е 
независима от разпределението на елементите на пакета в папки и файлове 
на диска. В Java, обаче, така описаната файлова организация на пакетите 
е напълно задължителна (ако не е спазена, възниква грешка при 
компилацията).

Прието е имената на пакетите в Java да започват с 
малка буква и да бъдат изписвани в camelCase.  stringUtils

Класовете трябва да имат уникални имена само в рамките 
на пакета, в който са дефинирани. Имената на класовете 
извън него са произволни.

Включване на пакет 
При изграждането на приложения в зависимост от предметната област 
често се налага многократното използване на два или повече класа от един 
пакет. За удобство на програмиста има механизъм за включване на пакет 
към текущото приложение, което става по време на компилацията му. По 
този начин могат свободно да се използват всички класове, дефинирани в 
пакета, без да е необходимо използването на техните пълни имена. 
import <package_name>.*; 

* означава, че включваме всички класове, 
които се съдържат в пакета <package_name>.
По този начин не се включват класовете от вложените 
пакети на пакета, който включваме. 
 -----------------------------   -----------------------------  -----------Глава 12. Обработка на изключения  -----------------------------   -----------------------------   -----------------------------  ----
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Не съм разгледал цялата глава след 354стр При По подробно търсене на проблем да видя книгата
Изключение
Изключение (exception) в общия случай е уведомление за дадено 
събитие, нарушаващо нормалната работа на една програма. Изключенията
дават възможност това необичайно събитие да бъде обработено и програмата
 да реагира по някакъв начин. Когато възникне изключение конкрет
 ното състояние на програмата се запазва и се търси обработчик на 
изключението (exception handler).
Изключенията се предизвикват или "хвърлят" (throw an exception).

Прихващане и обработка на изключения
Exception handling (инфраструктура за обработка на изключенията) 
е част от средата – механизъм, който позволява хвърлянето и 
прихващането на изключения. Част от тази инфраструктура са дефинираните
 езиковите конструкции за хвърляне и прихващане на изключения. 
Тя се грижи и затова изключението да стигне до кода, който може да го 
обработи.

В ООП се ползват изключения.
В Процедурно ориентирания подход се ползва връщане на стойност от метод която е отрицателна или друг код на грешка.


Грешка се хвърля когато дадена операция не може да се изпълни успешно

Методът, който извиква операцията може да прихване 
изключението и да обработи грешката или да пропусне изключението и да 
остави то да бъде прихванато от извикващият го метод. Така не е задължително
 грешките да бъдат обработвани непосредствено от извикващия 
код, а могат да се оставят за тези, които са го извикали. Това дава 
възможност управлението на грешките и необичайните ситуации да се 
извършва на много нива.

Друга основна концепция при изключенията е тяхната йерархична същност.
 Изключенията в ООП са класове и като такива могат да образуват 
йерархии посредством наследяване. При прихващането на изключения 
може да се обработват наведнъж цял клас от грешки, а не само дадена 
определена грешка (както е в процедурното програмиране).

Изключенията в Java
Изключение (exception) в Java представлява събитие, което уведомява
програмиста, че е възникнало обстоятелство (грешка) непредвидено в 
нормалния ход на програмата. Това става като методът, в който е възникнала 
грешката изхвърля специален обект съдържащ информация за вида 
на грешката, мястото в програмата, където е възникнала, и състоянието на 
програмата в момента на възникване на грешката.
Всяко изключение в Java носи т.нар stack trace – информация за това къде точно в кода е възникнала 
грешката.

FileInputStream fis = new FileInputStream(fileName);
Ако се случи изключение, променливата fis няма да бъде инициализирана 
и ще остане със стойност null.

Стека е мястото където се записват всички променливи в програмата

Програмна конструкция try-catch

Конструкцията се състои от един try блок, обгръщащ валидни Java 
конструкции, които могат да хвърлят изключения, следван от един или 
много catch блока, които обработват различни по тип изключения. В catch
блокът ExceptionType трябва да е тип на клас, който е наследник на класа 
java.lang.Throwable. В противен случай ще получим проблем при 
компилация. Изразът в скобите след catch играе роля на декларация на 
променлива и затова вътре в блока catch можем да използваме objectName, 
за да извикваме методите или да използваме свойствата на изключението.

public static void readFile(String fileName) {
	try {
			// Exceptions could be thrown below
			FileInputStream fis = new FileInputStream(fileName);
			BufferedReader in = new BufferedReader(
			new InputStreamReader(fis));
			String tmp = null;
			while ((tmp = in.readLine()) != null) {
			System.out.println(tmp);
		}
		in.close();
		fis.close();
	} catch (FileNotFoundException e) { 
		// ako lipswa fail 6te se izpulni tozi catch
		// Exception handler for FileNotFoundException
		// We just inform the client that there is no such file
		System.out.println("The file \"" + fileName +
		"\" does not exist! Unable to read it.");
	} catch (IOException e) {
		// ako ima gre6ka ot tip IOException se izpulnqwa tozi catch i poneje ne znaem kakwa e gre6kata izpiswame cqlata informaciq v
		// standartniq izhod
		// Exception handler for IOException
		e.printStackTrace();
	}
}

Отпечатването на цялата информация от изключението 
(stack trace) на потребителя не винаги е добра практика! 
Как най-правилно се обработват изключения е описано в 
частта за добри практики.

Stack Trace
Информацията, която носи т. нар. Stack trace, съдържа подробно описание
на естеството на изключението и за мястото в програмата, където то е 
възникнало. Stack trace се използва, за да се намерят причините за възникването
 на изключението и последващото им отстраняване (довеждане 
до нормалното изпълнение на програмата). Stack trace съдържа голямо 
количество информация и е предназначен за анализиране само от програмистите
 и администраторите, но не и от крайните потребители на програмата, които
 не са длъжни да са технически лица. Stack trace е стандартно 
средство за търсене и отстраняване (дебъгване) на проблеми.

Как да разчетем "Stack Trace" - стр 349
Всички методи от стека на извикванията са показани на отделен ред. Найотгоре 
е методът, който първоначално е хвърлил изключение, а най-отдолу 
е main() методът. Всеки метод се дава заедно с класа, който го съдържа и 
в скоби реда от файла, където е хвърлено изключението, примерно 
ReadFile.readFile(ReadFile.java:12). Редовете са налични само ако класът
е компилиран с опция да включва дебъг информация (номерата на редовете 
и т.н.).

Ако методът е конструктор, то вместо името му се използва <init> 
java.io.FileInputStream.<init>(Unknown Source). Ако липсва информация 
за номера на реда, където е възникнало изключението се изписва Unknown 
Source. Ако методът е native (външен за Java виртуалната машина), се 
изписва Native Method.

Хвърляне на изключения (конструкцията 
throw)
Изключения се хвърлят с ключовата дума throw, като първо се създава 
инстанция на изключението и се попълва нужната информация за него. 
Могат да се хвърлят само класове наследници на java.lang.Throwable.
Ето един пример:

public static void main(String... args) {
RuntimeException exception = new RuntimeException("Problem");
throw exception;
}

Exception in thread "main" java.lang.RuntimeException: Problem
at introjavabook.Program.main(Program.java:10)

Видове изключения в Java
В Java има 3 вида изключения: проверени (checked), непроверени 
(unchecked) и грешки (errors).

Принципът "хвани или изхвърли"
Принципът "хвани или изхвърли" важи за изключенията, които задължително трябва да се обработят.
 Те или трябва да бъдат прихванати, или изхвърлени от метода, в който са възникнали, или от някой от следващите 
методи от стека на извикванията.
За изключенията, които трябва да бъдат обработени, има два варианта:
- Изключението да бъде обработено (хвани)


public static void openFile(String fileName) {
	try {
		FileInputStream fis = new FileInputStream(fileName);
	} catch (FileNotFoundException e) {
	// ...
	}
}

Отговорността за изключението да бъде оставена на друг
(изхвърли), като той бъде задължен да обработи това изключение 
или да задължи някой друг:

public static void openFile(String fileName)
throws FileNotFoundException {
FileInputStream fis = new FileInputStream(fileName);
}
По този начин 
методът прехвърля отговорността за обработката на даден тип изключения 
на извикващия метод.

-стр 351
!!! мои мисли : мога да разуча за кодовете които методите връщат които са за грешка и тях да ползвам!!!

Checked exceptions
Checked (проверени) са изключения, които задължително трябва да 
спазват принципа "хвани или изхвърли" и това се гарантира от компилатора.
 Тези изключения наследяват класа java.lang.Exception, но не 
наследяват java.lang.RuntimeException.

Checked са изключения, които една добре написана програма трябва да 
очаква и би трябвало да може да се възстанови от тях

Например програма, която чете данни от сървър с бази от данни. Ако 
кабелът до сървъра в дадения момент бъде прекъснат, програмата ще 
получи ConnectException и може да съобщи на потребителя да опита отново 
или да му обясни, че в момента може да използва само други части на 
програмата

Checked изключенията или трябва да бъдат прихванати и обработени или 
трябва да бъдат изхвърляни изрично чрез throws декларация в съответния 
метод. Ако нито едно от двете не е направено, компилаторът ще даде 
съобщение за грешка.

Грешки (Errors)
Грешките (errors) са критични ситуации (fatal errors), при които изпълнението 
на програмата обикновено не може да се възстанови и трябва 
принудително да завърши. Пример за такава грешка е java.lang. 
OutOfMemoryError. Когато паметта свърши, програмата обикновено няма 

какво да направи и трябва принудително да запише състоянието си (за да 
няма загуба на данни) и да завърши.

Unchecked exceptions
Unchecked (непроверени) изключения, са изключения, които не са задъл
жени да спазват принципа "хвани или изхвърли". Тези изключения 
наследяват класа RuntimeException. Възникването на такова изключение 
най-често означава бъг в програмата или неправилна употреба на някоя 
библиотека.
Вероятно сте се сблъсквали с грешката NullPointerException. Тя е типичен 
представител на unchecked изключенията. Може да възникне по 
невнимание, когато се обърнем към обект, който няма стойност. Прихва
щането и обработването на такива проблеми не е задължително, но е 
възможно.

Throwable
Класът java.lang.Throwable е базовият клас на всички грешки и изключения 
в Java. Само този клас или негови наследници могат да се хвърлят от JVM 
(Java Virtual Machine – виртуалната машина на Java) или могат да 
бъдат хвърляни чрез throw оператора. Само този клас или негови 
наследници могат да бъдат аргументи на catch клаузата.

Throwable – характеристики
Throwable съдържа копие на стека по време на създаването на изключе
нието. Съдържа още текстово съобщение описващо грешката (попълва се 
от кода, който хвърля изключението или някой наследяващ клас). Всяко 
изключение може да съдържа още причина (cause) за възникването му –
друго изключение, което е причина за появата на проблема. Можем да го 
наричаме вътрешно / обвито изключение (inner / wrapped exception)
или вложено изключение.
Външното изключение се нарича обгръщащо / обвиващо изключение. 
Така може да се навържат много изключения. В този случай говорим за
верига от изключения (exception chain).
Обвити изключения – защо ги има?
Защо се налага едно изключение да инициира друго?
Добра практика е всеки модул / компонент / програма да дефинира малък 
брой application exceptions (изключения написани от автора на модула /
програмата) и този компонент да се ограничава само до тях, а не да хвърля 
стандартни изключения (от Java API), наричани още системни 
изключения (system exceptions). Така ползвателят на този модул / 
компонент знае какви изключения могат да възникнат в него и няма нужда 
да се занимава с технически подробности.


Например един модул, който се занимава с олихвяването в една банка би 
трябвало да хвърля изключения само от неговата бизнес област, примерно 
InterestCalculationException и InvalidPeriodException, но не и изключения 
като FileNotFoundException, DivideByZeroException и NullPointerException.
При възникване на някое изключение, което не е свързано директно с 
проблемите на олихвяването, то се обвива в друго изключение от тип 
InterestCalculationException и така извикващия метод получава 
информация, че олихвяването не е успешно, а като детайли за неуспеха 
може да разгледа оригиналното изключение, причинител на проблема.

Тези application exceptions от бизнес областта на решавания проблем, за 
които дадохме пример, обаче не съдържат достатъчно информация за 
възникналата грешка, за да бъде тя поправена. Затова е добра практика в 
тях да има и техническа информация за оригиналния причинител на 
проблема, която е много полезна за дебъгване например.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Не съм разгледал цялата глава след 354стр При По подробно търсене на проблем
 да видя книгата от throwable надолу
 
 Throwable – методи
Ето най-основните методи на изключенията (класът Throwable):
public class Throwable implements Serializable {
public Throwable() {
public Throwable(String message) {
public Throwable(Throwable cause) {
public Throwable(String message, Throwable cause) {
public String getMessage() {...}
public Throwable getCause() {...}
public void printStackTrace() {...}
public StackTraceElement[] getStackTrace() {...}
public synchronized Throwable initCause(Throwable cause) {
}
Нека обясним накратко тези методи:
- Имаме четири конструктора с различните комбинации за съобщение и 
обвито изключение.
- Методът getMessage() връща текстово описание на изключението. Ако 
изключението е FileNotFoundException, то описанието може да казва 
кой точно файл не е намерен. Всяко изключение само решава какво 
съобщение да върне. Най-често се позволява на хвърлящият 
изключението да сложи това описание.
- Методът getCause() връща вътрешното / обвитото изключение.
- Методът printStackTrace() отпечатва класът на изключението, 
съобщението и стека на грешката и стека на цялата верига от 
извикани методи, заедно с цялата верига на вложени едно в друго
изключения.
- Методът getStackTrace() връща целия стек, който се пази в 
изключението. Съществува от Java версия 1.4.
- Методът initCause() метод използван преди Java 1.4 за задаване на 
вътрешното / обвитото изключение. Сега се използват конструкторите, но този метод също продължава да работи.

Вериги изключения – частта Caused by

package introjavabook;
	public class ExceptionProgram {
		public static void main(String... args) {
		try {
			throw new NullPointerException("Problem");
		} catch (NullPointerException npe) {
			throw new RuntimeException(npe);
		}
	}
}

Exception in thread "main" RuntimeEx: NullPointerEx: Problem
at ExceptionProgram.main(ExceptionProgram.java:13)
Caused by: java.lang.NullPointerException: Problem
at ExceptionProgram.main(ExceptionProgram.java:11)

Това ни дава 
полезна информация за това как се е стигнало до хвърлянето на изключението, което разглеждаме.


Error
Изключенията от тип Error и неговите наследници индикират за сериозен 
проблем (неочаквани грешки). Използват се при възникване на грешки –
такива, от които програмата не може да се възстанови и не се очаква те да 
бъдат хващани. Всички такива грешки наследяват класа Error.

Тъй като класа Error наследява Throwable, той притежава всички негови 
свойства: носи в себе си stack trace и съобщение за грешка, съдържа 
методите getMessage(), printStackTrace() и getStackTrace() и може да 
съдържа вложено изключение, достъпно с getCause().
Пример за такова изключение е OutOfMemoryError, което възниква при 
заделяне на памет, когато не може да бъде отделено достатъчно място за 
новосъздаващия се обект.


Декларацията throws за методи
Когато трябва да върнем грешка която викащия метод да си я обработи връщаме списък с грешките.

public static void readFile(String fileName) 
throws FileNotFoundException, IOException {
}
Това е примерен метод, които изхвърля два типа изключения -
FileNotFoundException и IOException. В случая FileNotFoundException е 
излишно обявен, тъй като е наследник на IOException.

Изхвърлянето на изключения към предходния метод обикновено означава, 
че изключенията трябва да се прихванат и обработят там. Най-правилното 
място да се обработи дадено изключение е там, където се изпълнява бизнес 
операцията, която е била прекъсната поради някакъв проблем.

Във визуалните (GUI) приложения грешката трябва да се покаже на 
потребителя под формата на диалогов прозорец съдържащ описание, 
съобразено с познанията на потребителите. 

При уеб приложения 
грешката се визуализира като червен текст в началото на страницата или 
след полето, за което се отнася.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Правило!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Един метод трябва да обработва само изключенията, за 
които е компетентен, които очаква и за които има знания 
как да ги обработи. Останалите трябва да ги изхвърля към 
извикващия метод.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Правило!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Прихващане на изключения на нива. Примера с четене на файл. Ако файла го няма, там имаме проверка, в метода.
Ако при четенето на файла има грешка това вече в извикващия метод трябва да има проверка.

Конструкцията try-finally

Всеки блок try може да съдържа блок finally. Блока finally се изпълнява 
винаги при излизане от try блока, независимо как се излиза от try блока. 
Това гарантира изпълнението на finally блока дори ако възникне 
неочаквано изключение или се излезе с израз return.

Блокът finally няма да се изпълни, ако по време на 
изпълнението на блока try виртуалната машина прекрати 
изпълнението си!
 
 Всеки try блок може да има един единствен блок finally освен блоковете 
catch.
В случай на нужда от освобождаване на вече заети ресурси блока finally
е незаменим. Ако го нямаше, никога не бихме били сигурни дали разчистването няма случайно да се прескочи при неочаквано изключение или 
заради използването на return, continue, или break изрази


Сигурното затваряне на поток се прави по следния начин:
FileInputStream fis = null;
try {
		fis = new FileInputStream("fileName.txt");
		// Using "fis" here ...
	} finally {
		// Always close "fis"
		if (fis != null) {
			fis.close();
	}
}
Алтернативно решение
Опростена версия на горния пример се явява следната конструкция:
FileInputStream fis = new FileInputStream("fileName.txt");
try {
// Using "fis" here …
} finally {
fis.close();
}
Предимството е по-краткия запис – спестяваме една излишна декларация 
на променливата fis и избягваме проверката за null. Проверката за null е 
излишна, защото инициализацията на потока е извън try блока и ако е 
възникнало изключение докато тя се изпълнява изобщо няма да се стигне 
до изпълнение на finally блока и затварянето на потока.
Недостатък е невъзможността да се обработят изключения възникнали при 
инициализацията в същия try блок. Трябва да използваме допълнителен 
try блок, който да прихване всички възможни checked exceptions по време 
на инициализацията или да ги изхвърлим от самия метод.

Освобождаване на множество ресурси

Освобождават се в ред обратен на заделянето
FileInputStream fis = new FileInputStream(fileName);
try {
BufferedReader in = new BufferedReader(

new InputStreamReader(fis));
try {
// Using "in" here
} finally {
in.close();
}
} finally {
fis.close();
}

или

FileInputStream fis = null;
BufferedReader in = null;
try {
fis = new FileInputStream(fileName);
in = new BufferedReader(new InputStreamReader(fis));
// Using "in" here …
} finally {
if (in != null) {
in.close();
}
if (fis != null) {
fis.close();
}
}
. Все пак вторият подход е малко рисков, тъй като във 
finally блока възникне изключение (което почти никога не се случва) при 
затварянето на първия поток, вторият поток няма да бъде затворен. При 
първия подход няма такъв проблем, но се пише повече код.

} catch (IOException e) {
// Handle IOException and all its descendants
}
Горният пример ще прихване не само IOException, но и всички негови 
наследници в това число FileNotFoundException, EOFException, 
RemoteException и десетки други

Прихващането на Exception и Throwable не е добра практика и се 
предпочита прихващането на по-конкретни групи от изключения като 
IOException или на един единствен тип изключение като например 
FileNotFoundException.

Предаване на грешките за обработка в стека на 
методите – прихващане на нива

Като начало в method1() трябва анализираме кода за грешка връщан от 
метода readFile() и евентуално да предадем на method2(). В method2() 
трябва да анализираме кода за грешка връщан от method1() и евентуално 
да го предадем на method3(), където да се обработи самата грешка.
Как можем да избегнем всичко това? Да си припомним, че виртуалната 
машина търси прихващане на изключения назад в стека на извикване на 
методите и позволява на всеки един от методите в стека да дефинира 
прихващане и обработка на изключението. Ако методът не е заинтересован, 
чрез throws клаузата, просто препраща изключението по-назад в стека:

Добри практики при работа с изключения
Това са важни правила, които трябва да 
запомните и следвате. Не ги пренебрегвайте!

str 373

По принцип вторият вариант се счита за по-лош, тъй като изключенията 
трябва да се ползват за изключителна ситуация, а липсата на файла в 
нашия случай е по-скоро обичайна ситуация.

Лоша практика е да се разчита на изключения за обработка на очаквани 
събития и от гледна точка на производителността. Хвърлянето на изключение е бавна
 операция – трябва да се инициализира stack trace, трябва да 
се открие обработчик на това изключение и т.н.

Точната граница между очаквано и неочаквано 
поведение е трудно да бъде ясно дефинирана. Най-общо 
очаквано събитие е нещо свързано с функционалността 
на програмата. Въвеждането на грешно име на файла е 
пример за такова. Спирането на тока докато работи тази 
програма, обаче не е очаквано събитие.

Препоръчително е изключения, които не са хванати от никой, а такива 
може да са само runtime изключенията или грешките, да се хващат от общ 
глобален "прихващач", който да ги записва (в най-общия случай) някъде, 
а на потребителя да показва "приятелско" съобщение в стил: "Възникна
грешка, опитайте по-късно". Добре е винаги да показвате освен съобщение 
разбираемо за потребителя и техническа информация (stack trace), която, 
обаче е достъпна само ако потребителят я поиска

str 375

Хвърляйте изключенията на съответното ниво на 
абстракция!

Ако, обаче имате 
метод, който извършва олихвяване на всички сметки в една банка, той не 
трябва да хвърля ArrayIndexOutOfRange, тъй като това изключение не е от 
бизнес областта на банковия сектор и олихвяването. Нормално е 
олихвяването да хвърли изключение InvalidInterestException с подходящо 
съобщение за грешка от бизнес областта на банките, за което би могло да 
бъде закачено оригиналното изключение ArrayIndexOutOfRange.


Ако изключението има причинител, запазвайте го!
Винаги, когато при прихващане на изключение хвърляте ново изключение 
от по-високо ниво на абстракция, добавяйте към него оригиналното изключение.

Давайте подробно описателно съобщение при 
хвърляне на изключение!
Примерно: 
Error reading settings file: 
C:\Users\Administrator\MyApp\MyApp.settings


Error reading settings file: 
C:\Users\Administrator\MyApp\MyApp.settings. Number expected at line 
17.

Това съобщение вече само говори за проблема. Очевидно имаме грешка на 
ред 17 във файла MyApp.settings, който се намира в папката 
C:\Users\Administrator\MyApp. В този ред трябва да има число, а има нещо 
друго. Ако отворим файл, бързо можем да намерим проблема, нали?

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Правило!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Винаги давайте адекватно, подробно и конкретно съобщение за грешка, когато хвърляте изключение! 
Ползвателят на вашия код трябва само като прочете съобщението, 
веднага да му стане ясно какъв точно е проблемът, къде се е случил и каква е причината за него.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Правило!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Ще дадем още няколко примера:
- Имаме метод, който търси число в масив. Ако той хвърли 
IndexOutOfRangeException, от изключително значение е индексът, 
който не може да бъде достъпен, примерно 18 при масив с дължина 7.
Ако не знаем позицията, трудно ще разберем защо се получава 
излизане от масива.
- Имаме метод, който чете числа от файл. Ако във файла се срещне 
някой ред, на който няма число, би трябвало да получим грешка, 
която обяснява, че на ред 17 (примерно) се очаква число, а там има 
стринг (и да се отпечата точно какъв стринг има там).
- Имаме метод, който изчислява стойността на числен израз. Ако 
намерим грешка в израза, изключението трябва да съобщава каква 
грешка е възникнала и на коя позиция. Кодът, който предизвиква 
грешката може да ползва String.format, за да изгради съобщението 
за грешка. Ето един пример:
throw new ExpressionParseException(
String.format("Invalid character at position %d." +
"Number expected but found character '%s'.", index, ch);


Никога не игнорирайте прихванатите изключения!
Никога не игнорирайте изключенията, които прихващате, без да ги обработите. Ето един пример как не трябва да правите:
FileInputStream fis = null;
try {
	fis = new FileInputStream("file.bin");
	byte[] data = new byte[10];
	fis.read(data, 0, 10); 
	} catch(FileNotFoundException e) {
	} catch(IOException e) {
	} finally {
		try {
		fis.close();
	} catch(IOException e) {
	}
}
В този пример авторът на този ужасен код прихваща изключенията и ги 
игнорира. Това означава, че ако липсва файлът, който търсим, програмата 
няма да прочете нищо от него, но няма и да съобщи за грешка. Ползвателят 
на този код бъде заблуден, че файлът е бил прочетен, а той всъщност 
липсва.
Начинаещите програмисти понякога пишат такъв код, защото компилаторът 
ги задължава да прихващат изключенията при работа с файлове и те не 
знаят как да го направят. Вие нямате причина да пишете такъв код!
Ако все пак, понякога вашата програмна логика изисква да игнорирате 
изключение, направете го, но сложете изрично коментар, с който обяснявате действията си.
 Ето едно типично изключение от това правило:
FileInputStream fis = null;
try {
	fis = new FileInputStream("file.bin");
	// Read the file here 
	} finally {
	try {
	fis.close();
	} catch(IOException e) {
	// Ignore the exception. The file is already closed
	}
}
В примера по-горе си позволяваме да игнорираме изключението, което 
може да възникне при затваряне на файл, защото ако файлът не може да 
бъде затворен, това означава, че той или е бил вече затворен от някой 
други, или не може да бъде затворен и няма смисъл да го мъчим повече. И 
в двата случая няма по-адекватна обработка на грешката, освен да я 
игнорираме.

Отпечатвайте съобщенията за грешка на конзолата 
само в краен случай!

Представете си например нашия метод, който чете настройките на приложението от текстов файл.
 Ако възникне грешка, той би могъл да я отпечата 
на конзолата, но какво ще стане с извикващия метод? Той ще си помисли, 
че настройките са били успешно прочетени, нали?
Има едно много важно правило в програмирането:
Един метод или трябва да върши работата, за която е 
предназначен, или трябва да хвърля изключение.

Това правило можем да обясним в по-големи детайли: Един метод се пише, 
за да свърши някаква работа. Какво върши методът трябва да става ясно 
от неговото име. Ако не можем да дадем добро име на метода, значи той е 
прави много неща и трябва да се раздели на части. Ако един метод не може 
да свърши работата, за която е предназначен, той трябва да хвърли 
изключение. Например, ако имаме метод за сортиране на масив с числа, 
ако масивът е празен, методът или трябва да върне празен масив, или да съобщи за грешка.
Грешните входни данни трябва да предизвикват 
изключение, не грешен резултат! 
Например, ако се опитаме да вземем от 
даден стринг с дължина 10 символа подстринг от позиция 7 до позиция 12, 
трябва да получим изключение, не да вземем по-малко символи. Точно така 
работим методът substring() в класа String.

Не прихващайте всички изключения!
try {
String fileContents = readFileContents("file.txt");
} catch (Throwable t) {
System.out.println("File file.txt not found.");
}

В този код предполагаме, че имаме метод readFileContents(), който прочита 
текстов файл и го връща като String. Забелязваме, че catch блокът 
прихваща наведнъж всички изключения (независимо от типа им), не само 
FileNotFoundException, и при всички случаи отпечатва, че файлът не е 
намерен. Хубаво, обаче има ситуации, които са непредвидени. Например 
какво става, когато файлът е заключен от друг процес в операционната 
система. В такъв случай JVM ще се генерира FileAccessDeniedException, но 
съобщението за грешка, което програмата ще изведе, ще е грешно и 
подвеждащо. По същия начин, ако при отварянето на файла свърши 
паметта, ще се генерира съобщение OurOfMemoryError, но отпечатаната 
грешка ще е отново некоректна.
Изводът е от този пример е, че трябва да обработваме само грешките, които 
очакваме и за които сме подготвени. Останалите не трябва въобще да ги 
прихващаме.


Прихващайте само изключения, от които разбирате 
и знаете как да обработите!
Вече обяснихме, че даден метод трябва да прихваща само изключение, от 
които разбира, а не всички. Това е много важно правило, което непременно 
трябва да спазвате. Ако не знаете как да обработите даден exception, или 
не го прихващайте, или го обгърнете с ваш exception и го хвърлете по стека 
да си намери обработчик. Това е правилото: или добавете изключението в 
throws декларацията на вашия метод или го хванете и го опаковайте във 
ваше изключение и го хвърлете на извикващия метод. Иначе можете да 
стигнете до некоректна обработка на грешки, която може да доведе до 
много странни проблеми.

---------Въпроси
--- kakvo bqha checked i  unchecked exceptions

StringBuilder е направен, като директен заместител за StringBuffer  но без гаранция за синхронизация
ако трябва да се ползват повече нишки не е за предпочитане StringBuilder тогава е по добре да се ползва StringBuffer
String Builder - na kratko prawim promenliwa ot tozi klas kum moqto s append builder.append(); 
builder (обект от тип builder )e string koito mu prilepqme tekst i sled append moje pak da se dobavi append 
koeto sled wseki izvle4en red slaga o6te ne6to
content.append(line).append(System.lineSeparator()); // Добавяме реда и нов ред
insert(); - служи за да се сложи текст на определено място в стринга

regular Expressions

StringBuffer - 

Scanner -

FileInputStream - 

InputStreamReader - подадените му байтови потоци ги прави на знакови


 -----------------------------   -----------------------------  -----------Глава 13. Символни низове -----------------------------   -----------------------------  -----------
Класът java.lang.String
Класът java.lang.String позволява обработка на символни низове в Java. 
Работата със String ни улеснява при манипулацията на текстови данни: 
построяване на текстове, търсене в текст и много други операции.

String greeting = "Hello, Java";
По 
принцип ние можем да избегнем използването на класа, като декларираме 
променлива от тип char[] и запълним елементите на масива символ по 
символ. Недостатъците на това обаче са няколко:
1. Запълването на масива става символ по символ, а не наведнъж.
2. Трябва да знаем колко дълъг ще е текстът, за да сме наясно дали ще 
се побере в заделеното място за масива.
3. Обработката на текстовото съдържание става ръчно.

Класът String – универсално решение?

В Java съществуват и други класове за обработка на текстс някои от тях 
ще се запознаем по-нататък в главата.


Класът String има важна особеност – последователностите от символи, 
записани в променлива от класа, са неизменими (immutable). Веднъж 
записано, съдържанието на променливата не се променя директно - ако 
опитаме да променим стойността, тя ще бъде записана на ново място в 
динамичната памет, а променливата ще започне да сочи към него.

 Ако няколко променливи сочат към 
една и съща област в паметта с дадена стойност, тази стойност не може да 
бъде директно променена. Промяната ще се отрази само на променливата, 
чрез която е редактирана стойността, тъй като това ще създаде нова 
стойност в динамичната памет и ще насочи въпросната променлива към нея, 
докато останалите променливи ще сочат на старото място.


Символни низове – прост пример

String msg = "Stand up, stand up, Balkan superman.";

// изкарва на всеки ред по буква от текста (променливата)
for (int i = 0; i < msg.length(); i++) {
System.out.printf("msg[%d] = %c%n", i, msg.charAt(i));
}

String quote = "Book’s title is \"Intro to Java\"";
Book's title is "Intro to Java"

Пример за втория случай са обозначаването на 
символ за нов ред (\n), табулация (\t), избор на символ по неговия Unicode 
(\uXXXX, където с X се обозначава кодът) и др.


Деклариране на символен низ

Можем да декларираме променливи от тип символен низ чрез класа 
java.lang.String:
String str;

Създаване и инициализиране на символен низ

 Създаването на променлива на клас (познато 
още като инстанциране) е процес, свързан със заделянето на област в 
динамичната памет.

Можем да инициализираме променливи по 3 начина:
1. Чрез задаване на символна константа
2. Чрез присвояване стойността на друг символен низ
3. Чрез предаване стойността на операция, връщаща символен низ

Задаване на символна константа (литерал) 
Използваме такъв тип инициализация, когато знаем стойността, която 
трябва да се съхрани в променливата.
String website = "http://academy.devbg.org";

Присвояване стойността на друг символен низ
String source = "Some source";
String assigned = source;

Промяната на коя да е от променливите обаче ще се отрази само и 
единствено на нея, поради неизменността на типа String. Това не се отнася 
за останалите референтни типове, които не са неизменни (immutable), 
защото при тях промените се нанасят на адреса в паметта и всички 
референции сочат към променения обект.

Предаване стойността на операция, връщаща символен низ  (concatenation)

String email = "some@email.bg";
String info = "My mail is: " + email + ".";
// My mail is: some@email.bg.

Четене и печатане на конзолата

Scanner input = new Scanner(System.in);
String name = input.nextLine();
System.out.printf("Hello, %s, have a nice reading!", name);

Операции върху символни низове
 Езикът Java ни дава набор от готови функции, които ще 
използваме за манипулация над стринговете.

Сравняване на низове по азбучен ред
Може да се възползваме от различни възможности на класа String.

Сравнение за еднаквост

Ако условието изисква да сравним два символни низа и да установим дали 
стойностите им са еднакви или не, удобни методи са equals(…) и equalsIgnoreCase(…).
equalsIgnoreCase(…)- игнорира разликата между малки и главни букви
equals(…) - прави разлика между малки и главни букви

String word1 = "Java";
String word2 = "JAVA";
System.out.println(word1.equals(word2)); // false
System.out.println(word1.equalsIgnoreCase(word2)); // true

Сравнение на низове по азбучен ред
compareTo(…)- прави разлика между главни и малки букви
compareToIgnoreCase(…)- не прави разлика между главни и малки букви
Методът compareTo(…) сравнява 2 символни низа за равенство или различие. 
За да бъдат два низа с еднакви стойности, то те трябва да имат една и съща 
дължина (брой символи) и символите да бъдат еднакви и подредени в един 
и същ ред.

compareTo(…)
връща положително число, отрицателно число или 0 в зависимост от 
лексикографската подредба.

String score = "sCore";
String scary = "scary";
System.out.println(score.compareToIgnoreCase(scary)); // 14
System.out.println(scary.compareToIgnoreCase(score)); // -14
System.out.println(scary.compareTo(score)); // 32

Различието се открива едва в третия 
символ, който в първия низ е "o", а във втория: "a". Тогава изваждаме кода 
на параметъра от кода на променливата, за която е извикан методът. 
Крайният резултат е 14 (кодът на 'o' е 111, кодът на 'a' e 97; 111-97 = 14). 
Извикването на същия метод с разменени места на променливите връща -
14, защото тогава отправната точка е низът scary и кодовете се изваждат в 
обратен ред.

Защо операторите == и != не работят за низове?
тук влизат правилата за сравняване на препратки към паметта, 
известни още като референции или указатели.

Тогава сравняването на две 
променливи str1 и str2 няма да сравнява техните стойности, а дали те сочат 
към една и съща област в динамичната памет.

String hel = "Hel";
String hello = "Hello";
String copy = hel + "lo";
System.out.println(copy == hello); // false

Сравняването на низове с оператора == в Java е груба 
грешка, защото този оператор сравнява адресите на 
низовете, не техните стойности! За сравняване на низове 
използвайте методите equals() / equalsIgnorecase() и 
compareTo() / compareToIgnoreCase() и проверявайте за изрично за null, защото извикването на equals() върху null
стойност предизвиква NullPointerException.

Любопитен обаче е следният случай:

String hello = "Hello";
String same = "Hello";
System.out.println(same == hello); // true

Оптимизация на паметта при символни низове
Истината обаче е, че съществува 
оптимизация във виртуалната машина, която спестява създаването на 
дублиращи символни низове в паметта. Тази оптимизация се нарича 
strings interning (интерниране на низовете)

Когато инициализираме променлива от тип String, динамичната памет се 
обхожда и се прави проверка дали такава стойност вече съществува. Ако 
съществува, новата променлива просто започва да сочи към нея.

Оптимизация на паметта при символни низове стр 394

Все пак, ако не искаме да използваме оптимизацията, можем изрично да 
създадем нови обекти от тип String и да зададем техните стойности:

String str1 = new String("Hello");
String str2 = new String("Hello");
System.out.println((str1==str2)); // false

Връщаният резултат е 
false, тъй като всяка променлива сочи на отделно място в паметта:

Символните низове са неизменими! Всяка промяна на 
променлива от тип String създава нов низ, в който се 
записва резултатът. Така че операциите, които прилагате 
на символните низове, връщат като резултат препратка 
към получения резултат.

Възможна е и обработката на символни низове без създаването на нови 
обекти в паметта при всяка корекция. За целта е създаден класът 
StringBuilder, с който ще се запознаем по-долу.

Долепване на низове (конкатенация)
То може да бъде извършено по 2 начина: чрез 
метода concat(…) или с оператора +, или +=. 

String greet = "Hello, ";
String name = "reader!";
String result = greet.concat(name);

String greet = "Hello, ";
String name = "reader!";
String result = greet + name;

Търсене на низ в друг низ
Java платформата ни предоставя 2 метода за търсене на низове:
- indexOf(…)- започва от началото на низа към неговия край. Когато се интересуваме от първия срещнат резултат, тогава 
използваме indexOf(…)
String book = "Introduction to Java book";
int index = book.indexOf("Java");
System.out.println(index); // index = 16

- lastIndexOf(…)- търси отзад-напред.  Ако искаме да претърсваме низа от неговия край 
(например за откриване на последната точка в името на даден файл или 
последната наклонена черта в URL адрес), уместно решение е 
lastIndexOf(…).


Понякога искаме да открием всички срещания на даден подниз в текущия 
низ. Използването на двата метода само с 1 подаден аргумент за търсен низ 
не би ни свършило работа, защото винаги ще връща само първото срещане
на подниза. Ето защо е възможно подаването на втори параметър за индекс, 
който посочва началната позиция, от която започва търсенето.


Всички срещания на дадена дума – пример

String quote = "The main subject in the \"Intro Java\"" +
" book is Java for Java newbies.";
int index = quote.indexOf("Java");
while(index != -1) {
	System.out.println("Java found on index: " + index);
	index = quote.indexOf("Java", index + 1);
}
Ето защо 
правилното търсене на следващ резултат е с аргумент index + 1. За 
lastIndexOf(…), аналогично, тъй като търсенето е в обратен ред, индексът 
се намалява с единица.

Извличане на част от низ
substring(…)-  можем да извлечем даден подниз по зададени начална и крайна  позиция в текста
 Ако крайната позиция бъде пропусната, то подтекстът ще 
бъде копиран от началната позиция до края на символния низ. 

String path = "C:\\Pics\\Rila2008.jpg";
String filename = path.substring(8, 16);
// filename = "Rila2008"

Извикването на метода substring(индекс1, индекс2) извлича 
подниз на дадена променлива, който се намира между 
индекс1 и (индекс2 – 1) включително. Символът на 
посочената позиция – индекс2 – не се взима предвид! 
Например, ако посочим substring(5, 10), ще бъдат 
извлечени символите между индекс 5 и 9 включително, а 
не между 5 и 10!

Как бихме могли да изведем името на файла и неговото разширение?

String path = "C:\\Pics\\Rila2008.jpg";
int index = path.lastIndexOf("\\"); // index = 7
String fullName = path.substring(index + 1);
// fullname = "Rila2008.jpg"


Разцепване на низ по разделител
Един от най-гъвкавите методи за работа със символни низове е split(…). 
String listOfBeers = "Amstel, Zagorka, Tuborg, Becks.";

? На пръв поглед може да изглежда трудно –
трябва да търсим с indexOf(…) за специален символ, след това да отделяме 
подниз със substring(…), да итерираме всичко това в цикъл и да записваме 
резултата в дадена променлива.
 
Разделяне на низа по множество от разделители – пример
Има и доста по-лесен и гъвкав начин да разрешим проблема:
String[] beersArr = listOfBeers.split("[ ,.]");

Използвайки вградената функционалност на split(…), ще разделим 
съдържанието на даден низ по разделителите, които са подадени като 
аргумент на метода. В квадратни скоби са изредени всички разделители, 
които искаме да използваме за отправна точка при разделянето на думите. 
Всички поднизове, между които присъстват интервал, запетая или точка, 
ще бъдат отделени и записани в масива beersArr. 

Все пак, ако обходим масива и изведем елементите му един по един, 
резултатите ще бъдат: "Amstel", "", "Zagorka", "", "Tuborg", "" и "Becks". 
Получаваме 7 резултата, вместо очакваните 4. Причината е, че при разделянето
 на текста се откриват 3 подниза, които съдържат 2 разделителни 
символа един до друг (например запетая, последвана от интервал). В този 
случай празният низ между двата разделителя също е част от връщания 
резултат.

Как да премахнем празните елементи?
for(String beer : beersArr) {
	if(!beer.equals("")) {
		System.out.println(beer);
	}
}

Този подход обаче няма да премахне празните низове от масива. Затова 
можем да променим аргумента, който подаваме на метода split(…), като 
добавим знака +:
String[] beersArr = listOfBeers.split("[ ,.]+");
След тази промяна масивът beersArr ще съдържа 4 елемента – четирите 
думи от променливата listOfBeers. Добавяйки плюс към заградените 
символи, ние инструктираме метода split(…) да работи по следния начин: 
"Върни всички поднизове от променливата, които са разделени от 
интервал, запетая или точка. Ако срещнеш два или повече съседни 
разделителя, считай ги за един".

Обяснение на метода split(…)

Методът split(…) действително е един от най-комплексните и гъвкави 
методи за работа със символни низове. Неговата функционалност се дължи 
на факта, че той приема като аргумент регулярен израз (regular 
expression). Регулярният израз е символен низ, представящ множества
или подмножества. Пример за множества и подмножества са всички малки 
букви; всички цифри; главните латински букви от 'A' до 'M'; всички малки 
и главни латински и кирилски символи, и др. Обединяването на множества 
позволява по-прецизна обработка на текстови данни: извличане на
определени ресурси от текстове, търсене на телефонни номера, откриване 
на електронна поща в текст, разделяне на всички думи в едно изречение и 
т.н.

Квадратните скоби служат за изреждане на отделни символи, подмножества 
и множества. Например, за да дефинираме множество от всички малки 
латински букви, регулярният израз ще изглежда така:
String small = "[a-z]";

По този начин посочваме множеството от символи, намиращи се в 
интервала от 'a' до 'z'. Ако искаме да обхванем всички малки и главни букви 
на латиница и кирилица, можем да дефинираме следното множество:
String allLetters= "[a-zA-Zа-яА-Я]";

В сила са и операндите OR, AND и NOT за работа с множества. Можем, 
например, да разделим даден текст по всички символи, които не са цифри:
String nan = "[^0-9]";

Възможно е изграждането на сложни регулярни изрази, изградени от много 
обединения и сечения на множества. Те могат да бъдат използвани за 
задаване на набор от разделители при използването на split(…), за търсене 
на подниз, съвпадащ с определен шаблон, или за заместване на един низ с 
друг по определени критерии.

Регулярни изрази – полезни конструкции str 403

Регулярни изрази – полезни конструкции
Съществуват предефинирани класове, които обобщават често използвани 
множества. Някои от тях са:
- . (символът точка) – обхваща всички възможни символи (може да 
прихваща или не обозначенията за нов ред)
- \d – обхваща всички цифри (еквивалентно на [0-9])
- \D – обхваща всички символи, които не са цифри (еквивалентно на 
[^0-9])
- \s – знак за интервали: [ \t\n\x0B\f\r]
- \S – всички знаци, освен тези за интервали: [^\s]
- \w – всички символи, считани за дума: [a-zA-Z_0-9]
- \W – еквивалентно на [^\w]
Когато използвате предефинираните класове в Java, не 
забравяйте, че обратната наклонена черта е екраниращ 
знак! По тази причина е необходимо да добавяме още 
една обратна наклонена черта, за да използваме предефинираните класове.

Използване на предефинирани класове – пример

public class CatalogApplication {
	public static void main(String[] args) {
		String catalog = 
		"MicrowaveOven: 170, \n" +
		"AudioSystem: 125, \n" +
		"TV: 315, \n" +
		"Refrigerator: 400";
		System.out.println(catalog);
		/* MicrowaveOven: 170, 
		AudioSystem: 125,
		TV: 315, 
		Refrigerator: 400 */
		String[] products = catalog.split("[\\d\\s,:]+");
		for(String product : products) {
		System.out.print(product + " ");
		}
		// MicrowaveOven AudioSystem TV Refrigerator
		System.out.println();
		String[] prices = catalog.split("\\D+");
		for(String price : prices) {
		System.out.print(price + " ");
		}
		// Result: 170 125 315 400
	}
}

Структурата на каталога е еднотипна: име_на_продукт: цена, последвани от нов ред.
 При първото разделяне използваме класа \D, като разделяме текста на всички символи,
 които не са цифри. След това, за да изведем 
единствено имената на продуктите, използваме по-сложно множество: 
[\d\s,:], което обхваща всички цифри, всички интервали (необходимо ни 
е за премахването на разстоянията и знаците за нов ред), запетаи и 
двоеточия.
Виждате, че преди използваните класове е необходимо поставянето на още 
една наклонена черта, която указва, че наклонената черта от дефиницията 
на класа не е екраниращ символ.

Могат да бъдат дефинирани много по-сложни и прецизни регулярни изрази, 
които да решават по-специфични проблеми.
Повече информация за регулярните изрази и как да се възползваме от тях 
в Java може да откриете в уроците на Sun: java.sun.com/docs/
books/tutorial/essential/regex/ или в онлайн Java API спецификацията:
java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html.


Замяна на подниз с друг
Примерно в документ сме сгрешили един имейл на много места и може да го оправим с медотда а replace(…).

String doc = "Hello, some@mail.bg, " +
"you have been using some@mail.bg in your registration.";
String fixedDoc = doc.replace("some@mail.bg", "osama@laden.af");
System.out.println(fixedDoc);

Реализиран е и еквивалентен, но универсален вариант, който замества 
поднизовете, отговарящи на даден регулярен израз. Когато се налага да 
работим с по-обща информация, на помощ ни идва метода replaceAll(…).

Замяна на телефони със звездички – пример
Ако имаме служебен документ, който се използва само в офиса, и в него 
има лични данни, можем да ги цензурираме, преди да ги пратим на клиента.

String doc = "Smith's number: 0892880022 \n"+ 
"Franky can be found at 0853445566 \n" +
"so as Steven - 0811654321";
replacedDoc = doc.replaceAll("(08)[0-9]{8}", "$1********");
System.out.println(replacedDoc);

//Smith's number: 08**********
//Franky can be found at 08********** 
//so as Steven - 08**********

Обяснение на аргументите на replaceAll(…)

 Примерът може да бъде допълнително подобрен за 
подбиране на номерата само от дадени мобилни оператори, за работа с 
телефони на чуждестранни мрежи и др., но за целта на примера е 
използван опростен вариант. Литералът "08" е заграден от кръгли скоби. 
Те служат за обособяване на отделна група от регулярния израз. Групите 
могат да бъдат използвани за обработка само на определена част от израза, 
вместо целия. В нашия пример, групата е използвана в заместването –
откритите съвпадения са заместени с "$1********" – текстът от първата 
група на регулярния израз + последователни 8 звездички за цензурата. Тъй 
като дефинираната от нас група винаги е константа – 08, то заместеният 
текст ще бъде във формат: 08********. 

Преминаване към главни и малки букви
toLowerCase() 
toUpperCase()

String text = "All Kind OF LeTTeRs";
System.out.println(text.toLowerCase());
// all kind of letters

Ако искаме да сравним въведен вход от потребителя и не сме сигурни по 
какъв точно начин е написан той, можем да уеднаквим регистъра на 
буквите и да го сравним с дефинираната от нас константа.
По този начинне правим разлика за малки и главни букви. Например, ако имаме входен 
панел на потребителя, в който въвеждаме име и парола, и няма значение 
дали паролата е написана с малки, или главни букви, може да направим 
подобна проверка:


String pass1 = "Parola";
String pass2 = "PaRoLa";
String pass3 = "parola";
boolean isEqual;
isEqual = pass1.toUpperCase().equals("PAROLA") ; // true
isEqual = pass2.toUpperCase().equals("PAROLA") ; // true
isEqual = pass3.toUpperCase().equals("PAROLA") ; // true

В този случай малко обезсмисляме действието на метода 
equalsIgnoreCase(…), като дефинираме проверката ръчно.

Премахване на празно пространство в края на низ

Въвеждайки текст във файл или през конзолата, понякога се появяват 
'паразитни' интервали в началото или в края на текста. В началото или след 
края на дадена променлива може да се запише неволно някой друг 
интервал или табулация, които да не могат да се доловят на пръв поглед. 
Това може да не е съществено, но ако валидираме потребителски данни, би 
било проблем от гледна точка на проверка съдържанието на входната 
информация. На помощ идва методът trim() – той се грижи именно за 
премахването на паразитните празни места. Извиквайки метода на 
променлива от тип String, която има празни места в началото или края, той 
ще се погрижи за премахването им. Празните места могат да бъдат 
интервали, табулация, нови редове и др.

String fileData = " \n\n Mario Peshev ";

Ако изведем съдържанието на конзолата, ще получим 2 празни реда, 
последвани от няколко интервала, търсеното от нас име и още няколко 
допълнителни интервала в края. Тъй като на нас ни е необходимо само 
името, може да редуцираме информацията от променливата и да премахнем 
ненужните интервали:
String reduced = fileData.trim(); // result  "Mario Peshev"

 -----------------------------   -----------------------------   -----------------------------   StringBuilder  -----------------------------   -----------------------------   -----------------------------  ---------
Построяване на символни низове. StringBuilder

всички корекции, приложени върху съществуващ низ, връщат 
като резултат нов символен низ. Например, използването на методите 
replace(…), toUpperCase(), trim() не променят стринга, за който са 
извикани, а заделят нова област в паметта, в която се записва новото 
съдържание. Това има много предимства, но в някои случаи може да ни 
създаде проблеми с производителността на приложенията ни, ако не знаем 
тази съществена особеност.

Долепяне на низове в цикъл: никога не го правете!

Подобен проблем може да срещнем, когато се опитаме да съединяваме 
символни низове в цикъл, без значение от това дали конкатенацията е 
извършена чрез concat(…) метода или с операторите + и +=. Проблемът е 
пряко свързан с обработката на низовете и динамичната памет, в която се 
съхраняват те.

Как работи съединяването на низове?

Създаването на променливата result ще задели нова област от 
динамичната памет, в която ще запише резултата от str1 + str2, който е 
"SuperStar". След това самата променлива ще пази адреса на заделената 
област. Като резултат ще имаме 3 области в паметта, както и 3 референции 
към тях. Това е удобно и ясно, но създаването на нова област, записването 
на стойност, създаването на нова променлива и реферирането й към 
паметта е времеотнемащ процес, който би бил проблем при многократното 
му повтаряне в цикъл.

За разлика от други езици за програмиране, в Java не е дефинирано 
понятието "деструктор", т.е. не е необходимо ръчното освобождаване на 
обектите, записани в паметта.

Съществува специален механизъм, наречен 
garbage collector (система за почистване на паметта), който се грижи 
за изчистването на неизползваната памет и ресурси. Системата за 
почистване на паметта е отговорна за освобождаването на динамичната 
памет, когато вече не се използва. Създаването на много обекти, придружени с множество референции в паметта, е вредно, защото запълват 
паметта и се налага автоматичното изпълнение на garbage collector от 
виртуалната машина. Това отнема немалко време и забавя цялостното 
изпълнение на процеса.

Защо долепянето на низове в цикъл е лоша практика?

String collector = "Numbers: ";
for (int idx = 1; idx <= 5000; idx++) {
collector += idx;
}
// result Numbers: 12345678910111213141516...
итерацията на цикъла отнема 2-4 секунди. (koeto e mnogo vreme)

Конкатениране в цикъл с 50000 итерации - пример

Второ, за да отчетем правилно времето за 
изпълнение, ще извеждаме на конзолата текущата дата и час преди и след 
изпълнението на цикъла. Трето, за да видим, че променливата съдържа 
желаната от нас стойност, ще изведем част от нея на конзолата. Причината 
да не извеждаме цялата променлива е, че конзолата има буфер с определен 
размер и при стандартни настройки не може да изведе пълната на

променливата. Ако искате да се уверите, че цялата стойност е запаметена, 
може да увеличите ръчно размера на буфера от настройките на конзолата 
на Eclipse (Window | Preferences | Run/Debug | Console) или да запишете 
съдържанието на променливата в текстов файл.
Крайният вариант на примера би изглеждал така:

System.out.println(new Date());
String collector = "Numbers: ";
for(int idx = 1; idx <= 50000; idx++) {
collector += idx;
}
System.out.println(collector.substring(0, 1024));
System.out.println(new Date());


При изпълнението на примера в конзолата се извеждат дата и час на 
стартиране на програмата, отрязък от първите 1024 символа от променливата,
 както и дата и час на завършване на програмата. Причината да 
отрежем първите 1024 символа е, че самото отпечатване на голям обем 
текстова информация на конзолата отнема доста време, а ние искаме да 
измерим само времето за изчисленията без времето за отпечатване на 
резултата. 
Обърнете внимание на времето за изпълнение –
почти 9 минути!

Обработка на символни низове в паметта

Проблемът с дълготрайната обработка на цикъла е свързан именно с 
работата на стринговете в паметта. Всяка една итерация създава нов обект 
в динамичната памет и насочва референцията към него. Процесът изисква 
определено физическо време.
На всяка стъпка се случват няколко неща:
1. Заделя се област от паметта за записване на резултата от долепването 
на поредната цифра. Тази памет се използва само временно, докато 
се изпълнява долепването, и се нарича буфер.
2. Премества се старият низ в ново заделения буфер. Ако низът е дълъг 
(примерно 1 MB или 10 MB), това може да е доста бавна операция!
3. Долепя се поредната цифра към буфера.
4. Буферът се преобразува в символен низ.
5. Старият низ, както и временният буфер, остават неизползвани и по 
някое време биват унищожени от системата за почистване на паметта 
(garbage collector). Това също може да е бавна операция.
Много по-елегантен и удачен начин за конкатениране на низове в цикъл е 
използването на класа StringBuilder.

Построяване и промяна на низове със StringBuilder

java.lang.StringBuilder е клас, който служи за построяване и промяна на 
символни низове. Той преодолява проблемите с бързодействието, които 
възникват при конкатениране на низове от тип String
411

Класът е изграден 
под формата на масив от символи и това, което трябва да знаем за него, е 
че информацията в него не е неизменима – промените, които се налагат в 
променливите от тип StringBuilder, се извършват в една и съща област от 
паметта (буфер), което спестява време и ресурси. За промяната на 
съдържанието не се създава нов обект, а просто се променя текущият.

public class NumbersConcatenatorEllegant {
	public static void main(String[] args) {
		System.out.println(new Date());
		StringBuilder sb = new StringBuilder();
		sb.append("Numbers: ");
		for(int idx = 1; idx <= 50000; idx++) {
		sb.append(idx);
		}
		System.out.println(sb.substring(0, 1024));
		System.out.println(new Date());
	}
}

Необходимото време за слепване на 50000 символа със StringBuilder е по-малко от секунда!

Обръщане на низ на обратно – пример

public class WordReverser {
	public static void main(String[] args) {
		String text = "EM edit";
		String reversed = reverseText(text);
		System.out.println(reversed); // tide ME
		}
		public static String reverseText(String text) {
		StringBuilder sb = new StringBuilder();
		for (int i = text.length() - 1; i >= 0; i--)
		sb.append(text.charAt(i));
		return sb.toString();
	}
}

Как работи класът StringBuilder?
За разлика от познатите вече символни 
низове, обектите на класа StringBuilder не са неизменими, т.е. редакциите 
не налагат създаването на нов обект в паметта.
StringBuilder поддържа буфер с определен капацитет (по подразбиране 16 
символа).

Буферът е реализиран под формата на масив от символи, който 
е предоставен на програмиста с удобен интерфейс – методи за лесно и 
бързо добавяне, търсене, редактиране на елементите на стринга. Във всеки 
един момент част от символите в буфера се използват, а останалите стоят 
в резерва.

Създаваме обект от класа StringBuilder с буфер от 15 символа. Към 
него ще добавим символния низ: "Hello,Java!".

StringBuilder sb = new StringBuilder(15);
sb.append("Hello,Java!");

елементи са запълнената част от буфера с въведеното от нас 
съдържание. Обикновено при добавяне на нов символ към променливата не 
се създава нов обект в паметта, а се използват заетото пространство за 
редакции и неизползваното за добавяне на нови данни.
Ако целият 
капацитет на буфера е запълнен, тогава вече се заделя нова област в 
динамичната памет с удвоен размер (текущия капацитет + 1, умножен по
2). След това можем отново да добавяме спокойно символи и символни 
низове, без да се притесняваме за непрекъснатото заделяне на памет.


			StringBuilder – по-важни методи
- StringBuilder(int capacity) – конструктор с параметър начален 
капацитет. Чрез него може предварително да зададем размера на 
буфера, ако имаме приблизителна информация за броя итерации и 
слепвания. Така спестяваме излишни заделяния на динамична памет.
- capacity() – връща размера на целия буфер (общия брой заети и 
свободни символи)
- length() – връща дължината на записания низ в променливата
- charAt(int index) – връща символа на указаната позиция
- append(…) – слепва низ, число или друга стойност след последния 
записан символ в буфера
- delete(int start, int end) – премахва низ по зададена начална и 
крайна позиция
- insert(int offset, String str) – вмъква даден стринг на дадена 
позиция
- replace(int start, int end, String str) – замества записания низ 
между началната и крайната позиция със стойността на променливата 
str
- toString() – връща записаната информация в обекта на StringBuilder
като резултат от тип String, който можем да запишем в променлива 
на String. 

Извличане на главните букви от текст – пример

public static String extractCapitals(String s) {
	StringBuilder result = new StringBuilder();
	for (int i = 0; i < s.length(); i++) {
		 char ch = s.charAt(i);
		 if (Character.isUpperCase(ch)) {
		result.append(ch);
		}
	}
	return result.toString();
}
Можете да разгледате документацията за класа Character, защото той 
предлага и други полезни методи за обработка на символи.

Форматиране на низове

Java предлага на програмиста механизми за форматиране на символните 
низове. Практически всеки създаден обект на клас, както и примитивните 
променливи, могат да бъдат представени като текстово съдържание. 
Налице са форматиращи класове и методи, които служат за правилното 
форматиране на текст, числа, дати. Спомнете си метода printf(…) от 
System.out.printf(…) – с негова помощ извеждаме символни низове с 
предварително форматирано съдържание, можем да задаваме шаблони, в 
които да попълваме празните места с променливи или литерали; да 
форматираме дати, числа и т.н

С някои от средствата за форматиране на текст вече се запознахме в 
главата "Вход и изход от конзолата". Ще преговорим по-важните от тях и 
ще допълним знанията си за форматирането и преобразуването на низове.


 -----------------------------   -----------------------------  --------------------Класът java.util.Formatter -----------------------------   -----------------------------  ----------------

дава възможност за извеждане на форматиращи 
символни низове. Сред възможностите на класа са подравняването на 
текста и различни методи за форматиране на текст, символи, дати и 
специфичен изход в зависимост от местоположението.
Създаването на 
класа е вдъхновено от функцията printf(…) в езика C, като имплементацията 
е реализирана със сходен синтаксис, но с по-стриктни изисквания, 
съобразени с езика Java.

Всеки метод, който връща форматиран изход, изисква форматиращ стринг 
и списък от аргументи. Форматиращият низ е String обект, който съдържа 
фиксиран текст и един или повече вложени форматиращи спецификатори 
(format specifiers). Основните спецификатори за символни и числови 
типове имат следния синтаксис

%[индекс_на_аргумента$][флагове][ширина][.точност]формат

- индекс_на_аргумента – незадължителен спецификатор; десетично 
число, указващо позицията на аргумента. Първият аргумент има 
индекс "1$", вторият – "2$", и т.н.
- флагове – незадължителен спецификатор; списък от символи, 
модифициращи начина на извеждане на низа. Зависи пряко от 
формата.
- ширина – незадължителен спецификатор; неотрицателно десетично 
число, посочващо минималния брой от символи, които да бъдат 
изведени на изхода. Удобен за таблично форматиране.
- точност – незадължителен спецификатор; неотрицателно десетично 
число, ограничаващ броя символи. Зависи от типа формат, широко 
използван при десетични числа.
- формат (conversion) – символ, указващ как да бъде форматиран 
аргументът. Зависи от типа на подадения аргумент.

Служебният метод toString()

Един от основните ни помощници за представянето на обектите като 
символни низове е методът toString(). Той е заложен в дефиницията на 
класа Object – базовият клас, който наследяват пряко или не всички 
референтни типове в езика. По този начин дефиницията на методи се 
появява във всеки един клас, като ние имаме възможност да изведем под 
някаква форма съдържанието на един обект като текст.

Date currentDate = new Date();
System.out.println(currentDate); 
// Thu Aug 28 11:34:27 EEST 2008

Когато подаваме currentDate като параметърна метода println(…), нямаме 
точна декларация, която обработва дати. Методът има конкретна 
реализация за всички примитивни типове и символни низове. За всички 
останали обекти println(…) извиква метода toString(), който извежда 
съдържанието на обекта. Т.е. горният код е еквивалентен на този:

Date currentDate = new Date();
System.out.println(currentDate.toString());

Имплементацията на метода по подразбиране в класа Object връща 
уникална стойност на обекта, като извежда пълния път до класа и неговия 
хеш код. Всички класове, които не предефинират поведението на 
toString(), използват именно тази имплементация. Повечето класове в Java 
API имат предефинирана стойност на метода, представяща четимо и 
разбираемо съдържание на обектите. Препоръчително е предефинирането 
на метода в класовете, създавани от програмиста.

Използване на String.format()

 е статичен метод, чрез който можем да създаваме форматирани стрингове,
 на които да подаваме параметри. Той е удобен при 
създаването на шаблони – често срещани текстове с променливи 
параметри. С негова помощ можем да използваме низове с декларирани 
параметри и всеки път да променяме единствено параметрите. Можем да 
направим асоциация с метода System.out.printf(…), който също форматира 
шаблонен низ и подава стойности на местата на параметрите:

System.out.printf("This is a template from %s.", "Mario");

Както методът String.format(), така и System.out.printf(…) ползват за 
извеждането на параметризираните низове класа java.util.Formatter.

Преобразуване на типове
Често работата с приложения с графичен потребителски интерфейс предполага потребителският 
вход да бъде предаван през променливи от тип String, защото 
практически така може да се работи както с числа и символи, така и с текст 
и дати, форматирани по предпочитан от нас начин. 

При преобразуването на типове не бива да се осланяме 
само на доверието към потребителя. Винаги проверявайте 
входните потребителски данни при преобразуване! В противен случай ще настъпи изключение.

Преобразуване към числови типове

За преобразуване на символен низ към число можем да използваме 
обвиващите класове (wrapper classes)

Всички примитивни типове имат прилежащите им класове, които служат за 
представянето на примитивна стойност като обект и предоставят често 
използвани методи, които можем да ползваме наготово. Например типът 
char предлага клас Character, типът float – клас Float, типът int - клас 
Integer, и т.н.

Обвиващите класове, като изключим Character, предлагат методи за 
преобразуването на текстова променлива към променлива от примитивния 
тип, с който е обвързан с обвиващия клас. Методите имат формата 
parseXXX(String), като на мястото на XXX е името на типа (например 
parseInt(…), parseBoolean(…) и др.).

String text = "53";
int intValue = Integer.parseInt(text); // 53

Можем да преобразуваме и променливи от булев тип:

String text = "True";
Boolean boolValue = Boolean.parseBoolean(text); // true

Връщаната стойност е true, когато подаваният параметър е инициализиран 
(не е обект със стойност null) и съдържанието й е "true", без значение от 
малките и главни букви в него, т.е. всякакви текстове като "true", "True"
или "tRUe" ще зададат на променливата boolValue стойност true. Всички 
останали случаи връщат стойност false.

В случай, че подадената на parseXXX метод стойност е невалидна (например 
подаваме "Пешо" при парсване на число), се получава изключение
NumberFormatException.

Обработване на дати – SimpleDateFormat

Например, ако 
форматът е "27.10.2008", можем да използваме метода split(…), за да 
разделим съдържанието по точка; след това да обходим масива от връщани 
стойности, да ги преобразуваме като цели числа с parseInt(…) на класа 
Integer и да създадем нов календар, от който да вземем датата.

String text = "27.10.2008";
String[] dateElements = text.split("[.]");
String dayString = dateElements[0];
String monthString = dateElements[1];
String yearString = dateElements[2];
int day = Integer.parseInt(dayString);
int month = Integer.parseInt(monthString);
int year = Integer.parseInt(yearString);
Calendar cal = new GregorianCalendar(year, month - 1, day);
Date date = cal.getTime(); // Mon Oct 27 00:00:00 EET 2008
 -----------------------------   -----------------------------   -----------------------------  -java.text.SimpleDateFormat -----------------------------   -----------------------------  ------------
Ако обърнете 
внимание, в предпоследния ред месецът е подаден като month – 1. 
Причината за това е, че в Java месеците започват от 0 

27.10 отбелязва месец октомври, докато в Java обект това би означавало 
двадесет и седми ноември.

Класът java.text.
SimpleDateFormat съдържа функционалност, чрез която достигаме до
 поелегантно преобразуване на типовете. Той ни дава възможност за 
преобразуване на текстово съдържание към дата, както и обратното.

Не забравяйте да вмъкнете java.text.SimpleDateFormat или 
пакета java.text.* в началото на програмата, за да може 
да използвате възможностите на класа. Класът Date също 
се намира в java.util пакета и не се импортира автоматично!

java.text.SimpleDateFormat – шаблони
SimpleDateFormat ни предлага по-удобен интерфейс за превръщане на 
текстови променливи към обекти на класа java.util.Date, и обратно.

Той е базиран на работата на шаблони, които дефинират по 
какъв начин е въведена датата: кои елементи от нея са зададени (ден, 
месец, година, час, милисекунди и т.н.), какви са разделителите (точки, 
наклонени черти, интервали), използва ли се 24-часово визуализиране или 
12-часово и други подробности.

Форматиращ 
символ
Описание
G Ера
Y Година
M Месец
D Ден от месеца
H Час (1-12, сутрин/следобед)
H Час (0-23)
K Час (1-24)
K Час (0-11, сутрин/следобед)
M Минути
S Секунди
S Милисекунди (0-999)
E Ден от седмицата
D Ден от годината (1-365)
F Ден от седмицата в месеца (1-5)
w Седмица в годината (1-53)
W Седмица в месеца (1-5)
A Am/Pm – сутрин/следобед
Z Времева зона


Ще разгледаме някои примери за различни комбинации с шаблоните за 
форматиране на дати. Отправната ни дата, преди форматиране, изглежда 
по следния начин:

Mon Oct 13 14:02:03 EEST 2008

Обърнете внимание, че можем да вмъкваме произволен текст във 
форматиращия низ с цел по-добра четимост.
Шаблон Резултат
yyyy.MM.dd G 'at' HH:mm:ss z 2008.10.13 н.е. at 14:02:03 EEST
EEE, MMM d, ''yy Пн, X 13, '08
H:mm a 2:02 PM
hh 'o''clock' a, zzzz 02 o'clock PM, Eastern European 
Summer Time
K:mm a, z 2:02 PM, EEST
yyyyy.MMMMM.dd GGG hh:mm aaa 02008.Октомври.13 н.е. 02:02 PM
EEE, d MMM yyyy HH:mm:ss Z Пн, 13 X 2008 14:02:03 +0300
yyMMddHHmmssZ 081013140203+0300

Преобразуване на низове към дати – пример

Нека видим предходния пример за преобразуване на символен низ към 
дата, но този път да използваме класа SimpleDateFormat за форматиране.

SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
Date date = sdf.parse("27.10.2008");
System.out.println(date); // Mon Oct 27 00:00:00 EET 2008

Както виждате, използването на помощния клас java.text. 
SimpleDateFormat ни спестява доста излишно писане на код и ръчно 
преобразуване на типовете. Има и още една особеност: в предходния 
пример бе необходимо да намалим с единица стойността на променливата 
за месеца, тъй като в Java месеците са номерирани от 0 до 11. Методът 
parse(…) автоматично преобразува стойностите, преди да ги присвои на 
променлива от тип Date, и в текущия фрагмент месецът с номер 10 е 
октомври, а не ноември.

Важно е да се отбележи, че методът parse(…) предизвиква java.text. 
ParseException. Задължително е да прихванем това изключение по някакъв 
начин (било то в try/catch блок или чрез throws декларация на метода). 
Изключение реално настъпва, ако потребителският вход не отговаря на 
шаблона и въведеният символен низ не може да бъде преобразуван към 
дата – например промяна на разделителя от точка на наклонена черта, 
добавяне на 4-ти параметър, който не ни е познат; дефиниране на грешен 
шаблон и т.н.


SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
String userInput = "27/12/2008";
try {
	Date date = sdf.parse(userInput);
	System.out.println(date);
}
catch(ParseException pe) {
	System.out.println("Error in parsing " + userInput);
	// Error in parsing 27/12/2008
}

Ако входът от потребителя е коректен и съвпада с шаблона, то нашият код 
ще бъде изпълнен успешно. В посочения пример данните са разделени от 
наклонена черта, докато шаблонът ни очаква за разделител точка. В такъв 
случай ще бъде хвърлено изключение, което ние извеждаме на конзолата 
със съобщение за грешка. Във всички случаи е необходимо прихващане на 
изключенията при конверсията на потребителски вход към дата.

Въвеждането на грешна стойност за ден или месец може 
да не генерира изключение! В Java е допустимо създа
ването на променлива 'ден' със стойност по-голяма от 31 
или 'месец', чиято стойност надхвърля 12. Например при 
задаването на месец с по-голяма стойност от 12, ще 
преминем в следващата година.

Горната забележка е сходна с 'прехвърляне на брояча' на хронометър –
когато секундите надхвърлят 59, новата стойност става 0, а минутите се 
увеличават с единица (аналогично за часове, дни, месеци и т.н). В 
използвания от нас календар месеците са от 1 до 12 – респективно от 
януари до декември, но в Java е възможно да зададем месец 13, без да 
получим изключение. Задаването на 27.13.2008 г. например е еквивалентно на 27.01.2009 г

SimpleDateFormat sdf = new SimpleDateFormat("dd.MM.yyyy");
Date date = sdf.parse("27.13.2008");
System.out.println(date); // Tue Jan 27 00:00:00 EET 2009

Въпреки това е препоръчително да не се използват такива стойности, 
когато е възможно, за да не настъпва объркване.

Преобразуване на дати към символни низове – пример
 SimpleDateFormat е format(…).
обектите на класа Date могат да бъдат извеждани на конзолата.

 Често се налага да извеждаме датата, форматирана по желан от нас начин. 
Стандартното форматиране визуализира деня от седмицата, текущия 
месец, деня от месеца, час, минути, секунди, часова зона и година. В частни 
случаи се нуждаем само от определена част от датата – например само 
часовете и минутите. Тогава създаваме шаблон, който да извежда часовете 
и минутите от датата, като ни спестява извеждането на другата 
информация

Нека създадем обект от тип Date, който съдържа текущата дата, и да 
изведем часа и минутите, в които е създаден обекта:

String pattern = "HH часа и mm мин.";
SimpleDateFormat sdf = new SimpleDateFormat(pattern);
Date dateNow = new Date();
System.out.println(dateNow); // Sun Oct 12 15:57:39 EEST 2008
String formattedDate = sdf.format(dateNow);
System.out.println(formattedDate); // 15 часа и 57 мин.

Методът format(…) приема като аргумент обект от тип Date и връща 
стойността от тип String, която можем да използваме, за да я покажем на 
потребителя или да я обработим по някакъв начин. За разлика от parse(…), 
format(…) не хвърля винаги изключение, т.е. не е необходимо всеки път да 
прихващаме евентуален ParseException. При некоректен шаблон обаче 
може да възникне IllegalArgumentException.

	В стандартния случай 
шаблоните и създадените дати са създадени от програмиста и няма 
опасност от възникване на изключение.
Няма проблем за добавяне на допълнителни символи за по-прегледен вид 
на датата. В примера по-горе сме добавили думи "часа" и "мин." с цел поголяма
 яснота за потребителите. Шаблоните "HH" и "mm" пък са заместител 
на часа и минутите от обекта dateNow. 
За финал, ето и един пример за извеждане на деня от седмицата и текущата 
дата (елементите ден, месец, година):
String pattern = "EEEE, dd.MM.yyyy г.";
SimpleDateFormat sdf = new SimpleDateFormat(pattern);
Date dateNow = new Date();
System.out.println(dateNow); // Sun Oct 12 16:09:04 EEST 2008
String formattedDate = sdf.format(dateNow);
System.out.println(formattedDate); // Неделя, 12.10.2008 г.


 -----------------------------   -----------------------------  ----------- Глава 14. Дефиниране на класове  -----------------------------   -----------------------------  -----------

Собствени класове

Всеки модел представя някакъв аспект от реалността или някаква
интересна идея. Моделът е опростяване. Той интерпретира реалността, 
като се фокусира върху аспектите от нея, свързани с решаването на 
проблема и игнорира излишните детайли.


Да си припомним: какво са класовете и обектите?
Клас (class) наричаме описание на даден обект от реалността. Класът 
представлява шаблон, който описва видовете състояния и поведението на 
обектите (екземплярите), които биват създавани от този клас (шаблон).
Обект (object) наричаме екземпляр създаден по дефиницията (описанието)
 на даден клас. Когато един обект е създаден по описанието, което един 
клас дефинира, казваме, че обектът е от тип "името на този клас".

с фигурни скоби – "{" и "}"

- Конструктор (constructor) – това е псевдометод, който се използва 
за създаване на нови обекти. 



съществуват и такива 
полета, наречени статични, които са общи за всички обекти.


- Полета (fields) (член-променливи) – променливи декларирани в класа.
Пазят данни, които отразяват състоянието на обекта и са нужни за работата 
на методите на класа.Стойността, която се пази в полетата, отразява 
конкретното състояние на дадения обект, но съществуват и такива 
полета, наречени статични, които са общи за всички обекти.
// Field/Property-storage definition
private String name;

- Свойства (properties) – наричаме характерните особености на 
даден клас. Обикновено стойността на тези характеристики се пази в 
полета. Подобно на полетата, свойствата могат да бъдат притежавани 
само от конкретен обект, или да са споделени между всички обекти от 
тип даден клас.
// Field/Property-storage definition
private String name;


Природа на обектите
Нека припомним също, че когато създадем един обект, той се състои от две 
части – реална част от обекта, която съдържа данните за конкретния обект 
и се намира в частта от оперативната памет, наречена хийп (heap) и 
референция към този обект (която се намира в друга част от оперативната 
памет, където се държат локалните променливи и параметрите на методите, 
наречена стек (stack)).

    -------------     -------------
   |   Stack     |   |    Heap     |
   |             |   | obekt       |
   |локални пром |   |             |
   | парам на мет|   |             |
   |реф към обект|   |             |
   |Dog@187aeca  | > | Dog Object  |
   |             |   |             |
   |  dog null   | > |  nothing    |
   |             |   |             |
   |             | > |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
   |             |   |             |
    -------------     -------------

Когато декларираме една променлива от тип, някакъв клас, но не искаме 
тя да е инициализирана с връзка към конкретен обект, тогава трябва да й 
присвоим стойност null. Ключовата дума null в езика Java означава, че 
една променлива не сочи към нито един обект (липса на стойност):


Организация на .java файл.
Задължително най горе е packet и не е задължително да се слага но е добра практика
и за по добра организация и класове с еднакви имена да се разграничават.
  
После идват import-ите - не са задължителни, но ако ги има са веднага след пакета.

После идва декларирането на класове. Могат да са няколко в един файл, но за по добра прегледност,
всеки клас е в отделен файл.

Кодиране на файловете. Четене на кирилица и 
Unicode

Когато създаваме .java файл, в който да дефинираме класа си, е добре да 
помислим за кодирането при съхраняването му на файловата система.
Вътрешно, Java представя кода в Unicode кодиране, затова, няма проблеми, 
ако във файла използваме символи, които са от азбуки, различни от 
латинската, например на кирилица:

Този код ще се компилира и изпълни без проблем, но за да запазим 
символите четими в редактора, трябва да изберем подходящото кодиране 
на файла.
По подразбиране, Eclipse използва настройките на операционната система 
за кодиране на .java файловете. Но ако при тази ситуация, във файла 
въведем по-особен символ, например китайски йероглиф, той няма да има 
представяне в кодовата таблица на кирилицата и най-вероятно няма да 
бъде визуализиран коректно в Eclipse. За да нямаме подобни проблеми, е 
добре да настроим Eclipse, да съхранява .java файлове с кодиране UTF-8. 
Това става по следния начин: избираме от менюто Window -> Preferences -
> General -> Workspace -> Text File Encoding -> Other -> UTF-8:


-препоръчително да пишем всички идентификатори и 
коментари на английски език, за да може кодът ни да е разбираем за повече 
хора по света.


Модификатори и нива на достъп (видимост)

В Java има три модификатора за достъп. Те са public, protected и private.
4то ниво  default или package.
в по стари версии на java е  friendly

public - може да бъде достъпен от всеки друг 
клас, независимо дали е в текущия пакет или извън него. Той определя 
най-малко ограничителното ниво на видимост от всички нива в Java.

default - То е по-ограничително от public-видимостта, тъй като позволява,
 да достъпваме съответният елемент, само от класове, които се намират в същия 
пакет, в който се намира класът, на който принадлежи елементът.

protected -не може да бъде достъпван 
от никой друг клас, дори този клас да се намира в същия пакет.

Нивата на достъп, които един клас може да има са само public и default.

Не трябва да забравяме, че ако искаме да използваме клас с ниво на достъп 
public, от друг пакет, различен от текущия, в който създаваме класа си, 
трябва да използваме конструкцията за включване на пакети import, за 
пакета, в който се намира желаният за употреба клас.

Ако в един .java файл дефинираме повече от един клас, то в този файл е 
позволено да имаме само един единствен клас, който е с модификатор 
public. Освен това, когато декларираме един клас като public, файлът, в 
който се намира класът, трябва да има същото име, като на този клас.

Ниво на достъп default
В случай, че класът няма модификатор за достъп (т.е. има ниво на достъп 
default), този клас ще e видим само за класовете, които се намират в 
пакета, в който е деклариран класа. Затова понякога това ниво на достъп 
се нарича package.

Например, ако имаме клас A и клас В, но в различни пакети, и съответно 
клас A е с ниво на достъп default, то в клас В няма да можем да създаден 
нито един обект от тип A, или дори да дефинираме променлива от тип A.

Всъщност за класа В, класът А изобщо не съществува и ако въпреки всичко, 
се опитаме да използваме класът А в класа В, например:The type package1.A is not visible


Правила при създаването на име на клас

- Името на класа винаги започва с главна буква.
- Ако името на класа е съставено от няколко думи, първата буква от 
всяка нова дума, долепена до предходната, трябва да бъде главна.
- За имена на класове обикновено се използват съществителни имена.
- Името на класа е добре да бъде на английски език.

Dog
Account
Car
BufferedReader


Полета

Тези характеристики на реалния обект, ги интерпретираме в декларацията 
на класа, като декларираме набор от специален тип променливи, наречени 
полета, в които пазим данните за отделните характеристики. Когато 
създадем обекти по описанието на нашия клас, стойностите на полетата, 
ще съдържат конкретните характеристики, с които даден екземпляр (обект) 
се отличава от всички останали обекти от дадения клас.


В Java съществува и трети вид променливи, наречени полета (fields) или 
член-променливи на класа (instance variables).
Те се декларират в тялото на класа, но извън тялото на блок, метод или 
конструктор

Полетата се декларират в тялото на класа, но извън тялото 
на метод, конструктор или блок.

 Код, в който се декларират различни полета:
  class MyClass {
	int age;
	long distance;
	String[] names;
	Dog myDog;
}


модификатори
 static- 
 final-
 transient, volatile - извън обсега на тази книга и няма да бъдат разглеждани.
 
 подразбиращите се стойности за всеки един тип за полетата. 0 , false, null Или друго свързано с 0
 За разлика от полетата, локалните променливи, не биват 
инициализирани с подразбираща се стойност след 
тяхното деклариране.

public static void main(String[] args) {
int notInitializedLocalVariable;
System.out.println(notInitializedLocalVariable);
}

The local variable notInitializedLocalVariable may not have been 
initialized.

добра практика е обаче да инициализираме  полета изрично 
да задаваме стойности по подразбиране.

class MyClass {
	int age = 0;
	long distance = 0;
	String[] names = null;
	Dog myDog = null;
	// ... Other code ...
}

Модификатор final
поле с такъв идентификатор след като се инициализира
не може да му се промени стойността.

Достъп до нестатичните полетата на класа от 
нестатичен метод

this.<field_name>

int getAge() {
return this.age;
}

Нека подчертаем, че този достъп е възможен, само от нестатичен код, т.е. 
метод или блок, който няма модификатор static.

Извикване нестатичните методи на класа от 
нестатичен метод

По подобие на полетата, които нямат static в декларацията си, методите, 
които също не са статични, могат да бъдат извиквани в тялото на класа, 
чрез ключовата дума this.

void printAge() {
	int myAge = this.getAge(); // Calling getAge() by this
	System.out.println("My age is: " + myAge);
}
  На първия ред от примера, указваме, че искаме да получим възрастта 
(стойността на полето age) на текущия обект, извиквайки метода getAge(), 
на текущия обект. Това става, чрез ключовата дума this.

Достъпването на нестатичните елементи на класа (полета 
и методи), се осъществява чрез ключовата дума this и 
оператора за достъп – точка.


Ключовата дума this се използва, изрично да укаже, че правим достъп до 
нестатично поле на даден клас или извикваме негов нестатичен метод. 
Когато това не е необходимо може да бъде пропускана и директно да се 
достъпва елементът на класа.

Когато не е нужно изрично да се укаже, че правим достъп 
до елемент на класа, ключовата дума this, може да бъде 
пропусната.

Ако имаме 2 променливи с еднакви имена едната е 
локална(в метода), другата глобална в класа и извън метода.
Ако в метода извикаме променлива с такова име, взимаме локалната.

Ниво на достъп public
нещо декларирано като public, може да бъде достъпвано от други класове, независимо
дали другите класове са декларирани в същия пакет или извън него.

нещо декларирано като default - се достъпва от всякъде,
но само от неговия пакет.

Ниво на достъп private

private, не могат да бъдат достъпвани от никой друг клас, различен от 
класа, в който са декларирани.

  Какво е конструктор?
- се извиква чрез ключовата дума new.
Задачата на конструктора е да задели памет в хийпа, където ще съхраняват 
данните, които се пазят в полетата на конкретния обект (тези, които не са
static), инициализира всяко поле с подразбиращата се за типа му стойност 
и връща референция към новосъздадения обект.

Извикване на конструктор
Dog myDog = new Dog();

 final и static, не са позволени за употреба при
 декларирането на конструктори.
 
 Видимост на конструкторите
 public, protected, default и private
 
Добър стил е Инициализация на полета в конструктора 
 
 public class Dog {
	String name;
		public Dog() {
		this.name = "Sharo";
		}
	// ... The rest of the class body ...
}

Помним, че локалните променливи
 винаги се съхраняват в областта от 
оперативната памет, наречена стек, 
а обектите – в частта, наречена хийп.

Модификатор final на полета и стойности по подразбиране

Задаваме стойност при декларирането или в конструктора.

иначе дава грешка

class FinalModifierTest {
	final int age; // There is no initializing value
	public static void main(String[] args) {
	FinalModifierTest instance = new FinalModifierTest();
	}
}

Конструктор с променлив брой аргументи

- Когато декларираме конструктор с променлив брой аргументи, трябва 
да декларираме типа на аргументите, които ще бъдат подавани на 
метода, следван от три точки, след което името на масива, в който ще 
се съхраняват тези аргументи. Например за целочислени аргументи –
int... numbers.

- Параметърът за променлив брой аргументи трябва да е последен в 
списъка от параметри на конструктора.

public Lecture(String subject, String... studentsNames) {
// ... Initialization of the instance variables ...
}
Lecture lecture = 
new Lecture("Biology", "Pencho", "Mincho", "Stancho");

Варианти на конструкторите (overloading)

public Dog() { // NO parameters
	this.name = "Sharo ";
	this.age = 1;
	this.length = 0.3;
	this.collar = new Collar();
}
public Dog(String name) { // One parameter
	this.name = name;
	this.age = 1;
	this.length = 0.3;
	this.collar = new Collar();
}

public Dog(String name, int age, // Three parameters
double length) {
	this.name = name;
	this.age = age;
	this.length = length;
	this.collar = new Collar();
}

-------------ПО ДОБРИЯ ВАРИАНТ Е ТАКА  -----------------------------  ---


В Java, съществува механизъм, чрез който един конструктор
 да извиква конструктор деклариран в същия клас:
this([<parameters_list>])


public Dog() {
	this("Sharo"); // Constructor call
}
public Dog(String name) {
	this(name, 1); // Constructor call
}
public Dog(String name, int age) {
	this(name, age, 0.3); // Constructor call
}
public Dog(String name, int age, double length) {
	this(name, age, length, new Collar()); // Constructor call
}
public Dog(String name, int age, double length, Collar collar) {
	this.name = name;
	this.age = age;
	this.length = length;
	this.collar = collar;
}

Преди свободно да декларираме конструктори, които извикват други 
конструктори в класа, трябва да знаем, че ако в един конструктор викаме 
друг конструктор, то това трябва да стане на първия ред. Например, ако 
вземем конструктора с три параметъра по-горе и решим да направим 
следното:

public Dog(String name, int age, double length) {
	Collar collar = new Collar();
	this(name, age, length, collar); // NOT on the first line
}
Компилатора ще изведе следното съобщение за грешка:
Constructor call must be the first statement in a constructor.
 -----------------------------  ---Правило  -----------------------------  -------
Ако в един клас, един конструктор вика друг конструктор 
от същия клас, то извикваният конструктор трябва да е на
първия ред в извикващия конструктор. В противен 
случай, класът няма да се компилира.
 -----------------------------  ---Правило  -----------------------------  -------

Конструктор по подразбиране (implicit constructor)

Когато не дефинираме нито един конструктор в даден 
клас, компилаторът ще създаде един,
 наречен конструктор по подразбиране.
 
 public class Collar {
	private int size;
	public int getSize() {
	return this.size;
	}
}

Collar collar = new Collar();

Трябва да знаем, че конструкторът по подразбиране винаги носи името на 
класа <class_name>, винаги списъкът му с параметри е празен и винаги 
нивото му на достъп съвпада с нивото на достъп на класа 
<class_access_level>.

Конструкторът по подразбиране е винаги без параметри.

нека се уверим
Collar collar = new Collar(5);
дава грешка //The constructor Collar(int) is undefined.

Работа на конструктора по подразбиране
Както се досещаме, единственото, което конструктора по подразбиране ще 
направи при създаването на обекти от нашия клас, е да задели памет за 
полетата на класа ни (които не са статични) и да ги инициализира с
подразбиращите се стойности.

Разлика между конструктор по подразбиране и конструктор 
без параметри

public Collar(int size) {
	this(); - извикваме конструктор без параметри
	this.size = size;
}

Въпреки че конструкторът по подразбиране и този, без 
параметри, си приличат по сигнатура, те са напълно 
различни.

- конструкторът по подразбиране 
винаги ще има нивото на достъп, което има класа.
Нивото на достъп на 
конструктора без параметри зависи отново от нас
 – ние го определяме.
 
 Деклариране на локални променливи с модификатор final
 променлива в метод е локална 
 променлива в конструктор също
 
 public static void main(String[] args) {
	final Dog dog = new Dog("Walcho");
	dog = new Dog("Sharo"); 
}
The final local variable dog cannot be assigned. It must be blank and 
not using a compound assignment

Стойността (т. е. референцията), която се пази в една final
променлива (или поле) от референтен тип, не може да 
бъде модифицирана (т.е. да й бъде присвоена 
референция към друг обект), но е възможно, обектът, към 
който "сочи" въпросната референция да бъде 
модифициран.
public static void main(String[] args) {
	final Dog dog = new Dog("Walcho");
	System.out.printf("My dog's name is: %s\n", dog.getName());
	dog.setName("Sharo");
	System.out.printf("My dog's name is: %s\n", dog.getName());
}
My dog's name is: Walcho
My dog's name is: Sharo

Деклариране на методи и конструктори с параметри, които 
имат модификатор final

public void doSth(final int arg) {
// Do something...
}

Както знаем, параметрите от списъка с параметри на метод или конструктор, технически са просто локални променливи. Следователно, всичко, 
което казахме до тук за локалните променливи декларирани с модификатор 
final, е в сила и за параметри декларирани с този модификатор, 
независимо дали са от примитивен или референтен тип.
Може би изниква въпроса, защо би ни било нужно да декларираме 
параметър на метод или още повече на конструктор с такъв модификатор? 
Отговорът е, че модификаторът final, ни осигурява защита. Той ни предпазва някой да не "подмени" обектът, към който сочи нашия параметър с 
чужд обект. С други думи, ако един параметър в декларацията на един 
метод не е деклариран с модификатор final, това позволява на произволно 
място в тялото на метода, на въпросния параметър да се присвои 
референция към друг обект. По този начин нашият метод няма да работи 
както се очаква и така ще се наруши сигурността на цялата програма.
Може би всичко това звучи странно, но всичко ще се изясни, след като се 
запознаем с главата "Принципи на обектно-ориентираното програмиране".


Свойства (properties)-се нарича 
специален вид елемент на класа, който е нещо средно между поле и метод. 
Характерното е, че достъпът и модификацията на свойствата на класа се 
осъществява единствено чрез специален вид методи.

Свойствата в Java

Това става чрез деклариране на два метода 
– един за достъп 
(четене) и един за модификация (записване)
 на стойността на съответното 
свойство.

public class Point {
	private double[] coordinates;
	public Point(int x, int y) {
		coordinates = new double[2];
		// Initializing the x coordinate
		coordinates[0] = x;
		// Initializing the y coordinate
		coordinates[1] = y;
	}
		public double getX() {
		return coordinates[0];
	}
		public void setX(double x) {
		coordinates[0] = x;
	}
		public double getY() {
		return coordinates[1];
	}
		public void setY(double y) {
		coordinates[1] = y;
	}
}

Конвенция за свойствата в Java
За да декларираме едно свойство в Java, трябва да декларираме методи за 
достъп (четене и промяна) на съответното свойство, които имат строго 
определени правила за именуване. Също така трябва да решим по какъв 
начин ще съхраняваме информацията за това свойство в класа.
За всяко едно от тези условия има конвенция (която е част от JavaBeans 
спецификацията). Сега ще дадем подробна информация за всяко едно от 
тях.


Физическо представяне на свойствата в класа

Както видяхме по-горе, свойствата могат да имат различно представяне в 
един клас. В нашия пример, свойствата на класа Point, първоначално бяха 
представени като две полета, след това като чрез едно поле-масив.

Или може да решим да пазим информацията във файл или база данни.

Принципно няма значение по какъв начин физически ще 
бъде пазена информацията за свойствата в един Java 
клас, но обикновено това става чрез поле на класа с 
максимално рестриктирано ниво на достъп.

Представяне на свойство без декларация на поле

Метод за четене на стойността на свойство
public <property_type> get<property_name>()

името на 
свойството, започвайки с главна буква,
 спазвайки правилото camelCase.
 height - getHeight.
  
  public boolean isStopped() // stopped property
public boolean isMyStatus() // myStatus property

Метод за промяна на стойността на свойство
public void set<property_name>(<property_type> parameter_name)
width -  setWidth

public void setMyValue(int myValue) // myValue :: int, property
public void setColor(String colourName)

Видове свойства

Само за четене, т.е. тези свойства имат само get-метод.
Само за модифициране, т.е. тези свойства имат само set.

Статични членове на класа (static members)
Тъй като статични могат да бъдат само полетата и 
методите на класа, когато говорим за статични членове (елементи) на класа 
ще визираме точно тях.

За какво се използват статичните елементи?
Брояч на инстанциите от даден клас
Нека разгледаме и друг сценарий. Да кажем, че искаме да пазим в 
програмата ни текущия брой на обектите, които са били създадени от даден 
клас. Как ще съхраним тази променлива, която ще пази броя на 
създадените обекти?
Както знаем, няма да е възможно да я пазим като поле на класа, тъй като 
при всяко създаване на обект, ще се създава ново копие на това поле за 
всеки обект, и то ще бъде инициализирано със стойността по подразбиране. 
Всеки обект ще пази свое поле за индикация на броя на обектите и обектите 
няма да могат да споделят информацията по между си. В следващите 
подсекции ще разберем как да се справим и с този проблем.

Какво е статичен член?
  
  когато поле или метод е static -принадлежат на 
самия клас, а не на някой конкретен обект от дадения клас.

Следователно, когато маркираме поле или метод като статични, можем да 
ги използваме, без да създаваме нито един обект от дадения клас.
Единственото, от което се нуждаем е да имаме достъп (видимост) до класа.

Статичните елементи на класа могат да се използват, без 
да се създава обект от дадения клас.

От друга страна, ако имаме създадени обекти от дадения клас, тогава 
статичните полета ще бъдат общи за тях – има само едно копие на статично 
поле, което се споделя от всички обекти от дадения клас.

Статични полета

public class Dog {
	// Instance variables
	private String name;
	private int age;
}

има две полета съответно за име – name и възраст – age. Във всеки 
обект, всяко едно от тези полета има собствена стойност, която се 
съхранява на различно място в паметта за всеки обект.
Понякога обаче, искаме да имаме полета, които са общи за всички обекти 
от даден клас. За да постигнем това, трябва в декларацията на тези полета 
да използваме модификатора static.

Декларация на статични полета

Ето как би изглеждало едно поле dogCount, което пази информация за броя 
на създадените обекти от клас Dog:

public class Dog {
	// Static variable
	static int dogCount;
	// Instance variables
	private String name;
	private int age;
}

Статичните полета се създават, когато за първи път се опитаме да създадем 
обект от класа, на който принадлежат или когато заредим класа в паметта 
(как става това обаче, е извън обхвата на тази книга и няма да го 
разглеждаме). След създаването си, по подобие на обикновените полета в 
класа, те се инициализират с подразбиращата се стойност за типа си.

Инициализация по време на декларация

Трябва да знаем, че статичните полета са асоциирани с класа, вместо с 
който и да е обект от дадения клас. Това означава, че всички обекти, 
създадени по описанието на един клас споделят статичните полета на класа

Ако по време на декларация на статичното поле, сме задали стойност за 
инициализация, тя се присвоява на съответното статично поле. Тази 
инициализация се изпълнява само веднъж – при създаването на полето, 
веднага след като приключи присвояването на стойността по подразбиране. При последващо създаване на обекти от този клас, тази инициализация 
на статичното поле няма да се изпълни, тъй като статичното поле е 
асоциирано с класа и е независимо от обектите.


В горния пример например, ако добавим инициализация на статичното 
поле:
// Static variable - declaration and initialization
static int dogCount = 0;

Тази инициализация ще се извърши при създаването на първия обект от 
нашия клас или при първия опит да достъпим статичен елемент на класа 
(повече за това, в следващата секция). Когато извикаме за първи път 
конструктора на класа Dog или питаме да достъпим някое статично поле или 
статичен метод на класа, описанието на класа Dog ще се зареди в паметта. 
Тогава ще се задели памет за статичните му полета, те ще се инициализират 
със стойностите им по подразбиране. След това за тези статични полета, 
които имат инициализация по време на декларацията си (както е в нашия 
случай с полето dogCount), тази инициализация ще се извърши. Едва след 
тази инициализация ще се създаде първият обект от класа. В последствие 
обаче, когато създаваме други обекти от същия клас, този процес няма да 
се повтори, тъй като статичното поле вече съществува и един път 
създадено, то се споделя между всички обекти в класа.

Достъп до статични полета

За разлика от обикновените (нестатични) полета на класа, статичните, 
бидейки асоциирани с класа, а не с конкретен обект, могат да бъдат 
достъпвани, без да бъде създаван обект от дадения клас. Това става като 
към името на класа, чрез точкова нотация, достъпим името на съответното 
статично поле:

Например, ако искаме да отпечатаме стойността на статичното поле, което 
пази броя на създадените обекти от нашия клас Dog, това ще стане по 
следния начин:

public static void main(String[] args) {
	// Аccess to the static variable through class name
	System.out.println("Dog count is now " + Dog.dogCount);
}

Въпреки, че по принцип статичните полета се достъпват чрез името на 
класа, те могат да бъдат достъпвани и чрез променлива, която е референция към конкретен обект:

Ако модифицираме леко последния пример с метода main(), ще видим как 
можем да извлечем стойността на броя създадени обекти, използвайки 
някоя локална променлива – dog1, която съхранява референция към обект 
от тип Dog:

public static void main(String[] args) {
Dog dog1 = new Dog();
	// Accessing the static variable through local variable
	System.out.println("Dog count is now " + dog1.dogCount);
}

Разбира се, изходът е идентичен с този по-горе:
Dog count is now 0
Трябва да знаем обаче, че по-добра практика е да достъпваме статичните 
елементи на класа, чрез името на класа, вместо чрез някоя променлива, 
която съхранява референция към обект от този клас, тъй като това прави 
кода по-четим. Когато използваме променлива, която "сочи" към обект, не 
става ясно, че полето, което се достъпва чрез нея, е статично.

Модификация на стойностите на статичните полета

Като са споделени между всички обекти, това дава възможност
всеки обект да променя стойността на статичната променлива.

Ето защо, например, за да отчетем броя на създадените обекти от клас Dog, 
е удобно да използваме статично поле, което увеличаваме с единица, при 
всяко извикване на конструктора на класа, т.е. всеки път, когато създаваме 
обект от нашия клас:

public Dog(String name, int age) {
	this.name = name;
	this.age = age;
	dogCount += 1; // Modify the value in the constructor
}
Константи (constants)

в Java, могат да се създадат 
полета на класа, които декларирани и инициализирани веднъж, винаги 
притежават една и съща стойност. Това са константите.

Декларация на константи
Когато декларираме едно поле с модификатори static и final, това поле 
наричаме константа (constant):

статично поле автоматично му се задава стойност 0 затова
когато декларираме константа, 
трябва да винаги да й даваме стойност по време на декларацията:

Форматиране на константите

Съгласно конвенцията, константите в Java, винаги се изписват с главни 
букви. Ако константата е съставена от няколко думи, те се разделят със 
символа за долна черта

public static final double PI = 3.141592653589793;
public static final char PATH_SEPARATOR = '/';

Статични методи
По подобие на статичните полета, когато искаме един метод да е асоцииран 
само с класа, но не и с конкретен обект от класа, тогава го декларираме 
като статичен.

Разбира се по-препоръчително е, както при статичните полета, достъпът до 
статични методи да става чрез името на класа.

Достъп между статични и нестатични елементи на 
класа
В повечето случаи статичните методи се използват за достъпване на 
статични полета. Например, когато искаме да декларираме метод, който да 
връща броя на създадените обекти от класа Dog, той ще е статичен:
public static int getDogCount() {
	return dogCount;
}

Достъп до нестатичните елементи на класа от нестатичен 
метод
Нестатичните методи могат да достъпват нестатичните полета и други 
нестатични методи на класа.

Статични свойства на класа

Макар и рядко, понякога е удобно да се декларират и използват свойства 
не на обекта, а на класа. Те носят същите характеристики като свойствата, 
свързани с конкретен обект от даден клас, които разгледахме по-горе, но с 
тази разлика, че статичните свойства се отнасят за класа. Както можем да 
се досетим, всичко, което е нужно да направим, за да превърнем едно 
обикновено свойство в статично, е да добавим ключовата дума static в 
декларацията на методите за четене и модификация на съответното 
свойство.

Нека разгледаме един пример. Нека имаме клас, който описва някаква 
система. Ние можем да създаваме много обекти от нея, но моделът на 
системата има дадена версия и производител, които са общи за всички 
екземпляри, създадени от този клас:
public class System {
	private static double version = 0.1;
	private static String vendor = "Sun Microsystems";
	// The version property getter:
		public static double getVersion() {
	return version;
	}
	// The version property setter:
	public static void setVersion(double version) {
		System.version = version;
	}
	// The vendor property getter:
	public static String getVendor() {
		return vendor;
	}
	// The vendor property setter:
	public static void setVendor(String vendor) {
		System.vendor = vendor;
	}
	// ... More (non)static code here ...
}
Тук сме избрали да пазим стойността на статичните свойства в статични 
променливи (което е логично, тъй като те са обвързани само с класа). 
Свойствата, които разглеждаме са съответно версия (version) и производител (vendor). За всяко едно от тях сме създали статичен метод за достъп до 
съответното свойство и модификация. Така всички обекти от този клас, ще 
могат да извлекат текущата версия и производителя на системата, която 
описва класа. Съответно, ако някой ден бъде направено обновление на 
версията на системата например стойността стане 0.2, всеки от обектите, 
ще получи като резултат новата версия, чрез достъпване на свойството на 
класа.

Вътрешни, локални и анонимни класове
В Java можем да дефинираме класове вътре в даден друг клас или дори в 
даден метод. Понякога това може да е много удобно, когато ни трябва клас, 
който искаме да използваме временно или искаме да скрием от външния 
свят.

Вътрешни класове

В Java е възможно в един клас да се дефинира друг клас, т.е. класът да е 
член на клас. Такъв клас наричаме вътрешен клас (inner class, nested 
class). Нека разгледаме тази възможност с един пример:

public class OuterClass {
	private String name;
	private OuterClass(String name) {
		this.name = name;
	}
	private class InnerClass {
	private String name;
	private InnerClass(String name) {
		this.name = name;
	}
	private void printNames() {
		System.out.println("Inner name: " + this.name);
		System.out.println("Outer name: " + 
		OuterClass.this.name);
	}
	}
	public static void main(String[] args) {
		OuterClass outerClass = new OuterClass("outer");
		InnerClass innerClass = outerClass.new InnerClass("inner");
		innerClass.printNames();
	}
}
В примера външният клас OuterClass дефинира в себе си като private член 
класа InnerClass. Нестатичните методи на вътрешния клас имат достъп 
както до собствената си инстанция this, така и до инстанцията на външния 
клас (чрез синтаксиса OuterClass.this). При създаването на вътрешния 
клас на конструктора му се подава this референцията на външния клас, 
защото вътрешният клас не може да съществува без конкретна инстанция 
на външния. Забележете, че външния клас може да вика свободно private
методи и конструктори от вътрешния клас.

Вътрешните класове могат да бъдат декларирани като статични (чрез 
модификатора static). В този случай те могат да съществуват и без 
външния клас, в който са разположени, но нямат достъп до неговата this
инстанция.

Локални класове
В Java можем да дефинираме класове и в даден метод. Наричаме ги
локални класове (local classes). Локалните класове са подобни на 
вътрешните класове, но не могат да бъдат статични. Те имат достъп до 
член-променливите и методите на външния им клас. Локалните класове
могат да осъществяват достъп и до променливите, декларирани в метода, в 
който се съдържат, стига тези променливи да са обявени като final. Ето 
един пример:

public class LocalClassExample {
	public static void main(String[] args) {
	final int value = 5;
		class LocalClass {
		void printSomething() {
		System.out.println(value);
		}
		}
		LocalClass localClass = new LocalClass();
		localClass.printSomething();
	}
}

Локалните класове са достъпни само и единствено в метода, в който са 
декларирани и нямат модификатори за видимост и не могат да бъдат 
статични, както всяка една локална променлива.

Анонимни класове

В Java можем да декларираме локален клас без име. Такъв клас се нарича 
анонимен клас (annonymous class). Да разгледаме един пример:

public class AnnonymousClassExample {
	public static void main(String[] args) {
		new Object() {
		void printSomething() {
		System.out.println("I am annonymous class.");
		}
		}.printSomething();
	}
}

За момента приемете, че анонимните класове 
са локални класове без име, които ползват за основа даден съществуващ 
клас и му добавят допълнителни методи.

 -----------------------------   -----------------------------  -- НЕ СЪМ РЕШИЛ ЗАДАЧИТЕ  -----------------------------  ----


 -----------------------------   -----------------------------  ----------- Глава 15. Текстови файлове  -----------------------------   -----------------------------  

-какво е това поток, за какво служии как се ползва.
- какво е текстов файл и как се чете и пише в текстови файлове
- Ще демонстрираме и обясним добрите практики за 
прихващане и обработка на изключения, възникващи при работата с 
файлове.

Потоци

Да уточним, че терминът вход (input) се 
асоциира с четенето на информация, а терминът изход (output) – със 
записването на информация.

Какво представляват потоците?

Потокът е наредена последователност от байтове, които се изпращат от 
едно приложение или входно устройство и се получават в друго приложение или изходно устройство. Тези байтове се изпращат и получават един 
след друг и винаги пристигат в същия ред, в който са били изпратени. 
Потоците са абстракция на комуникационен канал за данни, който свързва 
две устройства или програми.

Модерните сайтове в Интернет не могат без потоци и така наречения 
streaming (произлиза от stream - поток), който представлява достъпване 
на големите мултимедийни файлове по уеб страниците чрез поток. Това 
позволява техния преглед да започне преди цялостното им сваляне, което 
повишава бързодействието на страницата.

Основни неща, които трябва да знаем за потоците
Потоците се използват, за да четем и записваме данни от и на различни
устройства.
Потоците са подредени серии от байтове. Не случайно наблягаме на 
думата подредени.
По никакъв начин не можем да си 
позволим да влияем на подредбата на информацията в потока, защото по 
този начин ще я направим неизползваема.

Потоците позволяват последователен достъп до данните си.
Може да 
манипулираме данните само в реда, в който те пристигат от потока.

За различните ситуации има различни видове потоци. Едни служат за 
работа с текстови файлове, други – за работа с бинарни (двоични) файлове, 
трети пък – за работа със символни низове. Различни са и потоците, които 
се използват при мрежова комуникация. Голямото изобилие от потоци ни 
улеснява в различните ситуации, но също така и ни затруднява, защото 
трябва да сме запознати със спецификата на всеки отделен тип, преди да 
го използваме в приложението си.

 -----------------------------  -Потоци в Java – основни класове -----------------------------  -

В Java класовете за работа с потоци се намират в пакета java.io.

Можем да отличим два основни типа потоци – такива, които работят с 
двоични данни и такива, които работят с текстови данни. Ще се спрем на
основните характеристики на тези два вида след малко.

Общото между тях е организацията и структурирането им. На върха на 
йерархията стоят абстрактни класове съответно за вход и изход. Те няма 
как да бъдат инстанцирани, но дефинират основната функционалност, 
която притежават всички останали потоци. Съществуват и буферирани 
потоци, които не добавят никаква допълнителна функционалност, но 
позволяват работата с буфер при четене и записване на информацията, 
което значително повишава бързодействието. Буферираните потоци няма 
да се разглеждат в тази глава, тъй като ние се концентрираме върху 
обработката на текстови файлове. Ако имате желание, може да се допитате 
до богатата документация, достъпна в Интернет, или към някой учебник за 
по-напреднали в програмирането.


Основните класове в пакета java.iо са  InputStream, OutputStream, 
BufferedInputStream, BufferedOutputStream, DataInputStream, 
DataOutputStream, Reader, Writer, BufferedReader, BufferedWriter, 
PrintWriter и PrintStream.Сега ще се спрем по-обстойно на тях, разделяйки 
ги по основния им признак – типа данни, с които работят.

В тази глава в примерите за писане в текстов файл ще ползваме само 
PrintStream, защото е идеален за работа с текстови файлове и с него се 
борави изключително лесно

 -----------------------------  -Правило -----------------------------  ---
Винаги затваряйте потоците и файловете, с които работите!
 Оставянето на отворен поток или файл води до 
загуба на ресурси и може да блокира работата на други 
потребители или процеси във вашата система.
 -----------------------------  -Правило -----------------------------  ---

 -----------------------------  -Двоични и текстови потоци -----------------------------  -
Както споменахме по-рано, можем да разделим потоците на две големи 
групи в съответствие с типа данни, с който боравят, а именно – двоични 
потоци и текстови потоци

 -----------------------------  -Двоични потоци -----------------------------  -

От името им личи, че работят с двоични данни. Сами се досещате, че това 
ги прави универсални и тях може да ползваме за четене на информация от 
всякакви файлове (картинки, музикални и мултимедийни файлове, 
текстови файлове и т.н.). Ще ги разгледаме накратко, защото за момента 
се ограничаваме до работа с текстови файлове.

Двата основни абстрактни класа, които седят в дъното на йерархията на 
двоичните потоци са съответно InputStream за вход и OutputStream за изход. 
Както казахме по-горе, те не могат да се инстанцират, но дефинират 
основната функционалност и се ползват при създаването на другите 
двоични потоци.

InputStream ни предлага различни методи за четене (четене само на един 
байт, четене на произволен брой байтове и записването им в масив и т.н.), 
пропускане на определен брой байтове, проверяване на броя достъпни 
байтове и, разбира се, метод за затваряне на потока. Обект от този клас 
може да получим от източник, извиквай съответния му метод.

OutputStream също е абстрактен клас. Той съдържа базовата функционалност за записване на информация в даден източник. Основните му 
методи ни позволяват да записваме различен брой байтове в източника, да 
прочистваме буфера на потока и, отново, да затваряме потока.

Другите класове за работа с бинарни потоци са BufferedInputStream, 
BufferedOutputStream, DataInputStream, DataOutputStream. За да можем да 
създадем обекти от тях, се нуждаем от обект от InputStream или, съответно,
OutputStream.

 -----------------------------  -Текстови потоци -----------------------------  -

Текстовите потоци са много подобни на двоичните, но работят само с 
текстови данни или, по-точно казано, с данни от символен тип (char). 
Идеални са за работа с текстови файлове. От друга страна това ги прави 
неизползваеми при работа с каквито и да е бинарни файлове.

Основните класове за работа с текстови потоци са Reader и Writer. Те са 
аналогични на основните класове от двоичните потоци. Методите им са 
същите, но вместо аргументи от тип byte приемат char. Както знаете, 
символите в Java са Unicode символи, но потоците могат да работят освен с 
Unicode и с други кодирания.
Съществуват и буферираните варианти BufferedReader и BufferedWriter, 
които се отличават с по-голямото си бързодействие.
Важно място има и класа PrintWriter, но той не е във фокуса на тази глава. 
Ако имате желание, може да погледнете документацията на Java API-то или 
източници в Интернет.
Класът, на когото ще обърнем най-голямо внимание е PrintStream. Той в 
голяма част се припокрива с PrintWriter, но има някой специфични 
особености. За да създадем обект от PrintStream класа ни е нужен файл или 
символен низ с име и път до файла. Той има много полезни методи, като 
например добре познатите print(…) и println(…). Всъщност System.out не е 
нищо повече от обект от тип PrintStream. Ето защо боравейки с този клас 
ще можем да използваме всички методи, с които вече сме добре запознати 
от работата ни с конзолата. Това, с което PrintStream класа се отличава, е, 
че скрито от нас той превръща текста в байтове преди да ги запише на 
желаното място. Леснотата, с която се работи с него и големите му 
възможности го правят идеален за използване в примерите, които ще 
последват по-напред в тази глава.

 -----------------------------  Четене от текстов файл -----------------------------  
Текстовите файлове предоставят идеалното решение за записване на 
данни, които трябва да ползваме често, а са твърде обемисти, за да ги 
въвеждаме ръчно всеки път, когато стартираме програмата. Сами се 
убеждавате, че тази практика изисква идеално владение на механизмите 
за четене на текстови файлове.

Java платформата предоставя множество начини за четене от файлове, но 
не всички са много лесни и интуитивни за използване. Ето защо се спираме 
на нещо познато за вас – класът java.util.Scanner. Сигурно до сега стотици 
пъти ви се е налагало да го ползвате за всевъзможни операции. Именно за 
това считаме, че ще е идеален за случая, защото е най-лесния начин за 
четене на текстов файл и същевременно сте имали много шансове да го 
усвоите до съвършенство.

Класът java.util.Scanner за четене на текстов файл

В момента сигурно сте малко объркани. До тук казахме, че четенето и 
записването в текстови файлове става само и изключително с потоци, а, 
същевременно, java.util.Scanner не се появи никъде в изброените по-горе 
потоци и не сте сигурни дали въобще е поток. Наистина, java.util.Scanner
не е поток, но може да работи с потоци. Той предоставя най-лесния и

разбираем начин за четене от текстов файл като се има предвид, че често 
до сега сте го използвали за четене на различни неща от конзолата.
Едно от големите предимства на java.util.Scanner е, че не е нужно да има 
поток, за да бъде създаден. Може да го създадем просто от файл, което 
значително ни улеснява и намалява вариантите за грешка. При създаването 
можем да уточним и кодирането. Ето пример как може да бъде създаден 
обект от класа java.util.Scanner:


// Link the File variable to a file on the computer
File file = new File("test.txt");

// Create a Scanner connected to a file and specify encoding
Scanner fileReader = new Scanner(file, "windows-1251");

// Read file here...

// Close the resource after you've finished using it
fileReader.close();

Първото, което трябва да направим е да създадем променлива от тип 
java.io.File, която да свържем с конкретен файл от нашия компютър. За 
целта е нужно само да подадем като параметър в конструктора му името на 
желания файл. Имайте предвид, че ако файлът се намира в папката на 
проекта, то можем да подадем само конкретното му име. В противен случай 
трябва да подадем пълния път до файла.


Не забравяйте при подаване на пълния път до даден файл 
да направите escaping на наклонените черти, които се 
използват за разделяне на папките ("C:\\Temp\\test.txt", а 
не "C:\Temp\test.txt"). По възможност избягвайте пълни 
пътища и работете с релативни!

Вече можем да създадем и нашия java.util.Scanner. Като параметри този 
път подаваме новосъздадената файлова променлива и име на encoding 
(като String), който желаем да ползваме при прочитането на файла (в този 
случай използваме windows-1251). Така можем да го ползваме за прочитане 
на желаната информация. Ако не укажем изрично кодиране, Java използва 
кодирането по подразбиране в операционната система (което може да е 
различно на различни компютри)

При Scanner имаме предупреждение за Exception.
За прихващането и 
обработването на изключителни ситуации при работа с файлове ще стане 
дума малко по-късно в тази глава, в секцията "Обработка на грешки".

 -----------------------------   Четене на текстов файл ред по ред – пример  -----------------------------  

File file = new File("sample.txt");
	// Next line may throw an exception!
Scanner fileReader = new Scanner(file);
	int lineNumber = 0;
	// Read file
while (fileReader.hasNextLine()) {
	lineNumber++;
	System.out.printf("Line %d: %s%n", 
	lineNumber, fileReader.nextLine());
}

fileReader.close();

 -----------------------------  Кодиране на файловете. Четене на кирилица -----------------------------  
Проблемите, които се появяват при четене с некоректно кодиране,
 например при четене на файл на кирилица.
 
 -----------------------------  Кодиране (encoding) -----------------------------  

Добре знаете, че в паметта на компютрите всичко се запазва в двоичен вид. 
Фактически, това означава, че се налага и текстовите файлове да се 
представят цифрово, за да могат да бъдат съхранени в паметта. Този процес 
се нарича кодиране на файловете.

Кодирането се състои в заместването на текстовите символи (цифри, букви, 
препинателни знаци и т.н.) с точно определени числови стойности. Може 
грубо да си го представите като голяма таблица, в която срещу всеки 
символ стои определена стойност (пореден номер).

Пример за кодираща схема (encoding или charset) е например ISO 8859-1, 
windows-1251, UTF-8, KOI8-R и т.н. Това е една таблица със символи и техните 
номера, но може да съдържа и специални правила. Например символът 
"ударение" (U+0300) е специален и се залепя за последния символ, който 
го предхожда.

Четене на кирилица
Вероятно вече се досещате, че ако искаме да четем от файл, който съдържа 
символи от кирилицата, трябва да използваме точния encoding, който 
"разбира" тези специални символи. Такъв именно е windows-1251. С него 
спокойно можем да четем текстови файлове, съдържащи кирилица. 
Единственото, което трябва да направим, е да го определим като encoding 
на потока, който ще обработваме с нашия Scanner (погледнете отново 
примера за създаване на Scanner).

Ако не укажем изрично кодиращата схема (encoding) за четене от файла, 
ще бъде използван системният encoding, който е различен на всеки един 
компютър. В такъв случай програмата може и да работи коректно, но може 
и да не работи коректно. Може да се случи и нещо по-лошо: при нас 
програмата да работи коректно, а като я занесем при клиента, за който е 
предназначена, там да се счупи кирилицата.

Може би се чудите какво става, ако "омажем" кодирането при четене или 
писане във файл. Възможни са няколко сценария:

- Ако ползваме само латиница, всичко ще работи нормално.
- Ако ползваме кирилица и четем с грешен encoding, ще прочетем т. 
нар. каракацили (познати още като джуджуфлечки или маймуняци). 
Това са случайни безсмислени символи.
- Ако записваме кирилица в кодиране, което не поддържа кирилската 
азбука, буквите от кирилицата ще бъдат заменени безвъзвратно със 
символа "?" (въпросителна).

 -----------------------------  Стандартът Unicode. Четене на Unicode -----------------------------  
Unicode представлява индустриален стандарт, който позволява на компютри и други електронни устройства винаги да представят и манипулират 
по един и същи начин текст, написан на повечето от световните 
писмености. Той се състои от дефиниции на над 100 000 символа, както и 
разнообразни стандартни кодиращи схеми (encodings). Обединението на 
различните символи, което ни предлага Unicode, води до голямото му 
разпространение. Както знаете, символите в Java (типовете char и String) 
също се представят в Unicode.
За да прочетем символи, записани в Unicode, трябва да използваме някоя
от поддържаните в този стандарт кодиращи схеми (encodings). Найизвестен и широко използван е UTF-8. Той представя стандартните ASCII 
символи с 1 байт, а всички останали – с до 4 байта. Можем да го определим 
за encoding по вече познатия ни начин (погледнете отново примера за 
създаване на Scanner):

File file = new File("sample.txt");
Scanner scanner = new Scanner(file, "UTF-8");

Ако се чудите дали за четене на текстов файл на кирилица да ползвате 
кодиране windows-1251 или UTF-8, на този отговор няма ясен отговор. И 
двата стандарта масово се ползват за записване на текстове на български 
език. И двете кодиращи схеми за позволени и може да ги срещнете.

GPT 4 - казва че UTF-8 е по добър с повече предимства.

Писане в текстов файл
-можем да записваме резултатите от изпълнението на дадена програма
-можем да ги ползваме, 
примерно и за да направим нещо като дневник на програмата
– удобен 
начин за следене кога се е стартирала, отбелязване на различни грешки 
при изпълнението и т.н.

-Ще ползваме  System.out. Това не е 
нищо повече от инстанция на класа, който ще използваме за писане в 
текстови файлове, а именно java.io.PrintStream.

Класът java.io.PrintStream
-ползва се изключително и само за работа с текстови данни.

За 
разлика от другите текстови потоци, преди да запише данните на желаното 
място, той ги превръща в байтове. PrintStream ни дава възможност при
създаването си да определим желания от нас encoding. Можем да създадем 
инстанция на класа по следния начин:

PrintStream fileWriter = new PrintStream(
"test.txt", "windows-1251");

Като параметри на конструктора трябва да подадем файл/име на файл и 
ако искаме, желаният от нас encoding. Този ред код отново може да 
предизвикат появата на грешка. 

 -----------------------------  Отпечатване на числата от 1 до 20 в текстов файл – пример -----------------------------  

	// Create a PrintStream instance
PrintStream fileWriter = new PrintStream("numbers.txt");
	// Loop through the numbers from 1 to 20 and write them
for (int num = 1; num <= 20; num++) {
	fileWriter.println(num);
}
	// Close the stream when you are done using it
	fileWriter.close();

- ако дадем име на файл който не съществува той сам ще се създаде,
а ако вече съществува ще се презапише
(ще се загуби старото съдържание).

	Когато искате да печатате кирилица и се чудите кое кодиране да ползвате, 
предпочитайте кодирането UTF-8. То е универсално и поддържа не само 
кирилица, но и всички широкоразпространени световни азбуки: гръцки, 
арабски, китайски, японски и др.

 -----------------------------  Обработка на грешки -----------------------------  
 -----------------------------  Прихващане на изключения при работа с файлове -----------------------------  

-FileNotFoundException може да възникне при ползване на:
Scanner или PrintStream.

- При създаване на Scanner или PrintStream,
ако излезне UnsupportedEncodingException значи
избраният от нас encoding не е поддържан.

-IOException. базов за 
всички входно-изходни грешки при работа с потоци.

Стандартния подход е : правим променлива и инициализираме с нулл,
а в try/catch инициализираме с файла.

Прихващане на грешка при отваряне на файл –
пример

String fileName = "sample.txt";
Scanner fileReader = null;
int lineNumber = 0;
try {
	fileReader = new Scanner(new File(fileName));
	System.out.println("File " + fileName + " opened.");
	while (fileReader.hasNextLine()) {
		lineNumber++;
		System.out.printf("Line %d:%s%n", 
			lineNumber, fileReader.nextLine());
	}
} catch (FileNotFoundException fnf) {
	System.out.println("File " + fileName + " not found.");
} catch (NullPointerException npe) {
	System.out.println("File " + fileName + " not found.");
} finally {
	// Close the scanner in the finally block
	if (fileReader != null) {
		fileReader.close();
	}
	System.out.println("Scanner closed.");
}


Брой срещания на дума във файл – пример

String fileName = "sample.txt";
Scanner fileReader = null;
int occurrences = 0;
String word = "Java";
	try {
		fileReader = new Scanner(new File(fileName));
		System.out.println("File " + fileName + " opened.");
		while (fileReader.hasNextLine()) {
		String line = fileReader.nextLine();
		int index = line.indexOf(word);
		while (index != -1) {
		occurrences++;
		index = line.indexOf(word, (index + 1));
	}
	}
	} catch (FileNotFoundException fnf) {
		System.out.println("File " + fileName + " not found.");
	} catch (NullPointerException npe) {
		System.out.println("File " + fileName + " not found.");
	} finally {
		if (fileReader != null) {
		fileReader.close();
		}
	System.out.println("Scanner closed.");
}
System.out.printf("The word %s occurs %d times", word, occurrences);

За леснота в примера думата, която търсим е твърдо кодирана (hardcoded). 
Вие може да реализирате програмата така, че да търси дума, въведена от 
потребителя.

Коригиране на файл със субтитри – пример

Сега ще разгледаме един по-сложен пример, в който едновременно четем 
от един файл и записваме в друг.

text  -----------------------------  -
{1029}{1122}{Y:i}Капитане, системите са|във шибана готовност.
{1123}{1270}{Y:i}Шибаното налягане е стабилно.|- Пригответе се за 
шибаното кацане.
{1343}{1468}{Y:i}Моля, затегнете коланите|и се настанете по местата 
си.
{1509}{1610}{Y:i}Координати 5.6|- Пет, пет, шест, точка ком.
{1632}{1718}{Y:i}Къде се дянаха|шибаните координати?
{1756}{1820}Командир Логар,|всички говорят на английски.
{1821}{1938}Не може ли да преминем|на турски още от началото?
{1942}{1992}Може!
{3104}{3228}{Y:b}Г.О.Р.А.|филм за космоса

За да го коригираме, просто трябва да нанесем корекция във времето за 
показване на субтитрите. Такава корекция може да бъде отместване (добавяне или изваждане на някаква константа) или промяна на скоростта 
(умножаване по някакви число, примерно 1.05).

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.util.Scanner;
public class FixingSubtitles {
private static final int COEFFICIENT = 2;
private static final int ADDITION = 5000;
private static final String INPUT_FILE = "GORA.sub";
private static final String OUTPUT_FILE = "fixed.sub";
public static void main(String[] args) {
	Scanner fileInput = null;
	PrintStream fileOutput = null;
	try {
	// Create scanner with the Cyrillic encoding
	fileInput = new Scanner(
	new File(INPUT_FILE), "windows-1251");
	// Create PrintWriter with the Cyrillic encoding
	fileOutput = new PrintStream(
	OUTPUT_FILE, "windows-1251");
	String line;
	while (fileInput.hasNextLine()) {
	line = fileInput.nextLine();
	String fixedLine = fixLine(line);
	fileOutput.println(fixedLine);
	}
	} catch (FileNotFoundException fnfe) {
	System.err.println(fnfe.getMessage());
	} catch (UnsupportedEncodingException uee) {
	System.err.println(uee.getMessage());
	} finally {
	if (null != fileInput) {
	fileInput.close();
	}
	if (null != fileOutput) {
	fileOutput.close();
	}
	}
}
private static String fixLine(String line) {
	// Find closing brace
	int bracketFromIndex = line.indexOf('}');
	// Extract 'from' time
	String fromTime = line.substring(1, bracketFromIndex);
	// Calculate new 'from' time
	int newFromTime = 
		Integer.parseInt(fromTime) * COEFFICIENT + ADDITION;
	// Find the following closing brace
	int bracketToIndex = line.indexOf('}', bracketFromIndex+1);
	// Extract 'to' time
	String toTime = 
	line.substring(bracketFromIndex + 2, bracketToIndex);
	// Calculate new 'to' time
	int newToTime = 
	Integer.parseInt(toTime) * COEFFICIENT + ADDITION;
	// Create a new line using the new 'from' and 'to' times
	String fixedLine = "{" + newFromTime + "}" + "{" +
	newToTime + "}" + line.substring(bracketToIndex + 1);
		return fixedLine;
	}
}


------------- не съм решил задачите от главата  -----------------------------  ---


 -----------------------------  --------Глава 16. Линейни структури от данни  -----------------------------  -
В настоящата тема ще се запознаем с някои от 
основните представяния на данните в програмирането. Ще видим как при 
определена задача една структура е по-ефективна и удобна от друга. Ще 
разгледаме структурите "списък", "стек" и "опашка" и тяхното приложение. 
Подробно ще се запознаем и с някои от реализациите на тези структури.

 -----------------------------  Абстрактни структури от данни -----------------------------  
- ще се запознаем с често използвани структури от данни (като 
списъци и хеш-таблици)
 -----------------------------  Какво е структура данни? -----------------------------  
В този момент на помощ ни идват структурите данни – множество от данни 
организирани на основата на логически и математически закони. Много 
често избора на правилната структура прави програмата много поефективна – можем да спестим памет и време за изпълнение.

 -----------------------------  Какво е абстрактен тип данни? -----------------------------  
Най-общо абстрактният тип данни (АТД) дава определена дефиниция 
(абстракция) на конкретната структура т.е. определя допустимите операции и свойства, без да се интересува от конкретната реализация. Това 
позволява един тип абстрактни данни да има различни реализации, 
респективно различна ефективност.

 -----------------------------  Основни структури от данни в програмирането -----------------------------  

- Линейни – към тях спадат списъците, стековете и опашките
- Дървовидни – различни типове дървета
- Речници – хеш-таблици
- Множества

 -----------------------------  Списъчни структури -----------------------------  
Най–често срещаните и използвани са линейните (списъчни) структури.
Те представляват абстракция на всякакви видове редици, последователности, 
поредици и други подобни от реалния свят.

Списък
- редица от елементи.
- покупките от магазина.

Абстрактна структура данни "списък"

Списък е линейна структура от данни, която съдържа поредица от 
елементи. Списъкът има свойството дължина (брой елементи) и елементите 
му са наредени последователно.

Списъкът позволява добавяне елементи на всяко едно място както и 
премахването им, както и последователното им обхождането. Както 
споменахме по-горе един АТД може да има няколко реализации. Пример за 
такъв АТД е интерфейсът java.util.List.

Интерфейсите в Java изграждат една "рамка" за техните имплементации –
класовете. Тази рамка представлява съвкупност от методи и свойства, 
които всеки клас, имплементиращ интерфейса, трябва да реализира (типът 
данни "интерфейс" в Java ще дискутираме подробно в главата "Принципи 
на обектно-ориентираното програмиране").


Всеки АТД реално определя някакъв интерфейс. Нека разгледаме интерфейса java.util.List. Основните методи, които той декларира, са:
- void add(int, Object) - добавя елемент на предварително избрана 
позиция
- boolean contains(Object) – проверява дали елемента се съдържа в 
списъка
- Object get(int) – взима елемента на съответната позиция
- boolean isEmpty() – проверява дали списъка е празен
- boolean remove(Object) – премахва съответния елемент
- Object remove(int) – премахва елемента на дадена позиция
- int indexOf(Object) – връща позицията на елемента
Нека видим няколко от основните реализации на АТД списък и обясним в 
какви ситуации се използва всяка от тях.


 -----------------------------   Статичен списък (реализация чрез масив)  -----------------------------  
Масивите изпълняват много от условията АТД списък, но имат една 
съществена разлика – списъците позволяват добавяне на нови елементи, 
докато масивите имат фиксиран размер.

-------- Примера е само в учебника стр 531 не съм го копирал никъде
- примера представлява  реализация чрез стрингове и масив които 
го променяме, което всичко е неефективно затова не съм го сложил тук.



 -----------------------------   Свързан списък (динамична реализация) -----------------------------  

Както видяхме, статичният списък има един сериозен недостатък – операциите добавяне и премахване от средата на списъка изискват преподреждане на елементите. При често добавяне и премахване (особено при голям 
брой елементи) това може да доведе до ниска производителност. В такива 
случаи се използват т. нар. свързани списъци. Разликата при тях е в 
структурата на елементите – докато при статичния списък елементите 
съдържат само конкретния обект, при динамичния списък елементите пазят 
информация за следващия елемент.

-------- Примера е само в учебника стр 536 не съм го копирал
 никъде защото показва само реализация която не е ефективна.
 
 -----------------------------   Двойно свързани списъци -----------------------------  

 -----------------------------  Класът ArrayList  -----------------------------  

След като се запознахме с някои от основните реализации на списъците, 
ще се спрем на класовете в Java, които ни предоставят списъчни структури 
"на готово". Първият от тях е класът ArrayList, който представлява 
динамично-разширяем масив. Той е реализиран по сходен начин със 
статичната реализация на списък, която разгледахме по-горе. Имаме 
възможност да добавяме, премахваме и търсим елементи. Някои по-важни 
методи, които можем да използваме са:

- add(Object) – добавяне на нов елемент
- add(index, Object) – добавяне елемент на определено място (индекс)
- size() – връща броя на елементите в списъка
- remove(Object) – премахване определен елемент
- remove(index) – премахване на елемента на определено място 
(индекс)
- clear() – изчистване на списъка


- във ArrayList са решени проблемите за премахване на елементи,
преоразмеряваме и др .

 -----------------------------  Класът ArrayList – пример -----------------------------  
В класа ArrayList можем да записваме всякакви елементи – числа, 
символни низове и други обекти. Ето един малък пример:

public static void main(String[] args) {
	ArrayList list = new ArrayList();
	list.add("Hello");
	list.add(5);
	list.add(3.14159);
	list.add(new Date());
	
	for (int i=0; i<list.size(); i++) {
	Object value = list.get(i);
	System.out.printf("Index=%d; Value=%s\n", i, value);
	}
}

/// Result 
Index=0; Value=Hello
Index=1; Value=5
Index=2; Value=3.14159
Index=3; Value=Sat Nov 29 23:17:01 EET 2008

 -----------------------------   ArrayList с числа – пример  -----------------------------  
- ArrayList не може да пази числа а обекти.
-ако записваме числа и после искаме да ги съберем трябва да ги
преубразуваме  от Object към число.

ArrayList list = new ArrayList();
list.add(2);
list.add(3);
list.add(4);
int sum = 0;
for (int i=0; i<list.size(); i++) {
Integer value = (Integer) list.get(i);
sum = sum + value.intValue();
}
System.out.println("Sum = " + sum);
// Output: Sum = 9

Ако пуснете горния пример в Eclipse, ще получите множество забележки, 
идващи от компилатора, които ви напомнят, че ползвате непараметризиран 
тип на данните, което не е добра практика. Преди да ви покажем още 
примери за работа с класа ArrayList ще да ви запознаем с една концепция 
в Java, наречена "шаблонни типове данни". Тя дава възможност да се 
параметризират списъците и колекциите в Java и улеснява значително 
работата с тях.


 -----------------------------  -Шаблонни класове (generics) -----------------------------  -
Когато използваме класа ArrayList, а и всички класове, имплементиращи 
интерфейса java.util.List, се сблъскваме с проблема, който видяхме погоре: когато добавяме нов елемент от даден клас ние го предаваме като 
обект от тип Object. Когато по-късно търсим даден елемент, ние го 
получаваме като Object и се налага да го превърнем в изходния тип. Не ни 
се гарантира, обаче, че всички елементи в списъка ще бъдат от един и същ 
тип. Освен това превръщането от един тип в друг отнема време, което 
забавя излишно изпълнението на програмата.
За справяне в описаните проблеми на помощ идват шаблонните класове. 
Образно казано те са шаблони създадени да работят с един или няколко 
типа, като при създаването си ние указваме какъв точно тип обекти ще 
съхраняваме в тях. Създаването на инстанция от даден шаблонен тип, 
примерно GenericType, става като в счупени скоби се зададе типа, от който 
трябва да бъдат елементите му:

GenericType<T> instance = new GenericType<T>();

Този тип T може да бъде всеки наследник на класа java.lang.Object, 
примерно String или Date. Понеже числата не са обекти и не наследяват 
класа Object, ако трябва да ги използваме като тип в шаблонен клас, трябва 
да използваме съответния им обвиващ (wrapper) клас. Така вместо 

примитивния тип int трябва да ползваме класа Integer, a вместо типа 
boolean трябва да ползваме класа Boolean. Ето няколко примера:

ArrayList<Integer> intList = new ArrayList<Integer>();
ArrayList<Boolean> boolList = new ArrayList<Boolean>();
ArrayList<Double> realNumbersList = new ArrayList<Double>();

Нека сега разгледаме някои от шаблонните колекции в Java.

 -----------------------------   Класът ArrayList<T>  -----------------------------  
ArrayList<T> е шаблонният вариант на ArrayList. При инициализацията на 
обект от тип ArrayList<T> указваме типа на елементите, който ще съдържа 
списъка, т. е. заместваме означения с T тип с някой истински тип данни 
(например число или стринг).
Например искаме да създадем списък от целочислени елементи. Можем да 
го направим по следния начин:

ArrayList<Integer> genericList = new ArrayList<Integer>();

Създаденият по този начин списък може да приема като стойности цели 
числа, но не може и други обекти, например символни низове. Ако се 
опитаме да добавим към ArrayList<Integer> обект от тип String, ще 
получим грешка по време на компилация. Чрез шаблонните типове 
компилаторът на Java ни пази от грешки при работа с колекции.
Забележете, че не посочваме типа int, а неговия обвиващ тип Integer. 
Причината за това е фактът, че шаблоните приемат като параметър само 
референтни типове (обекти) и не могат да работят с обикновени стойностни 
типове, които не се пазят в динамичната памет. По тази причина ползването 
на ArrayList<String> става директно, а ползването на списък от int или 
double изисква да ползваме съответните обвиващи типове: 
ArrayList<Integer> и ArrayList<Double>.

Класът ArrayList – представяне чрез масив

Класът ArrayList се представя в паметта като масив, от който една част 
съхранява елементите му, а останалите са свободни и се пазят като 
резервни. Благодарение на резервните празни елементи в масива операцията добавяне почти винаги успява да добави новия елемент без да 
разширява (преоразмерява) масива. Понякога, разбира се, се налага 
преоразмеряване, но понеже всяко преоразмеряване увдвоява размера на 
масива, това се случва толкова рядко, че може да се пренебрегне на фона 
на броя добавяния. Можем да си представим един ArrayList като масив, 
който има някакъв капацитет и запълненост до определено ниво:

Благодарение на резервното пространство в масива, съхраняващ елементите на класа ArrayList<Т>, той е изключително удобна структура от данни, 
когато е необходимо бързо добавяне на елементи, извличане на всички 
елементи и пряк достъп до даден елемент по индекс.
Може да се каже, че ArrayList<Т> съчетава добрите страни на списъците и 
масивите – бързо добавяне, променлив размер и директен достъп по 
индекс.

 -----------------------------   Класът ArrayList – истинско представяне в паметта -------------

Ако трябва да сме точни, трябва да отбележим, че горната картинка 
всъщност не отразява точното представяне на класа ArrayList<T> в паметта. 
Причината за това е, че в Java няма истински шаблонни типове, а само 
имитация на такива. Всички шаблонни типове Т изчезват още по време на 
компилация и се преобразуват в Object, т. е. долните три дефиниции след 
компилация стават абсолютно еднакви:

ArrayList<Integer> genericList = new ArrayList<Integer>();
ArrayList<Object> objList = new ArrayList<Object>();
ArrayList plainList = new ArrayList ();

Всички параметрирзирани колекции в Java са всъщност колекции от обекти 
и по тази причина работят по-бавно, отколкото масивите от примитивни 
типове (например int[]). При записването на нов елемент от примитивен
тип в ArrayList той се премества в динамичната памет. При достъп до 
елемент от ArrayList, той се връща като обект и след това може да бъде 
преобразуван обратно към примитивен тип (например към число).
Нека сме изпълнили следния код:

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(2);
list.add(3);
list.add(4);
list.add(5);

Вижда се, че всяка отделна стойност на списъка от числа е обект от тип 
Integer, разположен в динамичната памет (heap). В масива се пазят не 
самите стойности на елементите, а техните адреси (указатели). По тази 
причина достъпът до елементите на ArrayList<Integer> е по-бавен, 
отколкото достъпът до елементите на int[].

 -----------------------------   Кога да използваме ArrayList<T>?  -----------------------------  

Както вече обяснихме, класът ArrayList<T> използва вътрешно масив за 
съхранение на елементите, който удвоява размера си, когато се препълни. 
Тази негова специфика води до следните особености:
- Търсенето по индекс става много бързо – можем да достъпваме с 
еднаква скорост всеки един от елементите независимо от общия им 
брой.
- Търсенето по стойност на елемент работи с толкова сравнения, 
колкото са елементите, т.е. не е бързо.
- Добавянето и премахването на елементи е бавна операция – когато 
добавяме или премахваме елементи, особено, ако те не се намират в 
края на списъка, се налага да разместваме всички останали елементи, 
а това е много бавна операция.
- При добавяне понякога се налага и увеличаване на капацитета на 
масива, което само по себе си е бавна операция, но се случва много 
рядко и средната скорост на добавяне на елемент към ArrayList не 
зависи от броя елементи, т.е. работи много бързо.

 -----------------------------   Правило -----------------------------  
Използвайте ArrayList<T>, когато не очаквате често 
вмъкване и премахване на елементи, но очаквате да 
добавяте нови елементи в края или ползвате елементите 
по индекс.

 -----------------------------   Правило -----------------------------  


Прости числа в даден интервал – пример

public static ArrayList<Integer> getPrimes(int start, int end) {
	ArrayList<Integer> primesList = new ArrayList<Integer>();
	for (int num = start; num <= end; num++) {
	boolean prime = true;
		for (int div = 2; div <= Math.sqrt(num); div++) {
			if (num % div == 0) {
				prime = false;
				break;
			}
		}
	if (prime)
		primesList.add(num);
	}
	return primesList;
}
public static void main(String[] args) {
	ArrayList<Integer> primes = getPrimes(200, 300);
	for (int p : primes) {
		System.out.printf("%d ", p);
	}
	System.out.println();
}

От математиката знаем, че ако едно число не е просто, то съществува поне 
един делител в интервала [2 …к орен квадратен от даденото число]. Точно 
това използваме в примера по-горе. За всяко число търсим дали има 
делител в този интервал. Ако срещнем, то числото не е просто и можем да 
продължим със следващото. 

 -----------------------------   Обединение и сечение на списъци – пример  -----------------------------  

Можем да приемем, че имаме два списъка и искаме да вземем елементите, 
които се намират и в двата едновременно (сечение) или търсим тези, които 
се намират поне в единия от двата (обединение).
Нека разгледаме едно възможно решение на задачата: стр 549

Програмната логика в това решение директно следва определенията за 
обединение и сечение на множества. Ползваме операциите търсене на 
елемент в списък и добавяне на елемент към списък.
Ще решим проблема по още един начин: като използваме методите 
addAll(Collection c) и retainAll(Collection c) от интерфейса java. 
util.Collection, който ArrayList имплементира:

str  549
public static void main(String[] args) {
	ArrayList<Integer> firstList = new ArrayList<Integer>();
	firstList.add(1);
	firstList.add(2);
	firstList.add(3);
	firstList.add(4);
	firstList.add(5);
	System.out.print("firstList = ");
	printList(firstList);
	
	ArrayList<Integer> secondList = new ArrayList<Integer>();
	secondList.add(2);
	secondList.add(4);
	secondList.add(6);
	System.out.print("secondList = ");
	printList(secondList);
	
	ArrayList<Integer> unionList = new ArrayList<Integer>();
	unionList.addAll(firstList);
	unionList.removeAll(secondList);
	unionList.addAll(secondList);
	System.out.print("union = ");
	printList(unionList);
	
	ArrayList<Integer> intersectList = new ArrayList<Integer>();
	intersectList.addAll(firstList);
	intersectList.retainAll(secondList);
	System.out.print("intersect = ");
	printList(intersectList);
}

За да направим сечение правим следното: слагаме всички елементи от 
първия списък, след което премахваме всички елементи, които не се 
съдържат във втория (чрез retainAll()). Обединението правим като 
добавим елементите от първия списък, след което премахнем всички които 
се съдържат и в двата (чрез removeAll()), след което добавяме всички 
елементи от втория списък

Превръщане на ArrayList в масив и обратното

Тъй като класът ArrayList<T> и масивите много си приличат, често се налага 
да преобразуваме от ArrayList<T> към масив T[] и обратното. За 
преобразуването на масив към ArrayList няма стандартен метод или 
конструктор. За обратното преобразование има системен метод toArray(), 
но той има някои особености: изисква да му се подаде като параметър 
резултатният масив и след това да се извърши преобразование на 
върнатата стойност.

import java.util.ArrayList;
import java.util.Arrays;
public class ArrayConversions {
	public static void main(String[] args) {
	int[] arr = new int[] {1, 2, 3};
	
	// Convert the array to ArrayList
	ArrayList<Integer> list =
		new ArrayList<Integer>(arr.length);
	for (int i=0; i<arr.length; i++) {
		list.add(arr[i]);
	}
	
	// Append new number to the ArrayList
	list.add(4);
	
	// Convert the ArrayList to array
	Integer[] ints = 
		(Integer[]) list.toArray(new Integer[list.size()]);
		
	// Print the array
	System.out.println(Arrays.toString(ints));
	}
}

За съжаление в Java шаблонните класове и масивите не са измислени добре 
(както е направено в .NET, JavaScript и PHP) и поради това нямаме директна 
съвместимост между ArrayList и масив. Остава ни да се надяваме някой ден 
на Sun и на Java обществото да им дойде акъла и да поправят грешката си. 
До тогава ще преминаваме междумасиви и списъци ръчно, както в примера 
по-горе.


 -----------------------------  Класът LinkedList<T -----------------------------  

Класът LinkedList<T>
Този клас представлява динамична реализация на двусвързан списък.
 Елементите му пазят информация за обекта, който съхраняват, и указател към 
следващия и предишния елемент.

 -----------------------------  Кога да използваме LinkedList<T>? -----------------------------  

- Добавянето на елементи в LinkedList става много бързо – независимо 
от броя на елементите.
- Можем да добавяме бързо в началото и в края на списъка (за разлика 
от ArrayList<T>).
- Търсенето на елемент по индекс или по съдържание в LinkedList е 
бавна операция, тъй като се налага да обхождаме всички елементи 
последователно като започнем от началото на списъка.
- Изтриването на елемент е бавна операция, защото включва търсене.

 -----------------------------  Основни операции в класа LinkedList<T> -----------------------------  
LinkedList<T> притежава същите операции като ArrayList<T>, което прави 
двата класа взаимозаменяеми в зависимост от конкретната задача.
 Покъсно ще видим, че LinkedList<T> се използва и при работа с опашки.
 -----------------------------  Кога да ползваме LinkedList<T>? -----------------------------  
Като цяло класът LinkedList<T> се използва много рядко, защото 
ArrayList<T> върши същата работа не по-бавно, а предлага в допълнение и 
други бързи операции.


 -----------------------------  Стек -----------------------------  
Като кубчета едно върху друго.
Първи влязъл последен излязъл.

Стекът е често срещана и използвана 
структура от данни. Стек се използва и вътрешно от Java виртуалната 
машина за съхранение на променливите в програмата и параметрите при 
извикване на метод.

 -----------------------------  Абстрактна структура данни "стек" -----------------------------  
Може да има много реализации но ще се спрем на две основни 
-динамичната и статичната реализация.


Статичен стек (реализация с масив)
Както и при статичния списък и можем да използваме масив за пазене на 
елементите на стека. Можем да имаме индекс или указател, който сочи към 
елемента, който се намира на върха. Обикновено при запълване на масива 
следва заделяне на двойно повече памет, както това се случва при 
статичния списък (ArrayList).

Свързан стек (динамична реализация)
За динамичната реализация ще използваме елементи, които пазят, освен 
обекта, и указател към елемента, който се намира “по-долу". Тази 
реализация решава ограниченията, които има статичната реализация както 
и необходимостта от разширяване на масива при нужда:
Когато стекът е празен, върхът има стойност null. При добавяне на нов 
елемент, той се добавя на мястото, където сочи върхът, след което върхът
се насочва към новия елемент. Премахването става по аналогичен начин.


 -----------------------------  Класът Stack<T> -----------------------------  
В Java можем да използваме класа java.util.Stack<T>, предоставя
структурата от данни стек. Използвана е статичната имплементация като 
вътрешният масив се преоразмерява при необходимост.

Класът Stack<T> – основни операции

Реализирани са всички необходими операции за работа със стек:
- push(T) – позволява ни добавянето на нов елемент на върха на стека
- pop() – връща ни най-горния елемент като го премахва от стека
- peek() – връща най горния елемент без да го премахва
- size() – връща броя на елементите в стека
- clear() – премахва всички елементи
- contains(T) – проверява дали елемента се съдържа в стека
- toArray() – връща масив, съдържащ елементите от стека

 -----------------------------  Използване на стек – пример -----------------------------  

public static void main(String[] args) {
	Stack<String> stack = new Stack<String>();
	stack.push("1. Ivan");
	stack.push("2. Nikolay");
	stack.push("3. Maria");
	stack.push("4. George");
	System.out.println("Top = " + stack.peek());
	while (stack.size() > 0) {
	String personName = stack.pop();
	System.out.println(personName);
	}
}

Тъй като стекът е структура “последен влязъл – пръв излязъл", програмата 
ще изведе записите в ред обратен на реда на добавянето.

Проверка за съответстващи скоби – пример

public static void main(String[] args) {
	String expression = 
	 "1 + (3 + 2 - (2+3) * 4 - ((3+1)*(4-2)))";
	Stack<Integer> stack = new Stack<Integer>();
	boolean correctBrackets=true;
	
	for (int index = 0; index < expression.length(); index++) {
	char ch = expression.charAt(index);
	if (ch == '(') {
	stack.push(index);
	} else if (ch == ')') {
	if(stack.isEmpty()){
	correctBrackets=false;
	break;
	}
	stack.pop();
	} 
	}
	if(!stack.isEmpty())
	correctBrackets=false;
	System.out.println("Are the brackets correct? " +
	correctBrackets);
}

резултат //Are the brackets correct? true

 -----------------------------  Опашка -----------------------------  
Структурата "опашка" е създадена да моделира опашки, като
 например хора на каса.
 Можем да добавяме само отзад и изваждаме само отпред.
 
 
 -----------------------------   Статична опашка (реализация с масив) -----------------------------  

В статичната опашка отново ще използваме масив за пазене на данните. 
При добавяне на елемент той се добавя на индекса, който следва края, след 
което края започва да сочи към ново добавения елемент. При премахване 
на елемент, се взима елемента, към който сочи главата, след което главата 
започва да сочи към следващия елемент. По този начин опашката се 
придвижва към края на масива. Когато стигне до края, при добавяне на нов 
елемент той се добавя на първо място. Ето защо тази имплементация се 
нарича още зациклена опашка, тъй като мислено залепяме началото и 
края на масива и опашката обикаля в него:

 -----------------------------  Свързана опашка (динамична реализация) -----------------------------  
Динамичната реализация на опашката много прилича на тази на свързания 
списък. Елементите отново съдържат две части – обекта и указател към 
предишния елемент:

Тук обаче елементите се добавят на опашката, а се вземат от главата, като 
нямаме право да взимаме или добавяме елементи на друго място.

 -----------------------------  Интерфейсът Queue<T>  -----------------------------  

В Java се използва динамичната реализация на опашка чрез интерфейса 
Queue<T>. Както видяхме, интерфейсите декларират определени методи и 
свойства (т. е. АТД). При инициализация ние използваме класа 
LinkedList<T>, като му указваме да има поведение на опашка, т.е. 
получаваме имплементация със свързани елементи, която ще притежава 
методите на характерни за опашка. Тук отново можем да укажем типа на 
елементите, с които ще работим, тъй като опашката и свързаният списък са 
шаблонни типове.

 -----------------------------  Интерфейсът Queue<T> – основни операции  -----------------------------  
Queue<T> ни предоставя основните операции характерни за структурата 
опашка. Ето някои от често използваните:
- offer(T) – добавя елемент накрая на опашката
- poll() – взима елемента от началото на опашката и го премахва
- peek() – връща елементът от началото на опашката без да го премахва
- clear() – премахва всички елементи от опашката
- contains(Т) – проверява дали елемента се съдържа в опашката

 -----------------------------  Използване на опашка – пример  -----------------------------  
public static void main(String[] args) {
	Queue<String> queue = new LinkedList<String>();
	queue.offer("Message One");
	queue.offer("Message Two");
	queue.offer("Message Three");
	queue.offer("Message Four");
	while (queue.size() > 0) {
	String msg = queue.poll();
	System.out.println(msg);
	}
}

// резултат 
//Message One
//Message Two
//Message Three
//Message Four


 -----------------------------  Редицата N, N+1, 2*N – пример  -----------------------------  

public static void main(String[] args) {
	int n = 3;
	int p = 16;
	Queue<Integer> queue = new LinkedList<Integer>();
	queue.offer(n);
	int index = 0;
	System.out.print("S =");
	while (queue.size() > 0) {
	index++;
	int current = queue.poll();
	System.out.print(" " + current);
	if (current == p) {
	System.out.println();
	System.out.println("Index = " + index);
	return;
	}
		queue.offer(current + 1);
		queue.offer(2 * current);
	}
}
//резултат
//S = 3 4 6 5 8 7 12 6 10 9 16
//Index = 11


 -----------------------------  не съм решил задачите от главата  -----------------------------  


 -----------------------------  Глава 17. Дървета и графи  ----------------------------- 
- ползват се за моделиране на проблеми от реалността.

 -----------------------------  Дървета  -----------------------------  
В програмирането дърветата са изключително често използвана структура 
от данни, защото те моделират по естествен начин всякакви йерархии от 
обекти, които постоянно ни заобикалят в реалния свят. Нека дадем един 
пример, преди да изложим терминологията, свързана с дърветата. 

 -----------------------------  Терминология, свързана с дърветата  -----------------------------  
 стр 565
				   _
		  7		   	| 0
	   /  \  \		|
     19   21  14	| 1 дълбочина
	/ \ \    / \	|
   1  12 31 23  6  _| 2
- ребрата са това което свързва върховете.
- връх е всяка точка без значение къде.

- колкото по надолу е даден върх толкова е по млад 
- два съседни на широчина са братя, а един над друг родител и дете.
- корена няма предшественици.
- листа са върховете без наследници
- Вътрешни върхове са всички върхове, различни от корена и листата

Всяка една точка, ще наричаме връх, а всяка една отсечка – ребро. 
Върховете "19", "21" и "14" стоят под върха "7" и са директно свързани с 
него. Тях ще наричаме преки наследници (деца) на "7", а "7" – техен 
родител (баща). Аналогично "1", "12" и "31" са деца на "19" и "19" е техен 
родител. Съвсем естествено ще казваме, че "21" е брат на "19", тъй като са 
деца на "7" (обратното също е вярно – "19" е брат на "21"). От гледна точка 
на "1", "12", "31", "23" и "6", "7" е предшестващ ги в йерархията (в случая 
е родител на техните родители). Затова "7" ще наречем техен непряк 
предшественик (дядо, прародител), а тях – негови непреки 
наследници. 


-Корен е върхът, който няма предшественици. В нашия случай той е "7". 

-Листа са всички върхове, които нямат наследници. В примера – "1", "12", 
"31", "21", "23" и "6" са листа. 

-Вътрешни върхове са всички върхове, различни от корена и листата (т.е. 
всички върхове, които имат както родител, така и поне един наследник). 
Такива са "19" и "14". 

-Път ще наричаме последователност от свързани чрез ребра върхове, в 
която няма повтарящи се върхове. Например последователността "1", "19", 
"7" и "21" е път. "1", "19" и "23" не е път, защото "19" и "23" не са свързани 
помежду си с ребро. 

-Дължина на път е броят на ребрата, свързващи последователността от 
върхове в пътя. Практически този брой е равен на броят на върховете в 
пътя минус единица. Дължината на примера ни за път ("1", "19", "7" и "21") 
е три.

Дълбочина на връх ще наричаме дължината на пътя от корена до дадения 
връх. На примера ни "7" като корен е с дълбочина нула, "19" е с дълбочина 
едно, а "23" – с дълбочина две. 


Дърво (tree) – рекурсивна структура от данни, която се състои от върхове, 
които са свързани помежду си с ребра.


-Всеки връх може да има 0 или повече преки наследници (деца). 
 
-Всеки връх има най-много един баща. Съществува точно един спе
циален връх, който няма предшественици – коренът (ако дървото не 
е празно). 

-Всички върхове са достижими от корена, т.е съществува път от корена 
до всички тях. 


Можем да дефинираме дърво и по по-прост начин: всеки единичен връх 
наричаме дърво и той може да има нула или повече наследници, които също 
са дървета. 

Височина на дърво е максималната от дълбочините на всички върхове. В 
горния пример височината е 2.

 Степен на връх ще наричаме броят на преките наследници (деца) на 
дадения връх. Степента на "19" и "7" е три, докато тази на "14" е две. 
Листата са от нулева степен.

Разклоненост на дърво се нарича максималната от степените на всички 
върхове в дървото. В нашият пример степента на върховете е най-много 3, 
следователно разклонеността на дървото ни е 3.



 -----------------------------  Реализация на дърво – пример -----------------------------  

Ще реализираме дърво, което съдържа числа 
във върховете си и всеки връх може да има 0 или повече наследници, които 
също са дървета (следвайки рекурсивната дефиниция). Всеки връх от 
дървото е рекурсивно-дефиниран чрез себе си. Един връх от дървото 
(TreeNode<T>) съдържа в себе си списък от наследници, които също са 
върхове от дървото (TreeNode<T>). Нека разгледаме сорс кода: 

- примера е записан в Проекта
Chapter17TreesAndGraphExample1WhatIsTree

 -----------------------------   Как работи нашата имплементация на дърво?  -----------------------------  
Нека кажем няколко думи за предложения код. В примера имаме клас 
Tree<Т>, който е имплементация на самото дървото. В него е дефиниран 
вътрешен клас – TreeNode<T>, който представлява един връх от дървото. 

Функционалността, свързана с връх като например създаване на връх, 
добавяне на наследник на връх, взимане на броя на наследниците и т.н. се 
реализират на ниво TreeNode<T>. 

Останалата функционалност (например обхождане на дървото) се 
реализира на ниво Tree<Т>. Така функционалността става логически 
разделена между двата класа, което прави имплементацията по гъвкава. 

Причината да разделим на два класа имплементацията е, че някои опера
ции се отнасят за конкретен връх (например добавяне на наследник), 
докато други се отнасят за цялото дърво (например търсене на връх по 
неговата стойност). При такова разделяне дървото е клас, който знае кой 
му е коренът, а всеки връх знае наследниците си. При такава имплемен
тация е възможно да имаме и празно дърво (при root=null).

Ето и някои подробности от реализацията на TreeNode<T>. Всеки един връх 
(node) на дървото представлява съвкупност от частно поле value, което 
съдържа стойността му, и списък от наследници children. Списъкът на 
наследниците е от елементи на същия тип. Така всеки връх съдържа списък 
от референции към неговите преки наследници. Предоставени са също get 
и set методи за достъп до стойността на върха. Операциите, които могат да 
се извършват от външен за класа код върху децата, са:

-addChild(TreeNode<T> child) - добавя нов наследник. 

-TreeNode<T> getChild(int index) - връща наследник по зададен 
индекс. 

-getChildrenCount() - връща броя на наследници на даден връх.

За да спазим изискването всеки връх в дървото да има точно един родител, 
сме дефинирали частното поле hasParent, което показва дали даденият 
връх има родител. Тази информация се използва вътрешно в нашия клас и 
ни трябва в метода addChild(Tree<E> child). В него правим проверка дали 
кандидат детето няма вече родител. Ако има, се хвърля изключение, 
показващ, че това е недопустимо. 

В класа Tree<Т> сме предоставили два get метода TreeNode<T> getRoot() и 
ArrayList<TreeNode<T>> getChildNodes(), които връщат съответно корена на 
дървото и неговите преки наследници (деца). 

 -----------------------------   Рекурсивно обхождане на дърво в дълбочина  -----------------------------  

В класа Tree<Т> e реализиран е и методът TraverseDFS(), който извиква 
частният метод DFS(TreeNode<E> root, String spaces), който обхожда 
дървото в дълбочина и извежда на стандартният изход елементите му, така 
че нагледно да се изобрази дървовидната структура чрез отместване 
надясно (с добавяне на интервали). 

Алгоритъмът за обхождане в дълбочина (Depth-First-Search или DFS) 
започва от даден връх и се стреми да се спусне колкото се може по-надолу 
в дървовидната йерархия и когато стигне до връх, от който няма 
продължение се връща назад към предходния връх. Алгоритъмът можем да 
опишем схематично по следния начин: 

1. Обхождаме текущия връх. 
2. Последователно обхождаме рекурсивно всяко едно от поддърветата 
на текущия връх (обръщаме се рекурсивно към същия метод после
дователно за всеки един от неговите преки наследници). 

 -----------------------------   Създаване на дърво  -----------------------------  

За да създаваме по-лесно дървета сме дефинирали специален конструктор, 
който приема стойност на връх и списък от поддървета за този връх. Така 
позволяваме подаването на произволен брой аргументи от тип Tree<E> 
(поддървета). При създаването на дървото за нашия пример използваме 
точно този конструктор и той ни позволява да онагледим структурата му. 

 -----------------------------   Обхождане на директориите по твърдия диск  -----------------------------  

 -----------------------------   Рекурсивно обхождане на директориите в дълбочина  -----------------------------   

Следващият пример показва как да обходим рекурсивно (в дълбочина, по 
алгоритъмa Depth-First-Search) дървовидната структура на дадена папка и 
да изведем на стандартния изход и нейното съдържание:

-----примера се намира в проекта--------
Chapter17TreesAndGraphEx2

Както се вижда от примера, рекурсивното обхождане на съдържанието на 
директория по нищо не се различава от обхождането на нашето дърво.

 Всъщност, ако една дирек
тория е празна, тогава тя също се явява листо, защото няма наследници.

C:\ 
  C:\Config.Msi 
  C:\Documents and Settings 
    C:\Documents and Settings\Administrator 
      C:\Documents and Settings\Administrator\.ARIS70 
      C:\Documents and Settings\Administrator\.jindent 
      C:\Documents and Settings\Administrator\.nbi 
        C:\Documents and Settings\Administrator\.nbi\downloads 
        C:\Documents and Settings\Administrator\.nbi\log 
        C:\Documents and Settings\Administrator\.nbi\cache 
        C:\Documents and Settings\Administrator\.nbi\tmp 
        C:\Documents and Settings\Administrator\.nbi\wd 
      C:\Documents and Settings\Administrator\.netbeans 
        C:\Documents and Settings\Administrator\.netbeans\6.0 
 -----------------------------   Обхождане на директориите в ширина  -----------------------------  

Нека сега разгледаме още един начин да обхождаме дървета. Обхожда
нето в ширина (Breath-First-Search или BFS) е алгоритъм за обхождане 
на дървовидни структури от данни, при който първо се посещава началният 
връх, след това неговите преки съседи, след тях преките съседи на 
съседите и т.н. Този процес метод на вълната, защото прилича на 
вълните, образувани от камък, хвърлен в езеро.

Алгоритъмът за обхождане на дърво в ширина по метода на вълната можем 
да опишем схематично по следния начин: 
1. Записваме в опашката Q началния връх. 
2. Докато Q не е празна повтаряме следните две стъпки:
 - Изваждаме от Q поредния връх v и го отпечатваме.
 - Добавяме всички наследници на v в опашката
 
 Алгоритъмът BFS е изключително прост и има свойството да обхожда първо 
най-близките до началния връх върхове, след тях по-далечните и т.н. и 
най-накрая – най-далечните върхове. С времето ще се убедите, че BFS 
алгоритъмът има широко приложение при решаването на много задачи, 
като например при търсене на най-кратък път в лабиринт. 
Нека сега приложим BFS алгоритъма за отпечатване на всички директории 
от файловата система: 

Ако стартираме програмата, ще се убедим, че обхождането в ширина първо 
открива най-близките директории до корена (дълбочина 1), след тях 
всички директории на дълбочина 2, след това директориите на дълбочина 
3 и т.н. Ето примерен изход от програмата:

C:\ 
C:\Config.Msi 
C:\Documents and Settings 
C:\Inetpub 
C:\Program Files 
C:\RECYCLER 
C:\System Volume Information 
C:\WINDOWS 
C:\wmpub 
C:\Documents and Settings\Administrator 
C:\Documents and Settings\All Users 
C:\Documents and Settings\Default User 

 -----------------------------   Двоични дървета  -----------------------------  
Сега ще преминем към един неин полезен частен случай, който се оказва 
изключително важен за практиката – двоично дърво.

Двоично дърво (binary tree) – дърво, в което всеки връх е от степен не 
надвишаваща две т.е. дърво с разклоненост две. Тъй като преките 
наследници (деца) на всеки връх са най-много два, то е прието да се
въвежда наредба между тях, като единият се нарича ляв наследник, а 
другият – десен наследник. Те от своя страна са корени съответно на 
лявото поддърво и на дясното поддърво на техния родител. 

 -----------------------------   Двоично дърво – пример   -----------------------------  

			14
		  /   \
		 /	   \
		/		\
	  19- ляво	15 - дясно поддърво
	/   \		/
   23    6     3
	    / \
	   10  21
	   
	   Следва да отбележим обаче, че двоичните дървета имат едно много 
сериозно различие в дефиницията си, за разлика от тази на обикновеното 
дърво – наредеността на наследниците на всеки връх. Следващият пример 
ясно показва това различие: 

 На схемата са изобразени две абсолютно различни двоични дървета – в 
единия случай коренът е "19" и има ляв наследник "23", а в другия имаме 
двоично дърво с корен отново "19", но с "23" за десен наследник. Ако
разгледаме обаче двете структури като обикновени дървета, те ще са 
абсолютно еднакви и неразличими. Затова такова дърво бихме изобразили 
по следния начин:

	19
	|
	23
	
	 Запомнете! Въпреки, че разглеждаме двоичните дървета 
като подмножество на структурата дърво, трябва да се 
отбележи, че условието за нареденост на наследниците ги 
прави до голяма степен различни като структури. 

 -----------------------------   Обхождане на двоично дърво  -----------------------------  

-ЛДК (Ляво-Корен-Дясно/Pre-order) – обхождането става като 
първо се обходи лявото поддърво, след това коренът и накрая дясното 
поддърво. В нашият пример последователността, която се получава 
при обхождането е: "23", "19", "10", "6", "21", "14", "3", "15". 

-КЛД (Корен-Ляво-Дясно/In-order) – в този случай първо се 
обхожда коренът на дървото, после лявото поддърво и накрая 
дясното. Ето и как изглежда резултатът от този вид обхождане: "14", 
"19", "23", "6", "10", "21", "15", "3". 

-ЛДК (Ляво-Дясно-Корен/Post-order) – тук по аналогичен на 
горните два примера начин, обхождаме първо лявото поддърво, после 
дясното и накрая коренът. Резултатът след обхождането е "23", "10", 
"21", "6", "19", "3", "15", "14".
	
 -----------------------------   Обхождане на двоично дърво с рекурсия – пример  -----------------------------  
----примера е 
----Ch17Ex4BinaryTreeTraversal


 -----------------------------   Как работи примерът?  -----------------------------  
Тази примерна имплементация на двоично дърво не се различава 
съществено от реализацията, която показахме в случая на обикновено 
дърво. Отново имаме отделни класове за представяне на двоично дърво и 
на връх в такова – BinaryTree<T> и BinaryTreeNode<T>. Във вътрешния клас 
BinaryTreeNode<T> имаме частни полета value и hasParent. Както и преди 
първото съдържа стойността на върха, а второто показва дали върха има 
родител. При добавяне на ляв или десен наследник (ляво/дясно дете) на 
даден връх, се прави проверка дали имат вече родител и ако имат, се 
хвърля изключение, аналогично на реализацията ни на дърво. 

За разлика от реализацията на обикновеното дърво, сега вместо списък на 
децата, всеки връх съдържа по едно частно поле за ляв и десен наследник. 
За всеки от тях сме дефинирали публични get и set методи, за да могат да 
се достъпват от външен за класа код. 

В BinaryTree<T> са реализирани три get метода, които връщат съответно 
корена на дървото, левия му наследник и десния му наследник. Методът 
traversePreOrder() извиква вътрешно метода preOrder(BinaryTreeNode< T> 
root). Вторият метод от своя страна обхожда подаденото му дърво по 
схемата ляво-корен-дясно (ЛКД). Това става по следния тристъпков 
алгоритъм:

-1. Рекурсивно извикване на метода за обхождане за лявото поддърво на 
дадения връх. 

-2. Обхождане на самия връх. 

-3. Рекурсивно извикване на метода за обхождане на дясното поддърво. 

Силно препоръчваме на читателя да се опита (като едно добро упражнение) 
да модифицира предложения алгоритъм и код самостоятелно, така че да 
реализира другите два основни типа обхождане.

 -----------------------------   str 584  -----------------------------  
 -----------------------------   Наредени двоични дървета за претърсване  -----------------------------  
----------- от тук нататък не съм записвал в нищо



 -----------------------------   Глава 19. Структури от данни – съпоставка и препоръки  -----------------------------  

Ще дадем 
конкретни препоръки в какви ситуации какви структури от данни да 
ползваме. Ще обясним кога да предпочетем хеш-таблица, кога масив, кога 
динамичен масив, кога множество, реализирано чрез хеш-таблица и кога 
балансирано дърво. Всички тези структури имат вградена в Java платфор
мата имплементация. От нас се иска единствено да можем да преценяваме 
кога коя структура да ползваме, за да пишем ефективен и надежден 
програмен код. Именно на това е посветена настоящата тема – на ефек
тивната работа със структури от данни. 

 -----------------------------   Защо са толкова важни структурите данни?   -----------------------------  
Може би се чудите защо отделяме толкова голямо внимание на структурите 
данни и защо ги разглеждаме в такива големи детайли? Причината е, че 
сме си поставили за задача да ви направим мислещи софтуерни инженери. 
Без да познавате добре основните структури от данни в програмирането и 
основните компютърни алгоритми, вие не можете да бъдете добри 
програмисти и рискувате да си останете обикновени "занаятчии". Който 
владее добре структурите от данни и алгоритми и успее да си развие 
мисленето в посока правилното им използване, има големи шансове да 
стане добър софтуерен инженер – който анализира проблемите в дълбо
чина и предлага ефективни решения. 

По темата защо са важни структурите от данни и алгоритмите има изписани 
стотици книги. Особено впечатляващи са четирите тома на Доналд Кнут, 
озаглавени "The Art of Computer Programming", в които структурите от
данни и алгоритмите са разгледани в над 2500 страници. Един автор дори 
е озаглавил книга с отговора на въпроса "защо структурите от данни са 
толкова важни". Това е книгата на Никлаус Вирт "Алгоритми + структури от 
данни = програми", в която се разглеждат отново структурите данни и 
фундаменталните алгоритми в програмирането.

 -----------------------------  --- Правило  -----------------------------  ---
Структурите от данни и алгоритмите стоят в основата на 
програмирането. За да станете добри програмисти, е 
необходимо да познавате основните структури от данни и 
алгоритми и да се научите да ги прилагате по подходящ 
начин. 

 -----------------------------  --- Правило  -----------------------------  ---

 -----------------------------   Сложност на алгоритъм  -----------------------------  

Сложност на алгоритъм е метрика, която отразява порядъка на броя 
операции, необходими за изпълнение на дадена операция или алгоритъм 
като функция на обема на входните данни. Формулирано още по-просто, 
сложност е груба, приблизителна оценка на броя стъпки за изпълнение на 
даден алгоритъм. Означава се най-често с нотацията О(f), където f е 
функция на обема на входните данни. 

Сложността може да бъде константна, логаритмична, линейна, n*log(n), 
квадратична, кубична, експоненциална и друга. Това означава, че се 
изпълняват съответно константен, логаритмичен и т.н. брой стъпки за 
решаването на даден проблем.


 -----------------------------  --- Правило  -----------------------------  ---

Сложност на алгоритъм е груба оценка на броя стъпки, 
които алгоритъмът ще направи в зависимост от обема на 
входните данни.
 -----------------------------  --- Правило  -----------------------------  ---

Типични сложности на алгоритмите

Сложност      Означение 		Описание 
константна		 O(1)	 	За извършване на дадена операция са 
							необходими константен брой стъпки 
							(примерно 1, 5, 10 или друго число) и 
							този брой не зависи от обема на 
							входните данни. 
логаритмична 	O(log(N))	 За извършване на дадена операция 
							върху N елемента са необходими брой 
							стъпки от порядъка на log(N), където 
							основата на логаритъма е най-често 2. 
							Примерно алгоритъм със сложност 
							O(log(N)) за N = 1 000 000 ще направи 
							около 20 стъпки (с точност до 
							константа). 
линейна 		O(N) 		За извършване на дадена операция 
							върху N елемента са необходими 
							приблизително толкова стъпки, колкото 
							са елементите. Примерно за 1 000 
							елемента са нужни около 1 000 стъпки. 
							Броят елементи и броят операции са 
							линейно зависими, примерно броят 
							стъпки е около N/2 или 3*N за N 
							елемента. 
			O(n*log(n)) 	За извършване на дадена операция 
							върху N елемента са необходими 
							приблизително N*log(N) стъпки. 
							Примерно при 1 000 елемента са нужни 
							около 10 000 стъпки. 
квадратична	 O(n2) 			За извършване на дадена операция са 
							необходими N2 на брой стъпки, където N 
							характеризира обема на входните 
							данни. Примерно за дадена операция 
							върху 100 елемента са необходими 10 
							000 стъпки. Ако броят стъпки е в 
							квадратна зависимост спрямо обема на 
							входните данни, то сложността е 
							квадратична. 
кубична   O(n3)				 За извърхване на дадена операция са 
							необходими от порадъка на N3 стъпки, 
							където N характеризира обема на 
							входните данни. Примерно при 100 
							елемента се изпълняват около 1 000 000 
							стъпки. 
експоненциална O(2n), 
				O(N!), 
				O(nk), … 
							За извърпване на дадена операция или 
							изчисление са необходими брой стъпки, 
							който е в експоненциалназависимост 
							спрямо размера на входните данни. 
							Например при N=10 експоненциалната 
							функция 2N има стойност 1024, при 
							N=20 има стойност 1 048 576, а при 
							N=100 функцията има стойност, която е 
							число с около 30 цифри.		

	При оценката на сложност константите не се взимат предвид, тъй като не 
влияят съществено на броя операции. По тази причина алгоритъм, който 
извършва N стъпки и алгоритми, които извършват съответно N/2 и 3*N 
стъпки се считат за линейни и за приблизително еднакво ефективни. 		
							
 -----------------------------   Сложност и време за изпълнение  -----------------------------  ---

 -----------------------------  --- таблица с времето на алгоритмите стр 647  

От таблицата можем да направим много изводи: 
заспива заспива - Алгоритми с константна, логаритмична и линейна сложност са толкова 
бързи, че не можем да усетим забавяне, дори при относително голям 
вход. - Сложността O(n*log(n)) е близка до линейната и също работи толкова, 
бързо, че трудно можем да усетим забавяне. - Квадратични алгоритми работят добре до няколко хиляди елемента. - Кубични алгоритми работят добре при под 1 000 елемента. - Като цяло т.нар. полиномиални алгоритми (тези, които не са експо
ненциални) се считат за бързи и работят добре за хиляди елементи. - Експоненциалните алгоритми като цяло не работят и трябва да ги 
избягваме (ако е възможно). Ако имаме експоненциално решение за 
дадена задача, може да се каже, че нямаме решение, защото то ще 
работи само ако елементите са под 10-20. Съвременната криптогра
фия разчита точно на това, че не са известни бързи (неекспо
ненциални) алгоритми за откриване на тайните ключове, които се 
използват за шифриране на данните. 
 -----------------------------  --- Правило  -----------------------------  -------
Ако решите една задача с експоненциална сложност, това 
означава, че сте я решили само за много малък размер на 
входните данни и в общия случай решението ви не работи. 
 -----------------------------  --- Правило  -----------------------------  -------

 -----------------------------   Оценяване на сложност – примери  -----------------------------  

Ако имаме единичен цикъл от 1 до N, сложността му е линейна – O(N):
int findMaxElement(int[] array) { 
	int max = array[0]; 
	for (int i=0; i<array.length; i++) { 
		if (array[i] > max) 
		max = array[i]; 
	} 
	return max; 
} 
Този код ще работи добре, дори при голям брой елементи. 
Ако имаме два вложени цикъла от 1 до N, сложността им е квадратична – 
O(N2). Пример: 
int findInversions(int[] array) { 
	int inversions = 0; 
	for (int i=0; i<array.length; i++) 
		for (int j = i+1; j<array.length; j++) 
			if (array[i] > array[j]) 
			inversions++; 
	return inversions; 
} 

Ако имаме три вложени цикъла от 1 до N, сложността им е кубична – O(N3). 

Ако имаме два вложени цикъла съответно от 1 до N и от 1 до M, сложността 
им е квадратична – O(N*М). 

 -----------------------------   Кога да използваме дадена структура?  -----------------------------  


 -----------------------------  - Масив (Array)  -----------------------------  -
Масивите трябва да се ползват само когато трябва да обработим фиксиран 
брой елементи, до които е необходим достъп по индекс. Например, ако 
сортираме числа, можем да запишем числата в масив и да приложим някой 
от добре известните алгоритми за сортиране.

 -----------------------------   Правило  -----------------------------  -------
Ползвайте масиви, когато трябва да обработите фиксиран 
брой елементи, до които ви трябва достъп по индекс.
 -----------------------------   Правило  -----------------------------  -------

 -----------------------------  Свързан / двусвързан списък (LinkedList) -----------------------------  
 
Свързаният списък може бързо (с константна сложност) да добавя и 
изтрива елементи от двата си края, поради което е удобен за имплемен
тация на стекове, опашки и други подобни структури. 

Свързан списък в практиката се използва много рядко, защото динамичният 
масив (ArrayList) изпълнява почти всички операции, които могат да бъдат 
изпълнени с LinkedList, но за повечето от тях работи по-бързо. 

Ползвайте ArrayList, когато ви трябва свързан списък – той работи не по
бавно, а ви дава по-голяма бързина и удобство. Ползвайте LinkedList, ако 
имате нужда от добавяне и изтриване на елементи в двата края на 
структурата.

 -----------------------------   Правило  -----------------------------  -------
Ползвайте свързан списък, когато трябва да добавяте и 
изтривате елементи от двата края на списъка.
  -----------------------------   Правило  -----------------------------  -------

 -----------------------------   Динамичен масив (ArrayList)  -----------------------------  

Динамичният масив (ArrayList) е една от най-използваните в практиката 
структура от данни. Той няма фиксиран размер, както масивите и има 
директен достъп по индекс, за разлика от свързания списък. 

В крайна сметка ArrayList комбинира добрите страни на масивите и на 
списъците, заради което е предпочитана структура данни в много ситуации. 
Например, ако трябва да обработим текстов файл и да извлечем от него 
всички думи, отговарящи на даден регулярен израз, най-удобната 
структура, в която можем да ги натрупваме, е ArrayList. 

Динамичният масив (ArrayList) е подходящ, когато трябва често да 
добавяме елементи и искаме да запазваме реда им на добавяне и да ги 
достъпваме често по индекс. Ако често търсим или изтриваме елемент, 
ArrayList не е подходяща структура.

  -----------------------------   Правило  -----------------------------  -------

Ползвайте ArrayList, когато трябва бързо да добавяте 
елементи и да ги достъпвате по индекс.
  -----------------------------   Правило  -----------------------------  -------

	
 -----------------------------   Стек (Stack) -----------------------------  

Стекът е структура с поведение LIFO (last in, first out) – последен влязъл, 
пръв излязъл. Използва се, когато трябва да моделираме такова поведение, 
например, ако трябва да пазим пътя до текущата позиция при рекурсивно 
търсене. 

  -----------------------------   Правило  -----------------------------  

Ползвайте стек, когато е необходимо да реализирате 
поведението "последен влязъл, пръв излязъл" (LIFO). 

  -----------------------------   Правило  -----------------------------  

 -----------------------------   Опашка (Queue)  -----------------------------  
 -----------------------------   Правило  -----------------------------  

Ползвайте опашка, когато е необходимо да реализирате 
поведението "пръв влязъл, пръв излязъл" (FIFO). 
 -----------------------------   Правило  -----------------------------  

 -----------------------------   Речник, реализиран с хеш-таблица (HashMap) 

 -----------------------------   Правило  -----------------------------  -------
Ползвайте хеш-таблица, когато искате бързо да добавяте 
елементи и да търсите по ключ. 

Основното предимство на хеш-таблицата пред останалите 
структури от данни е изключително бързото търсене и 
добавяне на елементи, а не толкова удобството на работа! 
  -----------------------------   Правило  -----------------------------  -------
 
 
 ------- има и други но в книгата
 
 Речник, реализиран с дърво (TreeMap)
 
Ползвайте TreeMap, когато искате бързо да добавяте еле
менти и да търсите по ключ и елементите ще ви трябват 
сортирани по ключ. 

Множество, реализирано с хеш-таблица (HashSet)
Ползвайте HashSet, когато трябва бързо да добавяте еле
менти към множество и да проверявате дали даден еле
мент е от множеството. 

Множество, реализирано с дърво (TreeSet)
Ползвайте TreeSet, когато трябва бързо да добавяте еле
менти към множество и да проверявате дали даден еле
мент е от множеството и освен това елементите ще ви 
трябват сортирани в нарастващ ред. 

 -----------------------------  стр 658  -----------------------------  
 -----------------------------   Глава 20 Принципи на обектно-ориентираното програмиране  -----------------------------  



В Java  един клас може да наследи само един друг 
клас (single inheritance).

наследяване става с extends

Класът, който наследяваме, се нарича клас-родител или още базов клас 
(base class, super class). 

В горния пример в конструктора на Lion използваме ключовата дума super. 
Тя указва да бъде използван базовият клас и позволява достъп до негови 
методи, конструктори и член-променливи. Със super() можем да извикваме 
конструктор на базовия клас. Със super.method() можем да извикваме метод 
на базовия клас, да му подаваме параметри и да използваме резултата от 
него. Със super.field можем да вземем стойността на член-променлива на 
базовия клас или да й присвоим друга стойност.


 -----------------------------   override  -----------------------------  
В Java наследените от базовия клас методи могат да се пренаписват 
(override). Това означава да им се подмени имплементацията, като ориги
налният сорс код от базовия клас се игнорира, а на негово място се написва 
друг код. 
 -----------------------------   override  -----------------------------  


Можем да извикваме непренаписан метод от базовия клас и без super. 
Употребата на ключовата дума е необходима само ако имаме пренаписан 
метод или променлива със същото име в наследения клас. 

super може да се използва изрично, за яснота. super. 
method()  извиква метод, който задължително е от базовия 
клас. Такъв код се чете по-лесно, защото знаем къде да 
търсим въпросния метод. 
Имайте предвид, че ситуацията с this не е такава. this 
може да означава както метод от конкретния клас, така и 
метод от който и да е базов клас.


 -----------------------------   Да си припомним: класове и обекти  -----------------------------  

Класовете са описание (модел) на реални предмети или явления, 
наречени същности (entities). Например класът "Студент".

Класовете имат характеристики – в програмирането са наречени свойства 
(properties). Например съвкупност от оценки. 

Класовете имат и поведение – в програмирането са наречени методи 
(methods). Например явяване на изпит.

Основни предимства и цели на ООП – да позволи по-бърза разработка 
на сложен софтуер и по-лесната му поддръжка. ООП позволява по лесен 
начин да се преизползва кода, като залага на прости и общоприети правила 
(принципи). Нека ги разгледаме. 

- Наследяване (Inheritance) 
Ще обясним за как йерархиите от класове подобряват четимостта на 
кода и позволяват преизползване на функционалност.
 - Абстракция (Abstraction) 
Ще се научим да виждаме един обект само от гледната точка, която 
ни интересува, и да игнорираме всички останали детайли.
 - Капсулация (Encapsulation) 
Ще се научим да скриваме ненужните детайли в нашите класове и да 
предоставяме прост и ясен интерфейс за работа с тях.
 - Полиморфизъм (Polymorphism)
Ще обясним как да работим по еднакъв начин с различни обекти, 
които дефинират специфична имплементация на някакво абстрактно 
поведение. 

 -----------------------------   Наследяване (Inheritance)  -----------------------------  

То позволява на един клас да "наследява" (поведение и характе
ристики) от друг, по-общ клас. Например лъвът е от семейство котки. 
Всички котки имат четири лапи, хищници са, преследват жертвите си. Тази 
функционалност може да се напише веднъж в клас Котка и всички хищници 
да я преизползват – тигър, пума, рис и т.н. 

-става с  extends.
- В Java  един клас може да наследи само един друг клас 
 (single inheritance).Ограничението е породено от това,
 че при наследяване на два класа с еднакъв метод е трудно
 да се реши кой от тях да се използва. 
 -В Java могат да се наследяват множество интерфейси.
 
Класът, който наследяваме, се нарича клас-родител или още
 базов клас (base class, super class).

 -----------------------------   Ключовата дума super  -----------------------------  
-Тя указва да бъде използван базовият клас и позволява достъп
 до негови методи, конструктори и член-променливи.
-Със super() можем да извикваме конструктор на базовия клас.
-Със super.method() можем да извикваме метод на базовия клас,
 да му подаваме параметри и да използваме резултата от него. 
-Със super.field можем да вземем стойността на член-променлива
 на базовия клас или да й присвоим друга стойност. 
 
-наследените от базовия клас методи могат да се пренаписват 
(override).Повече за пренаписването на методи ще обясним в секцията 
"Виртуални методи". 

-Можем да извикваме непренаписан метод от базовия клас и без super. 
Употребата на ключовата дума е необходима само ако имаме пренаписан 
метод или променлива със същото име в наследения клас. 

 -----------------------------   Правило  -----------------------------  
super може да се използва изрично, за яснота. super. 
method()  извиква метод, който задължително е от базовия 
клас. Такъв код се чете по-лесно, защото знаем къде да 
търсим въпросния метод. 
Имайте предвид, че ситуацията с this не е такава. this 
може да означава както метод от конкретния клас, така и 
метод от който и да е базов клас.
 -----------------------------   Правило  -----------------------------  


 -----------------------------  Конструкторите при наследяване  -----------------------------  

При наследяване на един клас, нашите конструктори задължително трябва 
да извикат конструктор на базовия клас, за да може и той да инициализира 
член-променливите си. Ако не го направим изрично, в началото на всеки 
наш конструктор компилаторът поставя извикване на базовия конструктор 
без параметри: super(). Ако базовият клас няма конструктор по 
подразбиране (без параметри). Нашите конструктори трябва да извикат 
изрично някои от другите конструктори на базовия клас. Липсата на 
изрично извикване предизвиква грешка при компилация. 

public class AfricanLion extends Lion {
    public AfricanLion(boolean male, int weight) {
        // If we comment the next line, AfricanLion
        // will not compile. Try it.
        super(male, weight);
    }

    public String toString() {
			return String.format(
            "(AfricanLion, male: %s, weight: %s)",
            this.isMale(), this.getWeight() );
    }

} 

 -----------------------------   Правило  -----------------------------  -------
Извикването на конструктор на базов клас трябва винаги 
да е на първия ред от нашия конструктор. Иначе компи
латорът дава грешка. Идеята е полетата на базовия клас 
да бъдат инициализирани преди да започнем да инициа
лизираме полета в класа-наследник, защото може те да 
разчитат на някое поле от базовия клас. 
 -----------------------------   Правило  -----------------------------  -------

 -----------------------------   Нива на достъп при наследяване  -----------------------------  
 public, private и default (friendly) ,protected
 
 
- protected свързано е с наследяването.

- Всички негови public и protected методи и свойства са видими за 
класа наследник.
 - Всички негови private методи и свойства не са видими за класа 
наследник. 
- Всички негови default (friendly) методи и свойства са видими за класа 
наследник само ако базовият клас и наследникът са в един и същ 
пакет (package).


 -----------------------------   Класът Object  -----------------------------  

Архитектите на Java поемат в друга посока. Те създават клас, който всички 
други класове пряко или косвено да наследяват и до който всеки обект 
може да бъде преобразуван. В този клас е удобно да бъдат сложени важни 
методи и тяхната имплементация по подразбиране. Този клас се нарича 
Object. 

В Java всеки клас, който не наследява друг клас изрично, наследява 
системния клас java.lang.Object по подразбиране. За това се грижи
компилаторът. Всеки клас, който наследява друг клас, наследява инди
ректно Object от него. Така всеки клас явно или неявно наследява Object и 
има в себе си всички негови методи и полета. 
Благодарение на това свойство всеки обект може да бъде преобразуван до 
Object. Типичен пример за ползата от неявното наследяване на Object е при 
колекциите, които разгледахме в главите за структури от данни. 
Списъчните структури (например ArrayList) могат да работят с всякакви 
обекти, защото ги разглеждат като инстанции на класа Object. 

 -----------------------------   Java, стандартните библиотеки и Object -----------------------------  
 Тези класове са част от Java платформата
 – навсякъде, където има Java, ги има 
и тях. Тези класове се наричат стандартни клас-библиотеки – standard 
class libraries.

Java е първата платформа, която идва с такъв богат набор от предва
рително написани класове. Голяма част от тях работят с Object, за да могат 
да бъдат използвани на възможно най-много места. 

В Java има и доста библиотеки, които могат да се добавят допълнително и 
съвсем логично се наричат просто клас-библиотеки или още външни 
библиотеки.

 -----------------------------  Object – пример -----------------------------  

public class ObjectExample { 
	public static void main(String... args) { 
		AfricanLion africanLion = new AfricanLion(); 
		// Implicit casting 
		Object object = africanLion; 
	} 
} 

 Тази операция се нарича upcasting и е позволена, 
 защото AfricanLion е непряк наследник на класа Object.


 -----------------------------  Методът Object.toString() -----------------------------  
Един от най-използваните методи, идващи от класа Object, е toString(). 
Той връща текстово представяне на обекта. Всеки обект има такъв метод
 и следователно всеки метод има текстово представяне. Този метод се 
използва, когато отпечатваме обект чрез System.out.println().

– пример

public class ToStringExample { 
 public static void main(String... args) { 
  AfricanLion africanLion = new AfricanLion(); 
  System.out.println(africanLion.toString()); 
   
  // Result: "introjavabook.AfricanLion@de6ced" 
 } 
} 

Тъй като AfricanLion не пренаписва (override) метода toString(), в 
конкретния случай се извиква имплементацията от базовия клас. Lion и 
Felidae също не пренаписват този метод, следователно се извиква импле
ментацията, наследена от класа java.lang.Object. В резултата, който 
виждаме по-горе, се съдържа пакетът на обекта, името на класа, както и 
странна стойност след @ знака. Това всъщност е хеш кодът на обект в 
шестнайсетична бройна система. Това не е адресът в паметта, а някаква 
друга стойност. Обикновено тази стойност е различна за различните 
оебкти. 


Eто я и оригиналната имплементация на метода Object.toString(), 
извадена от сорс кода на стандартните библиотеки в Java: 

Public class Object { 
 // ... 
 public String toString() { 
  return getClass().getName() + 
   "@" + Integer.toHexString(hashCode()); 
 } 
 // ... 
} 
 -----------------------------  -------------------Пренаписване на toString() – пример  -----------------------------  

public class AfricanLion extends Lion {  
 
 // ... 
 
 public AfricanLion(boolean male, int weight) { 
  super(male, weight); 
 } 
 
 public String toString() { 
  return String.format( 
   "(AfricanLion, male: %s, weight: %s)", 
   this.isMale(), this.getWeight()); 
 } 
 
 // ... 
} 
Ето как можем 
след това да извикваме пренаписания метод toString():

public class ToStringExample { 
 
 public static void main(String... args) { 
 
  AfricanLion africanLion = new AfricanLion(true, 15); 
  System.out.println(africanLion); 
 
  // Result: "[AfricanLion, male: true, weight: 15]" 
 } 
} 

Забележете, че извикването на toString() става скрито. Когато на метода  
println() подадем някакъв обект, този обект първо се преобразува до 
стринг чрез toString() метода му и след това се отпечатва в изходния 
поток. Така при печатане на конзолата няма нужда изрично да преобразу
ваме обектите до стринг.

 -----------------------------  -------------------- str 686

-@Override -ползваме тази анотация ако искаме нашия метод да 
пренапише друг от базов клас. Валидно е от java 5.
  Ако случайно сбъркаме една буква от името на метода или 
типовете на неговите параметри, компилаторът веднага ще ни съобщи за 
грешката.

Йерархия на наследяване 
Ако тръгнем да описваме всички големи котки, рано или късно се стига до 
сравнително голяма група класове, които се наследяват един друг. Всички 
тези класове, заедно с базовите такива, образуват йерархия от класове на 
големите котки. Такива йерархии могат да се опишат най-лесно чрез клас
диаграми. Нека разгледаме какво е това "клас-диаграма".

 -----------------------------  Клас-диаграми -----------------------------  

Клас-диаграмата е един от няколко вида диаграми дефинирани в UML. 
UML (Unified Modeling Language) е нотация за визуализация на различни 
процеси и обекти, свързани с разработката на софтуер.

В клас-диаграмите има възприети правила класовете да се рисуват като 
правоъгълници с име, атрибути (член-променливи) и операции (методи), а 
връзките между тях се обозначават с различни видове стрелки.

Накратко ще обясним два термина от UML, за по ясно разбиране на при
мерите. Единият е генерализация (generalization). Генерализация е
обобщаващо понятие за наследяване на клас или имплементация на 
интерфейс (за интерфейси ще обясним след малко). Другият термин се 
нарича асоциация (association). Например "Лъвът има лапи", където Лапа 
е друг клас. Генерализация и асоциация са двата най-основни начина за 
преизползване на код. 

 -----------------------------  Един клас от клас диаграма – пример -----------------------------  

В най-горната част е дефинирано името на класа.
 В следващата част след него са атрибутите (термин от UML)
 на класа (в Java се наричат член-променливи и свойства).
 Най-отдолу са операциите (в UML) или методите (в Java).
Плюсът/минусът в началото указват дали атрибутът/операцията 
са видими (+ означава public) или невидими (- означава private).
 Protected членовете се означават със символа #.
 
 -стрелките означават генерализация или наследяване. Наследяващия 
 клас сочи към наследявания.
 
 -----------------------------   Асоциации  -----------------------------  
Асоциациите представляват връзки между класовете. Те моделират взаи
моотношения. Могат да дефинират множественост (1 към 1, 1 към много, 
много към 1, 1 към 2, ..., и много към много).

стр 690 - как се означават асоциациите.

 От клас-диаграмите най-често се създават класове. Диаграмите улесняват 
и ускоряват дизайна на класовете на един софтуерен проект. 

От горната диаграма можем директно да създадем класове. Ето класът 
Country: 

 -----------------------------   Агрегация  -----------------------------  

Агрегацията е специален вид асоциация. Тя моделира връзката "цяло / 
част". Агрегат наричаме родителския клас. Компоненти наричаме агре
гираните класове. В единия край на агрегацията има празен ромб:



 -----------------------------   Композиция  -----------------------------   
Запълнен ромб означава композиция. Композицията е агрегация, при която 
компонентите не могат да съществуват без агрегата (родителя): 

 -----------------------------   Абстракция (Abstraction)  -----------------------------  

Абстракцията означава да работим с нещо, което знаем
 как да използваме, но не знаем как работи вътрешно.

Абстракцията е нещо, което правим всеки ден. Това е действие, при което 
игнорираме всички детайли, които не ни интересуват от даден обект и 
разглеждаме само детайлите, които имат значение за проблема, който 
решаваме.

Абстракцията е една от най-важните концепции в програмирането и в ООП. 
Тя ни позволява да пишем код, който работи с абстрактни структури от 
данни (например списък, речник, множество и други). Имайки абстрактния 
тип данни ние можем да работим с него през неговия интерфейс, без да се 
интересуваме от имплементацията му. Например можем да запазим във 
файл всички елементи на списък, без да се интересуваме дали той е 
реализиран с масив, чрез свързана имплементация или по друг начин. Този 
код остава непроменен, когато работим с различни конкретни типове 
данни. Дори можем да пишем нови типове данни (които се появяват на по
късен етап) и те да работят с нашата програма, без да я променяме.

Абстракцията ни позволява и нещо много важно – да дефинираме 
интерфейс на нашите програми, т.е. да дефинираме всички задачи, 
които тази програма може да извърши, както и съответните входни и 
изходни данни. Така можем да направим няколко по-малки програми, всяка 
от които да извършва някаква по-малка задача. Това, допълнено от факта, 
че можем да работим с абстрактни данни, ни дава голяма гъвкавост при 
свързването на тези по-малки програми в една по-голяма и ни дава повече 
възможности за преизползване на код. Тези малки подпрограми се наричат 
компоненти. Този начин на писане на програми намира широко приложение 
в практиката, защото ни позволява не само да преизползваме обекти, а 
дори цели подпрограми. 


 -----------------------------   Абстракция – пример за абстрактни данни ------------
 
 Lion lion = new Lion(true, 150); 
Felidae bigCat1 = lion; 
AfricanLion africanLion = new AfricanLion(); 
Felidae bigCat2 = africanLion; 

 -----------------------------   Интерфейси  -----------------------------  

В езика Java интерфейсът е дефиниция на роля (на група абстрактни 
действия). Той дефинира какво поведение трябва да има един обект, без 
да указва как точно се реализира това поведение. 
Един обект може да има много роли (да имплементира много интерфейси) 
и ползвателите му могат да го използват от различни гледни точки. 
Например един обект Човек може да има ролите Военен (с поведение 
"стреляй по противника"), Съпруг (с поведение "обичай жена си"), 
Данъкоплатец (с поведение "плати си данъка"). Всеки човек обаче импле
ментира това поведение по различен начин: Иван си плаща данъците 
навреме, Георги – не навреме, Петър – въобще не ги плаща. 
Някой може да попита защо най-базовият за всички обекти клас Object не 
е всъщност интерфейс. Причината е, че тогава всеки клас щеше да трябва 
да имплементира група методи, а това би отнемало излишно време. Оказва 
се, че и не всеки клас има нужда от специфична реализация, тоест 
имплементацията по подразбиране върши работа в повечето случаи. От 
класа Object не е нужно да се пренапише (повторно имплементира) никой 
метод, но ако се наложи, това може да се направи.

 -----------------------------   Интерфейси – ключови понятия  -----------------------------  

В интерфейса може да има само декларации на методи и константи.

Декларация на метод (method declaration) е съвкупността от връщания 
тип на метода + сигнатурата на метода. Връщаният тип е просто за яснота 
какво ще върне метода.

Сигнатура на метод (method signature) е съвкупността от името на 
метода + описание на параметрите (тип и последователност). В един 
клас/интерфейс всички методи трябва да са с различни сигнатури и да не 
съвпадат със сигнатури на наследени методи. 

Имплементация на клас/метод (class/method implementation) е 
тялото със сорс код на класа/метода.

 -----------------------------   Интерфейси – пример   -----------------------------  

Интерфейсът в Java се дефинира с ключовата думичка interface. В него 
може да има само декларации на методи, както и статични променливи (за 
константи например).


public interface Reproducible { 
 Mammal[] reproduce(Mammal mate); 
} 

public class Lion extends Felidae implements Reproducible { 
 // ... 
 
 public Mammal[] reproduce(Mammal anotherLion) { 
  return new Mammal[]{new Lion(), new Lion()}; 
 } 
} 

В интерфейса методите само се декларират, имплементацията е в класа, 
който имплементира интерфейса - Lion. 

Класът, който имплементира даден интерфейс, трябва да имплементира 
всеки метод от него. Изключение – ако класът е абстрактен, тогава да 
имплементира нула, няколко или всички методи. Всички останали методи 
имплементират в някой от класовете наследници. 

 -----------------------------   Абстракция и интерфейси    -----------------------------  

Най-добрият начин да се реализира абстракция е да се работи с интер
фейси. Един компонент работи с интерфейси, които друг имплементира. 
Така подмяната на втория компонент няма да се отрази на първия, стига 
новият компонент да имплементира старите интерфейси. Интерфейсът се 
нарича още договор (contract). Всеки компонент, имплементирайки един 
интерфейс, спазва определен договор. Така два компонента, стига да 
спазват правилата на договора, могат да общуват един с друг, без да знаят 
как работи другата страна. 

Примери за важни интерфейси от Java collections framework са java. 
util.List и java.util.Collection. Всички стандартни колекции имплемен
тират тези интерфейси и различните компоненти си прехвърлят различни 
имплементации (масиви или свързани списъци, хеш-таблици, червено
черни дървета и др.) винаги под общ интерфейс. На фигурата по-горе е 
показано как изглежда част от йерархията на колекциите в Java. 
Колекциите са един отличен пример на обектно-ориентирана библиотека с 
класове и интерфейси, при която се използват много активно всички 
основни принципи на ООП: абстракция, наследяване, капсулация и поли
морфизъм. От картинката се вижда, че абстрактните типове данни са 
дефинирани като интерфейси (Collection, List, Set, Map и други), а 
конкретните им имплементации са техни преки или непреки наследници в 
йерархията (ArrayList, LinkedList, HashSet, HashMap, TreeMap и други).

 -----------------------------   Кога да използваме абстракция и интерфейси?     -----------------------------  

Отговорът на този въпрос е: винаги, когато искаме да постигнем абстракция 
на данни или действия, чиято имплементация по-късно може да се подмени. 
Написаният код срещу интерфейси е много по-издръжлив срещу промени, 
отколкото написаният срещу конкретни класове. Работата през интерфейси 
е често срещана и силно препоръчвана практика – едно от основните 
правила за писане на качествен код. 

 -----------------------------   Кога да пишем интерфейси?   -----------------------------  

Винаги е добра идея да се използват интерфейси, когато се предоставя 
функционалност на друг компонент. В интерфейса се слага само функцио
налността (като декларация), която другите трябва да виждат. 
Вътрешно в една програма/компонент интерфейсите могат да се използват 
за дефиниране на роли. Така един обект може да се използва от много 
класове чрез различните му роли. 

 -----------------------------   Капсулация (Encapsulation)   -----------------------------  

Един обект трябва да предоставя на ползвателя си само 
необходимите средства за управление. Една Секретарка ползваща един 
Лаптоп знае само за екран, клавиатура и мишка, а всичко останало е скрито. 
Тя няма нужда да знае за вътрешността на Лаптопа, защото не й е нужно и 
може да оплеска нещо. Тогава част от свойствата и методите остават скрити 
за нея.

Когато програмираме трябва да дефинираме като private (скрит) 
всеки метод или поле, които не ползваме от друг клас. 


 -----------------------------   Капсулация – примери    -----------------------------  

 public abstract class Felidae { // Latin for cat 
 // ... 
 
 public abstract void walk(); 
} 

 -----------------------------   -----------------------------  ----------------------
public class Lion extends Felidae implements Reproducable { 
 // ... 
 
 private movePaw(Paw paw) { 
  // ... 
 } 
 
 @Override 
 public void walk() { 
  this.movePaw(frontLeft); 
  this.movePaw(frontRight); 
  this.movePaw(bottomLeft); 
  this.movePaw(bottomRight); 
 } 
} 

Публичният метод walk() извиква 4 пъти някакъв друг скрит (private) 
метод. Така интерфейсът (в този случай абстрактният клас) е кратък – само 
един метод. Имплементацията обаче извиква друг метод, също част от 
имплементацията, но скрит за ползвателя на класа. Така класът Lion не 
разкрива публично информация за това как работи вътрешно и това му дава 
възможност на по-късен етап да промени имплементацията си без 
останалите класове да разберат (и да имат нужда от промяна). 


Друг пример за абстракция е класът ArrayList от стандартните библиотеки 
на Java. Ако отворим сорс кода на този клас, ще видим, че в него има
десетки полета и методи, които са дефинирани като private (скрити) и са 
достъпни само вътрешно от класа: 

Както виждаме, освен познатите ни публични методи в класа ArrayList има 
и скрити неща. Това са вътрешните структури, съхраняващи елементите на 
структурата (elementData и size) и някои тайни методи, които не би 
трябвало да се извикват извън класа. Скриването на тези детайли 
гарантира, че никой освен самия клас ArrayList няма да бута директно по 
данните и така няма да има възможност да сбърка нещо. Ако всички полета 
в ArrayList бяха дефинирани като публични, щеше да е много трудно да 
накараме потребителите да обновяват в синхрон променливите size и 
elementData. Понеже тези променливи са скрити, класът ArrayList се грижи 
вътрешно за тях и няма опасност някой да ги разбута. 


 -----------------------------   Полиморфизъм (Polymorphism)     -----------------------------  

Полиморфизмът позволява третирането на обекти от 
наследен клас като обекти от негов базов клас. Например големите котки 
(базов клас) хващат жертвите си (метод) по различен начин. Лъвът (клас 
наследник) ги дебне, докато Гепардът (друг клас-наследник) просто ги 
надбягва.

Полиморфизмът дава възможността да третираме произволна голяма котка 
просто като голяма котка и да кажем "хвани жертвата си", без значение 
каква точно е голямата котка. 
Полиморфизмът може много да напомня на абстракцията, но в програми
рането се свързва най-вече с пренаписването (override) на методи в нас
ледените класове с цел промяна на оригиналното им поведение, наследено 
от базовия клас. Абстракцията се свързва със създаването на интерфейс на 

компонент или функционалност (дефиниране на роля). Пренаписването на 
методи ще разгледаме в детайли след малко. 

 -----------------------------   Абстрактни класове    -----------------------------  

Какво става, ако искаме да кажем, че класът Felidae е непълен и само 
наследниците му могат да имат инстанции? Това става с ключовата дума 
abstract пред името на класа и означава, че класът не е готов и не може да 
бъде инстанциран. Такъв клас се нарича абстрактен клас. А как да укажем 
коя точно част от класа не е пълна? Това отново става с ключовата дума 
abstract пред името на метода, който трябва да бъде имплементиран. Този 
метод се нарича абстрактен метод и не може да притежава 
имплементация, а само декларация.

Всеки клас, който има поне един абстрактен метод, трябва да бъде 
абстрактен. Логично, нали? Обратното, обаче не е в сила. Възможно е да 
дефинирам клас като абстрактен дори когато в него няма нито един 
абстрактен метод. 

Абстрактните класове са нещо средно между клас и интерфейс. Те могат да 
дефинират обикновени методи и абстрактни методи. Обикновените методи 
имат тяло (имплементация), докато абстрактните методи са празни (без 
имплементация) и са оставени да бъдат реализирани от класовете
наследници. 

 -----------------------------   Чист абстрактен клас    -----------------------------  

Абстрактните класове, както и интерфейсите не могат да се инстанцират. 
Ако се опитате да създадете инстанция на абстрактен клас, ще получите 
грешка по време на компилация. Понякога даден клас може да бъде 
деклариран като абстрактен дори и да няма нито един абстрактен 
метод, просто, за да се забрани директното му използване, без да се 
създава инстанция на негов наследник.

Чист абстрактен клас (pure abstract class) е абстрактен клас, който 
няма нито един имплементиран метод, както и нито една член променлива. 
Много напомня на интерфейс. Основната разлика е, че един клас може да 
имплементира много интерфейси и наследява само един клас (бил той и 
чист абстрактен клас). 

В началото при съществуването на множествено наследяване не е имало 
нужда от интерфейси. За да бъде заместено, се е наложило да се появят 
интерфейсите, които да носят многото роли на един обект. 

 -----------------------------   Виртуални методи    -----------------------------  

Метод, който може да се пренапише в клас наследник, се нарича 
виртуален метод (virtual method). Всички методи в Java са виртуални, 
без изрично да се дефинират като такива. Ако не искаме да бъдат 
виртуални, ги маркираме с ключовата дума final. Тогава никой клас
наследник не може да декларира и дефинира метод със същата сигнатура. 
Виртуалните методи са важни за пренаписването на методи (method 
overriding), което е в сърцето на полиморфизма. 

Виртуални методи – пример str 703
Имаме клас, наследяващ друг, като и двата имат общ метод. И двата метода 
пишат на конзолата. Ето как изглежда класът Lion: 
 -----------------------------   -----------------------------  ------------
public class Lion extends Felidae { 
 // ... 
  
 public void catchPray(Object pray) { 
  System.out.println("Lion.catchPray"); 
 } 
} 
 -----------------------------   -----------------------------  ------------str 703
public class AfricanLion extends Lion { 
 // ... 
  
 public void catchPray(Object pray) { 
  System.out.println("AfricanLion.catchPray"); 
 } 
}
 -----------------------------   -----------------------------  ------------str 703
public static void main(String... args) { 
  { 
   Lion lion = new Lion(); 
   lion.catchPray(null); 
   // Will print "Lion.catchPray" 
  } 
 
  {
   AfricanLion lion = new AfricanLion(); 
   lion.catchPray(null); 
   // Will print "AfricanLion.catchPray" 
  } 
 
  { 
   Lion lion = new AfricanLion(); 
   lion.catchPray(null); 
   // Will print "AfricanLion.catchPray", because 
   // the variable lion has value of type AfricanLion 
  } 
 } 
} 

В последния опит ясно се вижда как всъщност се извиква пренаписаният 
метод, а не базовият. Това се случва, защото се проверява кой всъщност е 
истинският клас, стоящ зад променливата, и се проверява дали той има 
имплементиран (пренаписан) този метод.

 Пренаписването на методи се нарича още: припокриване (подмяна) на 
виртуален метод. 

Както виртуалните, така и абстрактните методи могат да бъдат припокри
вани. Абстрактните методи всъщност представляват виртуални методи без 
конкретна имплементация. Всички методи, които са дефинирани в даден 
интерфейс са абстрактни и следователно виртуални, макар и това да не е 
дефинирано изрично.


 -----------------------------   Виртуални методи и скриване на методи     -----------------------------  

В горния пример имплементацията на базовия клас остана скрита и неиз
ползвана. Ето как можем да ползваме и нея като част от новата имплемен
тация (в случай че не искаме да подменим, а само да допълним старата 
имплементация):

public class AfricanLion extends Lion { 
	public boolean catchPray(Object pray) { 
	System.out.println("AfricanLion.catchPray"); 
	System.out.println("calling super.catchPray(pray)"); 
	super.catchPray(pray); 
	} 
}

-- ще се изпишат и трите реда 

AfricanLion.catchPray 
calling super.catchPray(pray) 
Lion.catchPray 

 -----------------------------   Кога да използваме полиморфизъм?   -----------------------------  

Отговорът на този въпрос е прост: винаги, когато искаме да предоставим 
възможност имплементацията на даден метод да бъде подменен в клас
наследник. Добро правило е да се работи с възможно най-базовия клас или 
направо с интерфейс. Така промените върху използваните класове се 
отразяват в много по-малка степен върху класовете, които ние пишем. 
Колкото по-малко знае една програма за обкръжаващите я класове, тол
кова по-малко промени (ако въобще има някакви) трябва да претърпи тя. 		

 -----------------------------   Свързаност на отговорностите и функционално обвързване    -----------------------------  

Термините cohesion и coupling са неразривно свързани с ООП. Те допълват 
и дообясняват някои от принципите, които описахме до момента. Нека се 
запознаем с тях.

 -----------------------------   Свързаност на отговорностите (cohesion)   -----------------------------  

Понятието cohesion (свързаност на отговорностите) показва до каква 
степен различните задачи и отговорности на една програма или един 
компонент са свързани помежду си, т.е. колко фокусиранa е програмата в 
решаването на една единствена задача. Разделя се на силна свързаност 
(strong cohesion) и слаба свързаност (weak cohesion). 

 -----------------------------   Силна свързаност на отговорностите (strong cohesion)

Когато кохезията (cohesion) е силна, това показва, че отговорностите и 
задачите на една единица код (метод, клас, компонент, подпрограма) са 
свързани помежду си и се стремят да решат общ проблем. Това е нещо, към 
което винаги трябва да се стремим. Strong cohesion е типична харак
теристика на висококачествения софтуер. 

 -----------------------------  Силна свързаност за клас  -----------------------------  
Силна свързаност на отговорностите (strong cohesion) в един клас означава, 
че този клас описва само един субект. По-горе споменахме, че един субект 
може да има много роли (Петър е военен, съпруг, данъкоплатец). Всички 
тези роли се описват в един и същ клас. Силната свързаност означава, че 
класът решава една задача, един проблем, а не много едновременно. Клас, 
който прави много неща едновременно е труден за разбиране и поддръжка. 
Представете си клас, който реализира едновременно хеш-таблица, 
предоставя функции за печатане на принтер, за пращане на e-mail и за 
работа с тригонометрични функции. Какво име ще дадем на този клас? Ако 
се затрудняваме в отговора на този въпрос, това означава, че нямаме силна 
свързаност на отговорностите (cohesion) и трябва да разделим класа на 
няколко по-малки, всеки от които решава само една задача.

 -----------------------------  Силна свързаност за клас – пример  -----------------------------  
Като пример за силна свързаност на отговорности можем да дадем класа 
java.lang.Math. Той изпълнява една единствена задача – предоставя 
математически изчисления и константи: 
- Sin(), Cos(), Asin() 
- Sqrt(), Pow(), Exp()
 - Math.PI, Math.E
 
 -----------------------------  Силна свързаност за метод  -----------------------------  
Един метод е добре написан, когато изпълнява само една задача и я 
изпълнява добре. Метод, който прави много неща, свързани със съвсем 
различни задачи, има лоша кохезия и трябва да се раздели на няколко по
прости метода, които решават само една задача. И тук стои въпросът какво 
име ще дадем на метод, който търси прости числа, чертае 3D графика на 
екрана, комуникира по мрежата и печата на принтер справки, извлечени 
от база данни. Такъв метод има лоша кохезия и трябва да се раздели 
логически на няколко метода. 

 -----------------------------  Слаба свързаност на отговорностите (weak cohesion)  -----------------------------  
Слаба свързаност се наблюдава при методи, които вършат по няколко 
задачи. Тези методи трябва да приемат няколко различни групи параметри, 
за да извършат различните задачи. Понякога това налага несвързани
логически данни да се обединяват за точно такива методи. Използването 
на слаба кохезия (weak cohesion) е вредно и трябва да се избягва!

 -----------------------------  Слаба свързаност на отговорностите – пример  -----------------------------  
Ето един пример за клас, който има weak cohesion: 

public class Magic { 
	public void PrintDocument(Document d) { ... } 
	public void SendEmail(string recipient, 
	string subject, string text) { ... } 
	public void CalculateDistanceBetweenPoints( 
	int x1, int y1, int x2, int y2) { ... } 
} 

 -----------------------------  Добри практики за свързаност на отговорностите -----------------------------  

Съвсем логично силната свързаност е "добрият" начин на писане на код. 
Понятието се свързва с по-прост и по-ясен сорс код – код, който по-лесно 
се поддържа и по-лесно се преизползва (поради по-малкия на брой задачи, 
които той изпълнява). 
Обратно, при слаба свързаност всяка промяна е бомба със закъснител, 
защото може да засегне друга функционалност. Понякога една логическа 
задача се разпростира върху няколко модула и така промяната й е по
трудоемка. Преизползването на код също е трудно, защото един компонент 
върши няколко несвързани задачи и за да се използва отново, трябва да са 
на лице точно същите условия, което трудно може да се постигне. 

 -----------------------------  Функционално обвързване (coupling)  -----------------------------  
Функционално обвързване (coupling) описва най-вече до каква степен 
компонентите / класовете зависят един от друг. Дели се на функционална 
независимост (loose coupling) и силна взаимосвързаност (tight 
coupling). Функционалната независимост обикновено идва заедно със 
слабата свързаност на отговорностите и обратно.

 -----------------------------  Функционална независимост (loose coupling) -----------------------------   
Функционалната независимост (loose coupling) се характеризира с това, че 
единиците код (подпрограма / клас / компонент) общуват с други такива 
през ясно дефинирани интерфейси (договори) и промяната в имплемента
цията на един компонент не се отразява на другите, с които той общува. 
Когато пишете програмен код, не трябва да разчитате на вътрешни харак
теристики на компонентите (специфично поведение, неописано в интер
фейсите). 
Договорът трябва да е максимално опростен и да дефинира единствено 
нужните за работата на този компонент поведения, като скрива всички 
ненужни детайли.

Функционалната независимост е характеристика на кода, към която трябва 
да се стремите. Тя е една от отличителните черти на качествения програмен 
код. 

 -----------------------------  Loose coupling – пример  -----------------------------  
Ето един пример, в който имаме функционална независимост между 
класовете и методите: 

class Report { 
	public boolean loadFromFile(String fileName) {…} 
	public boolean saveToFile(String fileName) {…} 
} 
class Printer { 
	public static int print(Report report) {…} 
} 
class Example { 
	public static void main(String[] args) { 
	Report myReport = new Report(); 
	myReport.loadFromFile("DailyReport.xml"); 
	Printer.print(myReport); 
	} 
} 


В този пример никой клас и никой метод не зависи от останалите. Методите 
зависят само от параметрите, които им се подават. Ако някой метод ни 
потрябва в следващ проект, лесно ще можем да го извадим и използваме 
отново. 


 -----------------------------   Силна взаимосвързаност (tight coupling) str 707  -----------------------------  

Силна взаимосвързаност имаме при много входни параметри и изходни 
параметри и при използване на неописани (в договора) характеристики на 
друг компонент (например зависимост от статични полета в друг клас). При 
използване на много т. нар. контролни променливи, които оказват какво да 
е поведението със същинските данни. Силната взаимосвързаност между два 
или повече метода, класа или компонента означава, че те не могат да 
работят независимо един от друг и че промяната в един от тях ще засегне 
и останалите. Това води до труден за четене код и големи проблеми при 
поддръжката му. 


 -----------------------------   Tight coupling – пример   -----------------------------  
Ето един пример, в който имаме силна взаимосвързаност между класовете 
и методите: 


class MathParams { 
	public static double operand; 
	public static double result; 
} 

class MathUtil { 
	public static void sqrt() { 
	MathParams.result = calcSqrt(MathParams.operand); 
	} 
} 

class SpaceShuttle { 
	public static void main(String[] args) { 
		MathParams.operand = 64; 
		MathUtil.sqrt(); 
		System.out.println(MathParams.result); 
	} 
} 


 -----------------------------   Добри практики за функционално обвързване  -----------------------------  

Добрата практика е да не се разчита на нищо повече от описаното в 
договора (интерфейса). Разбира се, добра практика е да се програмира 
срещу интерфейси, а не срещу конкретни класове (за това вече споменахме 
в секцията "Абстракция"). 

Добра практика е методите да са гъвкави и да са готови да работят с всички 
компоненти, които спазват интерфейса им, а не само с определени такива. 
Последното би означавало, че тези методи очакват нещо специфично от 
компонентите, с които могат да работят. Добра практика е също всички 
зависимости да са ясно описани и видими. Иначе поддръжката на такъв код 
става трудна (пълно е с подводни камъни). 

Добър пример за strong cohesion и loose coupling е библиотеката Java 
collections framework (колекциите в Java). Класовете за работа с колекции 

имат силна кохезия. Всеки от тях решава една задача и позволява лесна 
преизползваемост. Тези класове притежават и другата характеристика на 
качествения програмен код: loose coupling. Класовете, реализиращи 
колекциите са необвързани един с друг. Всеки от тях работи през строго 
дефиниран интерфейс и не издава детайли за своята имплементация. 
Всички методи и полета, които не са от интерфейса, са скрити, за да се 
намали възможността за обвързване на други класове с тях. Методите в 
класовете за колекции не зависят от статични променливи и не разчитат на 
никакви входни данни, освен вътрешното си състояние и подадените им 
параметри. Това е добрата практика, до която рано или късно всеки 
програмист достига като понатрупа опит. 


 -----------------------------   Код като спагети (spaghetti code)  -----------------------------  

Спагети код е неструктуриран код с неясна логика, труден за четене, 
разбиране и за поддържане. Това е код, в който последователността е 
нарушена и объркана. Това е код, който има weak cohesion и tight coupling. 
Този код се свързва се със спагети, защото също като тях е оплетен и 
завъртян. Като дръпнеш един спагет (т. е. един клас или метод), цялата 
чиния спагети може да се окаже, оплетена в него (т. е. промяна на един 
метод или клас води до още десетки други промени поради силната 
зависимост между тях). Спагети кодът е почти невъзможно да се 
преизползва, защото няма как да отделиш тази част от него, която върши 
работа.

 -----------------------------   Обектно-ориентирано моделиране (OOM)  -----------------------------  
Нека приемем, че имаме да решаваме определен проблем или задача. Този 
проблем идва обикновено от реалния свят. Той съществува в дадена 
реалност, която ще наричаме заобикаляща го среда.

 -----------------------------   Обектно-ориентираното моделиране (ООМ) е процес, свързан с ООП, 
при който се изваждат всички обекти, свързани с проблема, който 
решаваме (създава се модел). Изваждат се само тези техни характеристики, 
които са свързани с решаването на конкретния проблем. Останалите се 
игнорират. Така вече си създаваме нова реалност, която е опростена версия
на оригиналната (неин модел), и то такава, че ни позволява да си решим 
проблема или задачата. 

Например, ако моделираме система за продажба на билети, за един пътник 
важни характеристики биха могли да бъдат неговото име, неговата възраст, 
дали ползва намаление и дали е мъж или жена (ако продаваме спални 
места). Пътникът има много други характеристики, които не ни 
интересуват, примерно какъв цвят са му очите, кой номер обувки носи, 
какви книги харесва или каква бира харесва.
 
При моделирането се създава опростен модел на реалността с цел решаване 
на конкретната задача. При обектно-ориентираното моделиране моделът се 
прави със средствата на ООП: чрез класове, атрибути на класовете, методи 
в класовете, обекти, взаимоотношения между класовете и т.н. Нека 
разгледаме този процес в детайли. 


 -----------------------------   Стъпки при обектно-ориентираното моделиране  -----------------------------   
Обектно-ориентираното моделиране обикновено се извършва в следните 
стъпки: 
- Идентификация на класовете.
- Идентификация на атрибутите на класовете. 
- Идентификация на операциите върху класовете. 
- Идентификация на връзките между класовете.
 
Ще разгледаме кратък пример, с който ще ви покажем как могат да се 
приложат тези стъпки. 

 -----------------------------  Идентификация на класовете   -----------------------------  

 -----------------------------   ИМЕНУВАНЕ НА КЛАСОВЕ И МЕТОДИ  -----------------------------  
ИМЕНАТА НА КЛАСОВЕТЕ СА:
СЪЩЕСТВИТЕЛНИ ИМЕНА 
Имената на 
класовете са съществителните имена в текста, най-често нарицателни в 
единствено число, например Студент, Съобщение, Лъв. Избягвайте имена, 
които не идват от текста, примерно: СтраненКлас, АдресКойтоИмаСтудент. 

НА МЕТОДИТЕ ГЛАГОЛ + СЪЩЕСТВИТЕЛНО
PrintReport(), ConnectToDatabase(). 


Нека имаме следната извадка от заданието за дадена система: 

На потребителя трябва да му е позволено да описва всеки продукт по 
основните му характеристики, включващи име и номер на продукта. Ако 
бар-кодът не съвпада с продукта, тогава трябва да бъде генерирана 
грешка на екрана за съобщения. Трябва да има дневен отчет за всички 
транзакции, специфицирани в секция 9. 

- потребителя
- продукт
- характеристики
- име
- номер на продукта
- бар-кодът
- грешка
- екрана за съобщения
- дневен отчет
- транзакции

Току-що идентифицирахме класовете, които ще ни трябват. Имената на 
класовете са съществителните имена в текста, най-често нарицателни в 
единствено число, например Студент, Съобщение, Лъв. Избягвайте имена, 
които не идват от текста, примерно: СтраненКлас, АдресКойтоИмаСтудент. 

Понякога е трудно да се прецени дали някой предмет или явление от 
реалния свят трябва да бъде клас. Например адресът може да е клас Address 
или символен низ. Колкото по-добре проучим проблема, толкова по-лесно 
ще решим кое трябва да е клас. Когато даден клас стане прекалено голям 
и сложен, той трябва да се декомпозира на няколко по-малки класове.

 -----------------------------   Идентификация на атрибутите на класовете  -----------------------------  

Класовете имат атрибути (характеристики), например: класът Student има 
име, учебно заведение и списък от курсове. Не всички характеристики са 
важни за софтуерната система. Например: за класа Student цвета на очите 
е несъществена характеристика. Само съществените характеристики 
трябва да бъдат моделирани. 


 -----------------------------   Идентификация на операциите върху класовете  -----------------------------  

Всеки клас трябва да има ясно дефинирани отговорности – какви обекти 
или процеси от реалния свят представя, какви задачи изпълнява. Всяко 
действие в програмата се извършва от един или няколко метода в някой 
клас. Действията се моделират с операции (методи).

За имената на методите се използват глагол + съществително. Примери: 
PrintReport(), ConnectToDatabase(). Не може веднага да се дефинират 
всички методи на даден клас. Дефинираме първо най-важните методи – 
тези, които реализират основните отговорности на класа. С времето се 
появяват още допълнителни методи.



 -----------------------------   ИМЕНУВАНЕ НА КЛАСОВЕ И МЕТОДИ   -----------------------------  
ИМЕНАТА НА КЛАСОВЕТЕ СА:
СЪЩЕСТВИТЕЛНИ ИМЕНА 
Имената на 
класовете са съществителните имена в текста, най-често нарицателни в 
единствено число, например Студент, Съобщение, Лъв. Избягвайте имена, 
които не идват от текста, примерно: СтраненКлас, АдресКойтоИмаСтудент. 

НА МЕТОДИТЕ ГЛАГОЛ + СЪЩЕСТВИТЕЛНО
PrintReport(), ConnectToDatabase().

 -----------------------------  Идентификация на връзките между класовете   -----------------------------  
Ако един студент е от определен факултет и за задачата, която решаваме, 
това е важно, тогава студент и факултет са свързани. Тоест класът Факултет 
има списък от Студенти. Тези връзки наричаме още асоциации (спомнете си 
секцията "клас-диаграми"). 


 -----------------------------   Нотацията UML  -----------------------------  
UML (Unified Modelling Language) бе споменат в секцията за наследяване. 
Там разгледахме клас-диаграмите. UML нотацията дефинира още няколко 
вида диаграми. Нека разгледаме накратко някои от тях.

Use case диаграми (случаи на употреба) 
Използват се при извличане на изискванията за описание на възможните 
действия. Актьорите (actors) представят роли (типове потребители). 

Случаите на употреба (use cases) описват взаимодействие между 
актьорите и системата. Use case моделът е група use cases – предоставя 
пълно описание на функционалността на системата. 

Use case диаграми – пример 
Ето как изглежда една sequence диаграма: СТР 713


Sequence диаграми 
Използват се при моделиране на изискванията за описание на процеси. За 
по-добро описание на use case сценариите. Позволяват описание на 
допълнителни участници в процесите. Използват се при дизайна за 
описание на системните интерфейси.

Sequence диаграми – пример 
Ето как изглежда една sequence диаграма:

 Класовете се представят с колони. Съобщенията (действията) се 
представят чрез стрелки. Участниците се представят с широки правоъ
гълници. Състоянията се представят с пунктирана линии. 

Съобщения – пример 

Посоката на стрелката определя изпращача и получателя на съобщението. 
Хоризонталните прекъснати линии изобразяват потока на данните: 


Statechart диаграми 
Statechart диаграмите описват възможните състояния на даден процес и 
възможните преходи между тях. Представляват краен автомат: 

шаблон сингълтон

шаблон фактори

 -----------------------------   декларация в С++  -----------------------------  
extern int number; // декларация на променлива (number е декларирана, но не е дефинирана)
int sum(int a, int b); // декларация на функция

 -----------------------------   Дефиниция в С++  -----------------------------  

int number = 5; // дефиниция на променлива
int sum(int a, int b) { // дефиниция на функция
    return a + b;
}

 -----------------------------   декларация в Java  -----------------------------  
int number; // това е декларация на променлива

 -----------------------------   Дефиниция в Java  -----------------------------  
int number = 10; // дефиниция на променлива

 -----------------------------   -----------------------------  ---------- записки  -----------------------------  

Абстракция и интерфейси 
Най-добрият начин да се реализира абстракция е да се работи с интер
фейси. 


Да преговоря:
-(cohesion и coupling)

-- да разгледам наследяване и подаване на стоиност на конструктоора , видовете конструктори

други записки
Класовете са описание (модел) на реални предмети или явления, 
наречени същности (entities).

super може да се използва изрично, за яснота. super. 
method()  извиква метод, който задължително е от базовия 
клас. Такъв код се чете по-лесно, защото знаем къде да 
търсим въпросния метод. 
Имайте предвид, че ситуацията с this не е такава. this 
може да означава както метод от конкретния клас, така и 
метод от който и да е базов клас.

При наследяване на един клас, нашите конструктори задължително трябва 
да извикат конструктор на базовия клас, за да може и той да инициализира 
член-променливите си. Ако не го направим изрично, в началото на всеки 
наш конструктор компилаторът поставя извикване на базовия конструктор 
без параметри: super(). Ако базовият клас няма конструктор по 
подразбиране (без параметри), нашите конструктори трябва да извикат 
изрично някои от другите конструктори на базовия клас. Липсата на 
изрично извикване предизвиква грешка при компилация. 

Класът Object 

Архитектите на Java поемат в друга посока. Те създават клас, който всички 
други класове пряко или косвено да наследяват и до който всеки обект 
може да бъде преобразуван. В този клас е удобно да бъдат сложени важни 
методи и тяхната имплементация по подразбиране. Този клас се нарича 
Object. 

В Java всеки клас, който не наследява друг клас изрично, наследява 
системния клас java.lang.Object по подразбиране.


Кога да използваме абстракция и интерфейси? 
Отговорът на този въпрос е: винаги, когато искаме да постигнем абстракция 
на данни или действия, чиято имплементация по-късно може да се подмени. 
Написаният код срещу интерфейси е много по-издръжлив срещу промени, 
отколкото написаният срещу конкретни класове. Работата през интерфейси 
е често срещана и силно препоръчвана практика – едно от основните 
правила за писане на качествен код.

Кога да пишем интерфейси? 
Винаги е добра идея да се използват интерфейси, когато се предоставя 
функционалност на друг компонент. В интерфейса се слага само функцио
налността (като декларация), която другите трябва да виждат. 
Вътрешно в една програма/компонент интерфейсите могат да се използват 
за дефиниране на роли. Така един обект може да се използва от много 
класове чрез различните му роли. 


Капсулация (Encapsulation)

Изборът какво е скрито и какво е публично видимо е на този, който пише 
класа. Когато програмираме трябва да дефинираме като private (скрит) 
всеки метод или поле, които не ползваме от друг клас. 



Абстрактни класове 
Какво става, ако искаме да кажем, че класът Felidae е непълен и само 
наследниците му могат да имат инстанции? Това става с ключовата дума 
abstract пред името на класа и означава, че класът не е готов и не може да 
бъде инстанциран. Такъв клас се нарича абстрактен клас. А как да укажем 
коя точно част от класа не е пълна? Това отново става с ключовата дума 
abstract пред името на метода, който трябва да бъде имплементиран.



Чист абстрактен клас 
Абстрактните класове, както и интерфейсите не могат да се инстанцират. 
Ако се опитате да създадете инстанция на абстрактен клас, ще получите 
грешка по време на компилация. Понякога даден клас може да бъде 
деклариран като абстрактен дори и да няма нито един абстрактен 
метод, просто, за да се забрани директното му използване, без да се 
създава инстанция на негов наследник. 
Чист абстрактен клас (pure abstract class) е абстрактен клас, който 
няма нито един имплементиран метод, както и нито една член променлива. 
Много напомня на интерфейс. Основната разлика е, че един клас може да 
имплементира много интерфейси и наследява само един клас (бил той и 
чист абстрактен клас). 
В началото при съществуването на множествено наследяване не е имало 
нужда от интерфейси. За да бъде заместено, се е наложило да се появят 
интерфейсите, които да носят многото роли на един обект. 

Виртуални методи 
Метод, който може да се пренапише в клас наследник, се нарича 
виртуален метод (virtual method). Всички методи в Java са виртуални, 
без изрично да се дефинират като такива. Ако не искаме да бъдат 
виртуални, ги маркираме с ключовата дума final. Тогава никой клас
наследник не може да декларира и дефинира метод със същата сигнатура. 
Виртуалните методи са важни за пренаписването на методи (method 
overriding), което е в сърцето на полиморфизма.


Пренаписването на методи се нарича още: припокриване (подмяна) на 
виртуален метод.

дефиниция на метод е като примерно в интерфеиса се изписват void methodName(int paramOne, int paramTwo);

Кога да използваме полиморфизъм? 
Отговорът на този въпрос е прост: винаги, когато искаме да предоставим 
възможност имплементацията на даден метод да бъде подменен в клас
наследник. Добро правило е да се работи с възможно най-базовия клас или 
направо с интерфейс. Така промените върху използваните класове се 
отразяват в много по-малка степен върху класовете, които ние пишем. 
Колкото по-малко знае една програма за обкръжаващите я класове, тол
кова по-малко промени (ако въобще има някакви) трябва да претърпи тя.

Свързаност на отговорностите (cohesion)

кохезия - колко състедоточен е един метод или клас в решаването само на една задача

Когато кохезията (cohesion) е силна, това показва, че отговорностите и 
задачите на една единица код (метод, клас, компонент, подпрограма) са 
свързани помежду си и се стремят да решат общ проблем. Това е нещо, към 
което винаги трябва да се стремим. Strong cohesion е типична харак
теристика на висококачествения софтуер. 

Силна свързаност за клас – пример 
Като пример за силна свързаност на отговорности можем да дадем класа 
java.lang.Math. Той изпълнява една единствена задача – предоставя 
математически изчисления и константи: 

Силна свързаност за метод 
Един метод е добре написан, когато изпълнява само една задача и я 
изпълнява добре. Метод, който прави много неща, свързани със съвсем 
различни задачи, има лоша кохезия и трябва да се раздели на няколко по
прости метода, които решават само една задача.

Слаба свързаност на отговорностите (weak cohesion) 
Слаба свързаност се наблюдава при методи, които вършат по няколко 
задачи. 


Функционално обвързване (coupling)



Функционално обвързване (coupling) 
Функционално обвързване (coupling) описва най-вече до каква степен 
компонентите / класовете зависят един от друг. Дели се на функционална 
независимост (loose coupling) и силна взаимосвързаност (tight 
coupling). Функционалната независимост обикновено идва заедно със 
слабата свързаност на отговорностите и обратно. 
Функционална независимост (loose coupling) 
Функционалната независимост (loose coupling) се характеризира с това, че 
единиците код (подпрограма / клас / компонент) общуват с други такива 
през ясно дефинирани интерфейси (договори) и промяната в имплемента
цията на един компонент не се отразява на другите, с които той общува. 
Когато пишете програмен код, не трябва да разчитате на вътрешни харак
теристики на компонентите (специфично поведение, неописано в интер
фейсите). 
Договорът трябва да е максимално опростен и да дефинира единствено 
нужните за работата на този компонент поведения, като скрива всички 
ненужни детайли.

class Report { 
	public boolean loadFromFile(String fileName) {…} 
	public boolean saveToFile(String fileName) {…} 
} 
class Printer { 
	public static int print(Report report) {…} 
} 
class Example { 
	public static void main(String[] args) { 
		Report myReport = new Report(); 
		myReport.loadFromFile("DailyReport.xml"); 
		Printer.print(myReport); 
	} 
} 

Силна взаимосвързаност (tight coupling) 
Силна взаимосвързаност имаме при много входни параметри и изходни 
параметри и при използване на неописани (в договора) характеристики на 
друг компонент (например зависимост от статични полета в друг клас). При 
използване на много т. нар. контролни променливи, които оказват какво да 
е поведението със същинските данни. Силната взаимосвързаност между два 
или повече метода, класа или компонента означава, че те не могат да 
работят независимо един от друг и че промяната в един от тях ще засегне 
и останалите. Това води до труден за четене код и големи проблеми при 
поддръжката му.


Добри практики за функционално обвързване 
Добрата практика е да не се разчита на нищо повече от описаното в 
договора (интерфейса). Разбира се, добра практика е да се програмира 
срещу интерфейси, а не срещу конкретни класове (за това вече споменахме 
в секцията "Абстракция"). 
Добра практика е методите да са гъвкави и да са готови да работят с всички 
компоненти, които спазват интерфейса им, а не само с определени такива. 
Последното би означавало, че тези методи очакват нещо специфично от 
компонентите, с които могат да работят. Добра практика е също всички 
зависимости да са ясно описани и видими. Иначе поддръжката на такъв код 
става трудна (пълно е с подводни камъни). 


Класовете, реализиращи 
колекциите са необвързани един с друг. Всеки от тях работи през строго 
дефиниран интерфейс и не издава детайли за своята имплементация. 
Всички методи и полета, които не са от интерфейса, са скрити, за да се 
намали възможността за обвързване на други класове с тях. Методите в 
класовете за колекции не зависят от статични променливи и не разчитат на 
никакви входни данни, освен вътрешното си състояние и подадените им 
параметри. Това е добрата практика, до която рано или късно всеки 
програмист достига като понатрупа опит.


Обектно-ориентирано моделиране (OOM) 
Нека приемем, че имаме да решаваме определен проблем или задача. Този 
проблем идва обикновено от реалния свят. Той съществува в дадена 
реалност, която ще наричаме заобикаляща го среда. 
Обектно-ориентираното моделиране (ООМ) е процес, свързан с ООП, 
при който се изваждат всички обекти, свързани с проблема, който 
решаваме (създава се модел). Изваждат се само тези техни характеристики, 
които са свързани с решаването на конкретния проблем. Останалите се 
игнорират. Така вече си създаваме нова реалност, която е опростена версия 

на оригиналната (неин модел), и то такава, че ни позволява да си решим 
проблема или задачата. 
Например, ако моделираме система за продажба на билети, за един пътник 
важни характеристики биха могли да бъдат неговото име, неговата възраст, 
дали ползва намаление и дали е мъж или жена (ако продаваме спални 
места). Пътникът има много други характеристики, които не ни 
интересуват, примерно какъв цвят са му очите, кой номер обувки носи, 
какви книги харесва или каква бира харесва. 
При моделирането се създава опростен модел на реалността с цел решаване 
на конкретната задача. При обектно-ориентираното моделиране моделът се 
прави със средствата на ООП: чрез класове, атрибути на класовете, методи 
в класовете, обекти, взаимоотношения между класовете и т.н. Нека 
разгледаме този процес в детайли. 

 -----------------------------   -----------------------------  ----------- Глава 21. Качествен програмен код  -----------------------------   -----------------------------  -----------

 -----------------------------   Именуване на идентификаторите

Идентификатори са имената на класове, интерфейси, изброими типове, 
анотации, методи и променливи. 

 Имената трябва да са съставени така, че да носят полезна информация 
 за какво служат и каква точно роля изпълняват в съответния код.
 
 -----------------------------   Имена на класове, интерфейси и други типове  -----------------------------  
 
  Имената на класовете да 
са от съществително име (нарицателно или собствено) и от едно 
или няколко прилагателни (преди или след съществителното).
Класът Африканския лъв ще се казва AfricanLion.
Това е именуване Pascal Case – първата буква на всяка дума от името 
е главна, а останалите са малки. 

Трябва да напишем клас, който намира 
прости числа в даден интервал. Добро име за този клас е PrimeNumbers или 
PrimeNumbersFinder или PrimeNumbersScanner. Лоши имена биха могли да 
бъдат FindPrimeNumber (не трябва да ползваме глагол за име на клас) или 
Numbers (не става ясни какви числа и какво ги правим) или Prime (не трябва 
да името на клас да е прилагателно).

Изключително лошо име на клас е Problem12. Някои начинаещи програмисти 
дават такова име за решението на задача 12 от упражненията. Това е 
изключително грешно!

Ако задачата търси път в лабиринт, дайте и име 
PathInLabyrinth.

Не давайте име, което съдържа числа – това е индикация 
за лошо именуване. 

Името на класа трябва да описва за какво служи този 
клас. Решението на задача 12 от упражненията не трябва 
да се казва Problem12 или Zad12. Това е груба грешка! 


 -----------------------------   Избягвайте съкращения  -----------------------------  
GrBxPnl трябва да е GroupBoxPanel
но
Изключения се правят за акроними, които са по
популярни от пълната си форма, например HTML или URL.
Например името 
HTMLParser е препоръчително пред HyperTextMarkupLanguageParser. 

 -----------------------------   Колко да са дълги имената на класовете?  -----------------------------  

Препоръчително е 
Имената на класовете да не надвишават 20 символа.
 В стандартните 
Java библиотеки има класове с дължина 40 символа, като примерно 
класовете 
ContentHandlerAlreadyRegisteredException 
и 
SQLIntegrityConstraintViolationException. Въпреки дължината е ясно за 
какво служат и двата класа.

Затова се препоръчва дължината да е максимум 20 символа.

 Ако може едно име 
да е по-кратко и също толкова ясно, колкото дадено по-дълго име, 
предпочитайте по-краткото. 

 -----------------------------   Имена на интерфейси и други типове  -----------------------------  

Имената на интерфейсите, изброимите типове (enums) и анотациите трябва 
да следват същата конвенция, както имената на класовете: изписват се в 
Pascal Case и се състоят от съществително и евентуално прилагателни. 
В Java има още една нотация за имена интерфейси: да завършват на able: 
Runnable, Serializable, Cloneable. Това са интерфейси, които най-често 
добавят допълнителна роля към основната роля на един обект. В Java 
повечето интерфейси не следват тази нотация, например интерфейсите Map 
и Set.

 -----------------------------   Имена на методи  -----------------------------  
Името да е camelCase и да почва с малка буква.
Името да е <глагол> + <обект>, например printReport(),  loadSettings() или setUserName(). 

Обектът може да е съществително или да е съставен от съществително и 
прилагателно, например showAnswer(), connectToRandomTorrentServer() или 
findMaxValue(). 

Лоши примери са: doWork() (не става ясно каква точно работа върши),
 printer() (няма глагол),
 find2() (ами защо не е find7()?),
 chkErr() (не се препоръчват съкращения), 
nextPosition() (няма глагол). 

Понякога единични глаголи са също добро име за метод, стига да става ясно 
какво прави съответния метод и върху какви обекти оперира. Например ако 
имаме клас Task, методите start(), stop() и cancel() са с добри имена, 
защото става ясно, че стартират, спират или оттеглят изпълнението на 
задачата, в текущия обект (this). В други случаи единичния глагол е 
грешно име, примерно в клас с име Utils методи с имена evaluate(), 
create() или stop() са неадекватни.

 -----------------------------   Методи, които връщат стойност  -----------------------------  
Имената на методите, които връщат стойност, трябва да описват връщаната 
стойност, например getNumberOfProcessors(), findMinPath(), getPrice(), 
getRowsCount(), createNewInstance(). 
Примери за лоши имена на методи, които връщат стойност (функции) са 
следните: showReport() (не става ясно какво връща методът), value() 
(трябва да е getValue() или hasValue()), student() (няма глагол), empty() 
(трябва да е isEmpty()).

 -----------------------------   Свързаност на отговорностите и именуване  -----------------------------  
Името трябва да описва всичко, което методът извършва. Ако не може да 
се намери подходящо име, значи няма силна свързаност на отговорностите 
(strong cohesion), т.е. методът върши много неща едновременно и трябва 
да се раздели на няколко отделни метода. 

 -----------------------------   Именуване на методи – още препоръки  -----------------------------  
Лоша практика е за имена на методи да се използват безлични и общи 
думички, например handleStuff() и processData(). 

Не се препоръчва да се използват цифри в името, например readProfile1() 
и readProfile2(). 

Дължината на името трябва да е толкова дълга, колкото е необходимо. 
Нормалното име на метод е в рамките на 9-15 символа. Ако името е 
прекалено дълго, ней-вероятно имаме лоша кохезия.

Консистентно трябва да се именуват методи, които извършват противо
положни операции: open() и close(), read() и write(). Лош пример би бил: 
openFile() и _descriptor_close().

Използвайте конвенция за честите операции. Например за четене и писане 
можем да ползваме getXXX() и setXXX(): getName(), getAge(), setName(), 
setAge(). Спазвайте тази конвенция навсякъде.


 -----------------------------   Модификатори   -----------------------------  

В света на Java има още една изключително популярна спецификация. 
Нарича се JavaBeans (пише се слято). JavaBeans е група от правила и 
интерфейси за писане на преизползваеми компоненти.

JavaBeans препоръчва, всяка една член-променлива да бъде скрита 
(private), а достъпът до нея да е с (getters and setters, accessor methods). 

isMale() вместо getMale(). is вместо get за булевите променливи. 

 -----------------------------   Имена на променливи  -----------------------------  

Името да е 10 до 16 символа, ясно и точно да описва обекта, който променливата съдържа. Например добри имена 
на променливи са account, blockSize и customerDiscount.

Името трябва да адресира проблема, който решава променливата. Тя 
трябва да отговаря на въпроса “какво", а не “как".Добри 
имена са employeeSalary, employees. Лоши имена са, несвързаните с 
решавания проблем имена myArray, customerFile, customerHashTable.

Изборът на дължината на името зависи от обхвата – променливите с по
голям обхват и по-дълъг живот имат по-дълго и описателно име:

protected Account[] customerAccounts; 

Променливите с малък обхват и кратък живот могат да са по-кратки: 
for (int i=0; i<customers.Length; i++) { … }


 -----------------------------   Имена на константи  -----------------------------  

public static final int MAX_POOL_SIZE = 16; 

Имената на константите точно и ясно трябва да описват смисъла на даде
ното число, стринг или друга стойност, а не самата стойност.

Именуване на специфични типове данни 
Имената на променливи, използвани за броячи, е хубаво да включват в 
името си дума, която указва това, например usersCount, rolesCount, 
filesCount. 

Променливи, които се използват за описване на състояние на даден обект, 
трябва да бъдат именувани подходящо. Ето няколко примера: ThreadState, 
TransactionState. 
Временните променливи най-често са с безлични имена (което указва, че 
са временни променливи, т.е. имат много кратък живот). Добри примери са 
index, value, count. Неподходящи имена са a, aa, tmpvar1, tmpvar2.

Имената на булевите променливи трябва да дават предпоставка за истина 
или лъжа. Например: canRead, available, isOpen, valid. Примери за 
неадекватни имена на булеви променливи са: student, read, reader. 

 -----------------------------   Форматиране на кода  -----------------------------  

- да разкрива неговата логическа структура.
- да се подобрява четимостта.

В Eclipse кодът може да се форматира автоматично с клавишната комби
нация [Ctrl+Shift+F].
В intelij e (Ctrl+Alt+L).

- при повече от един метод ги разделяме с 1 празен ред.

- метода да е с една табулация навътре от декларацията на класа.

между ключова дума  и отваряща скоба да 
поставяме интервал: 
while (true) { 
 // ... Code ... 
}

 -----------------------------   Параметри на метод  -----------------------------  
public void doSth(int param1, int param2, int param3) {}	
при извикване doSth(1, 2, 3); 

 -----------------------------   тялото на метод  -----------------------------  
public static void printLogo() { 
// ... Code ... 
}
public static void printLogo() {} 

 -----------------------------   съдържанието на класа  -----------------------------  

Променливи с Модификатори първо public,после protected, накрая private: 

Полета static после нестатични.
 По 
подобие на статичните, първо се декларират тези с модификатор за достъп 
public, след това тези с protected и накрая – тези с private: 

След нестатичните полета на класа, идва ред на декларацията на кон
структорите:


Най-накрая, след конструкторите, се декларират методите на класа. 
Препоръчва се да групираме методите по функционалност, вместо по ниво 
на достъп или област на действие. Например, метод с модификатор за 
достъп private, може да бъде между два метода с модификатори за достъп – public.
 Целта на всичко това е да се улесни четенето и разбирането на 
кода: 


 -----------------------------   Правила за пренасяне и подравняване   -----------------------------  
Когато даден ред е дълъг, разделете го на два или повече реда, като 
редовете след първия отместете надясно с една табулация: 
DictionaryEntry<K, V> newEntry =  
	new DictionaryEntry<K, V>(key, value);
	
	System.out.printf( 
		"word '%s' is seen %d times in the text%n", 
		wordEntry.getKey(), 
		wordEntry.getValue()); 
		
		Защо да използваме методи? 
 
Методът решава по-малък проблем. Много методи решават много малки 
проблеми. по-малките проблеми се решават по-лесно.

Чрез методите се намалява сложността на задачата – сложните проблеми 
се разбиват на по-прости, добавя се допълнително ниво на абстракция, 
скриват се детайли за имплементацията и се намалява рискът от неуспех. 
С помощта на методите се избягва повторението на еднакъв код. Скриват 
се сложни последователности от действия.

Какво трябва да прави един метод? 
Един метод трябва да върши работата, която е описана в името му и нищо 
повече. Ако един метод не върши това, което предполага името му, то или 
името му е грешно, или методът върши много неща едновременно, или 
просто методът е реализиран некоректно. И в трите случая методът не 
отговаря на изискванията за качествен програмен код и има нужда от 
преработка.


Един метод или трябва да свърши работата, която се очаква от него, или 
трябва да съобщи за грешка. В Java съобщаването за грешки се осъще
ствява с хвърляне на изключение. При грешни входни данни е недопустимо 
даден метод да връща грешен резултат. Методът или трябва да работи
коректно или да съобщи, че не може да свърши работата си, защото не са 
на лице необходимите му условия (при некоректни параметри, неочаквано 
състояние на обектите и др.). 

Например ако имаме метод, който прочита съдържанието на даден файл, 
той трябва да се казва readFileContents() и трябва да връща byte[] или 
String (в зависимост дали говорим за двоичен или текстов файл). Ако 
файлът не съществува или не може да бъде отворен по някаква причина, 
методът трябва да хвърли изключение, а не да върне празен низ или null.
Връщането на неутрална стойност (например null) вместо съобщение за 
грешка не е препоръчителна практика, защото извикващият метод няма 
възможност да обработи грешката и изгубва носещото богата информация 
изключение. 

Описаното правило има някои изключения. Обикновено то се прилага най
вече за публичните методи в класа. Те или трябва да работят коректно, или 
трябва да съобщят за грешка. При скритите (private) методи може да не се 
проверява за некоректни параметри, тъй като тези методи може да ги 
извика само авторът на класа, а той много добре знае какво подава като 
параметри и не винаги трябва да обработва изключителните ситуации, 
защото може да ги предвиди. 


Един публичен метод или трябва да върши коректно точно 
това, което предполага името му, или трябва да съобщава 
за грешка. Всякакво друго поведение е некоректно. 


 -----------------------------   методи още инфо -------------


В идеалния случай даден метод трябва да зависи единствено от парамет
рите си и да не използва никакви други данни като вход или като изход. 
Такива методи лесно могат да се извадят и да се преизползват в друг 
проект, защото са независими от средата, в която се изпълняват.

Понякога методите зависят от private променливи в класа, в който са 
дефинирани или променят състоянието на обекта, към който принадлежат. 
Това не е грешно и е нормално. В такъв случай говорим за обвързване 
(coupling) между метода и класа. Такова обвързване не е проблемно, 
защото целият клас може да се извади и премести в друг проект и ще 
започне да работи без проблем. Повечето класове от стандартните 
библиотеки на Java (от т. нар. Java API) дефинират методи, които зависят 
единствено от данните в класа, който ги дефинира и от подадените им 
параметри. В стандартните Java библиотеки зависимостите на методите от 
външни класове са минимални и затова тези библиотеки са лесни за 
използване.

Ако даден метод чете или променя глобални данни или зависи от още 10 
обекта, които трябва да се инициализирани в инстанцията на неговия клас, 
той е силно обвързан с всички тези обекти. Това означава, че функционира 
сложно и се влияе от прекалено много външни условия и следователно 
възможността за грешки е голяма.

 -----------------------------   Колко дълъг да е един метод?  -----------------------------  
-да гледам да е по кратък.
-ако е колкото един екран е по лесен за четене, ако е по дълъг можем да се замислим
дали не може да се декомпозира.

 -----------------------------   Параметрите на методите  -----------------------------  
Едно от основните правила за подредба на параметрите на методите е 
основният или основните параметри да са първи. Пример: 
public void archive(PersonData person, boolean persistent) { 

Друго основно правило е имената на параметрите да са смислени. Честа 
грешка, особено при Java, е имената на параметрите да бъдат свързани с 
имената на типовете им. Пример: 
public void archive(PersonData personData) { 
Вместо нищо незначещото име personData (което носи информация един
ствено за типа), можем да използваме по-добро име (така е доста по-ясно 
кой точно обект архивираме): 
public void archive(PersonData loggedUser) {


Ако има методи с подобни параметри, тяхната подредба трябва да е кон
систентна. Това би направило кода много по-лесен за четене: 
public void archive(PersonData person, boolean persistent) { 
// ... 
} 
public void retrieve(PersonData person, boolean persistent) { 
// ... 
} 

Параметрите не трябва да се използват и като работни променливи – не 
трябва да модифицират. Ако модифицирате параметрите на методите, 
кодът става по-труден за четене и логиката му – по-трудна за проследя
ване.

Неочевидните допускания трябва да се документират. Например мерната 
единица при подаване на числа. Например, ако имаме метод, който изчис
лява косинус от даден ъгъл, трябва да документираме дали ъгълът е в 
градуси или в радиани, ако това не е очевидно.

Броят на параметрите не трябва да надвишава 7. Това е специално, 
магическо число. Доказано е, че човешкото съзнание не може да следи 
повече от около 7 неща едновременно. Разбира се, тази препоръка е само 
за ориентир. Понякога се налага да предавате и много повече параметри. 
В такъв случай се замислете дали не е по-добре да ги предавате като 
някакъв клас с много полета. Например ако имате метода addStudent(…) с 
15 параметъра (име, адрес, контакти и още много други), можете да 
намалите параметрите му като подавате групи логически свързани пара
метри като клас, примерно така: addStudent(personalData, contacts, 
universityDetails). Всеки от новите 3 параметъра ще съдържа по няколко 
полета и пак ще се прехвърля същата информация, но в по-лесен за 
възприемане вид.


Понякога е логически по-издържано вместо един обект на метода да се 
подадат само едно или няколко негови полета. Това ще зависи най-вече от 
това дали методът трябва да знае за съществуването на този обект или не. 
Например имаме метод, който изчислява средния успех на даден студент – 
calcAverageResults(Student s). Понеже успехът се изчислява от оценките 
на студента и останалите му данни нямат значение, е по-добре вместо 
Student да се предава като параметър списък от оценки. Така методът 
придобива вида calcAverageResults(List<Mark>).


 -----------------------------   Правилно използване на променливите  -----------------------------  

Връщане на резултат 
Когато връщаме резултат от метод, той трябва да се запази в променлива 
преди да се върне. 

int salary = days * hoursPerDay * ratePerHour; 
return salary;


Има няколко причини да запазваме резултата преди да го видим. Едната е, 
че така документираме кода – по името на допълнителната променлива 
става ясно какво точно връщаме. Другата причина е, че когато дебъгваме 
програмата, ще можем да я спрем в момента, в който е изчислена 
връщаната стойност и ще можем да проверим дали е коректна. Третата 
причина е, че избягваме сложните изрази, които понякога може да са 
няколко реда дълги и заплетени.

 -----------------------------   Инициализиране на член-променливи на обекти  -----------------------------  

Някои обекти, за да бъдат правилно инициализирани, трябва да имат 
стойности на поне няколко техни полета. Например обект от тип Човек, 
трябва да има стойност на полетата "име" и "фамилия". Това е проблем, от 
който компилаторът не може да ни опази. 
Единият начин да бъде решен този проблем е да се премахне конструкторът 
по подразбиране (конструкторът без параметри) и на негово място да се 
сложат един или няколко конструктора, които получават достатъчно данни 
(във формата на параметри) за правилното инициализиране на съответния 
обект. 
Това решение, колкото и да е добро, противоречи на една от основните 
директиви на JavaBeans спецификацията, а именно всеки обект да има 
конструктор по подразбиране. Причината за подобно изискване е, че 
JavaBeans обектите са направени така, че да могат да се използват авто
матично от различни библиотеки. Липсата на конструктор по подразбиране 
би попречила на тези инструменти да създават бързо и лесно такива 
обекти. 
Тази директива не се спазва винаги, но става по-популярна заради все 
повече нови инструменти за автоматична работа с обекти. Например 
последната библиотека в Java 6 за работа с уеб услуги – JAX-WS – има 
подобно изискване. 

Решение би било всеки, които ползва такива обекти, да проверява за 
пълнотата на тези обекти (погледнете секцията за защитно програмиране)  -----------------------------  -----
или обектите да предоставят метод, който проверява това. 


 -----------------------------  ----- Деклариране на променлива в блок/метод  -----------------------------  -----
Променливите да са в началото на метода или класа, където се намира съгласно конвенцията на Sun.

Трябва да се намали възможноста за coupling и да се намали обхвата, затова.
 Ако не знаете какъв обхват да ползвате, започвайте от private и при нужда 
преминавайте към protected или public.

Статичните променливи е най-добре да са винаги private и достъпът до тях 
да става контролирано, чрез извикване на подходящи методи.

 -----------------------------   Диапазон на активност (span) е средният брой линии между обръще  -----------------------------  	
нията към дадена променлива. Той зависи от гъстотата на редовете код, в 
които тази променлива се използва. Диапазонът на променливите трябва 
да е минимален. По тази причина променливите трябва да се декларират и 
инициализират възможно най-близко до мястото на първата им употреба, а 
не в началото на даден метод или блок.

Член-променливите живеят докато 
съществува класът, в който са дефинирани, а статичните променливи – 
докато съществува виртуалната машина.

Декларирайте локалните променливи възможно най-къс
но, непосредствено преди да ги използвате за първи път, 
и ги инициализирайте заедно с декларацията им.

Променливите с по-голям обхват и по-дълъг живот, трябва да имат по
описателни имена, примерно totalStudentsCount. Причината е, че те ще 
бъдат използвани на повече места и за по-дълго време и за какво служат 
няма да бъде ясно от контекста. Променливите с живот няколко реда могат 
да бъдат с кратко и просто име, примерно count.


 -----------------------------   Работа с променливи – още правила  -----------------------------  

Една променлива трябва да се използва само за една цел. Това е много 
важно правило. За да не става объркване в стойностите и мисленето на име на променливата.


Правилно използване на изрази 
При работата с изрази има едно много просто правило: не ползвайте 
сложни изрази! Сложен израз наричаме всеки израз, който извършва 
повече от едно действие. Ето пример за сложен израз:

for (int i=0; i<xCoord.length; i++) { 
	for (int j=0; j<yCoord.length; j++) { 
		matrix[i][j] =  
		matrix[xCoord[findMax(i)+1]][yCoord[findMin(i)+1]] * 
		matrix[yCoord[findMax(i)+1]][xCoord[findMin(i)+1]]; 
	} 
} 

В примерния код имаме сложно изчисление, което запълва дадена матрица 
спрямо някакви изчисления върху някакви координати. Всъщност е много 
трудно да се каже какво точно се случва, защото е използван сложен израз. 


Има много причини, заради които трябва да избягваме използването на 
сложни изрази като в примера по-горе. Ще изброим някои от тях: 
-Кодът трудно се чете. В нашия пример няма да ни е лесно да разберем 
какво прави този код и дали е коректен. 
-Кодът трудно се поддържа. Помислете, какво ще ни струва да 
поправим грешка в този код, ако не работи коректно. 
-Кодът трудно се поправя, ако има дефекти. Ако примерният код по
горе даде ArrayIndexOutOfBoundsException, как ще разберем извън 
границите на кой точно масив сме излезли? Това може да е масивът 
xCoord или yCoord или matrix, а излизането извън тези масиви може да 
е на няколко места. 
-Кодът трудно се дебъгва. Ако намерим грешка, как ще дебъгнем 
изпълнението на този израз, за да намерим грешката? 

Трябва да направим
няколко по-прости изрази и да ги запишем в променливи с разумни имена. 
По този начин кодът става по-прост, по-ясен, по-лесен за четене и 
разбиране, по-лесен за промяна, по-лесен за дебъгване и по-лесен за 
поправяне. Нека сега пренапишем горния код, без да използваме сложни 
изрази: 

for (int i=0; i<xCoord.length; i++) { 
 for (int j=0; j<yCoord.length; j++) { 
  int maxStartIndex = findMax(i) + 1; 
  int minStartIndex = findMax(i) - 1; 
  int minXcoord = xCoord[minStartIndex]; 
  int maxXcoord = xCoord[maxStartIndex]; 
  int minYcoord = yCoord[minStartIndex]; 
  int maxYcoord = yCoord[maxStartIndex]; 
  matrix[i][j] =  
   matrix[maxXcoord][minYcoord] * 
   matrix[maxYcoord][minXcoord]; 
 } 
} 


Не пишете сложни изрази. На един ред трябва да се 
извършва по една операция. Иначе кодът става труден за 
четене, за поддръжка, за дебъгване и за промяна.


 -----------------------------   Използване на константи  -----------------------------  
В добре написания програмен код не трябва да има "магически числа" и 
стрингове. Такива наричаме всички литерали в програмата, които имат 
стойност, различно от 0, 1, -1, "" и null (с дребни изключения). 
За да обясним по-добре концепцията за използване на именувани кон
станти, ще дадем един пример за код, който има нужда от преработка: 
public class MathUtils { 
 public static double calcCircleArea(double radius) { 
  double area = 3.14159206 * radius * radius; 
  return area; 
 } 
 
 public static double calcCirclePerimeter(double radius) {
  double perimeter = 2 * 3.14159206 * radius; 
  return perimeter; 
 } 
  
 public static double calcElipseArea(double axis1,  
   double axis2) { 
  double area = 3.14159206 * axis1 * axis2; 
  return area; 
 } 
 
} 


В примера използваме три пъти числото 3.14159206 (∏), което е повторение 
на код. Ако решим да променим това число, като го запишем например с 
по-голяма точност, ще трябва да променим програмата на три места. 
Възниква идеята да дефинираме това число като стойност, която е глобална 
за програмата и не може да се променя. Именно такива стойности в Java се 
декларират като именувани константи по следния начин:

public static final double PI = 3.14159206; 

След тази декларация константата PI е достъпна от цялата програма и може 
да се ползва многократно. При нужда от промяна променяме само на едно 
място и промените се отразяват навсякъде. Ето как изглежда нашия 
примерен клас MathUtils след изнасянето на числото 3.14159206 в кон
станта: 

public class MathUtils { 
 public static final double PI = 3.14159206; 
 
 public static double calcCircleArea(double radius) { 
  double area = PI * radius * radius; 
  return area; 
 } 
 
 public static double calcCirclePerimeter(double radius) { 
  double perimeter = 2 * PI * radius; 
  return perimeter; 
 } 
  
 public static double calcElipseArea(double axis1, 
   double axis2) { 
  double area = PI * axis1 * axis2; 
  return area; 
 } 
} 

стр 752

 -----------------------------   Кога да използваме константи?  -----------------------------  

Константи трябва да дефинираме винаги, когато имаме нужда да ползваме 
числа или символни низове, за които не е очевидно от къде идват и какъв 
е логическият им смисъл. Константи е нормално да дефинираме и за всяко 
число или символен низ, който се ползва повече от веднъж в програмата. 

-За имена на файлове, с които програмата оперира. Те често трябва да 
се променят и затова е много удобно да са изнесени като константи в 
началото на програмата. 
-За константи, участващи в математически формули и преобразувания. 
Доброто име на константата подобрява шансът при четене на кода да 
разберете смисъла на формулата. 
-За размери на буфери или блокове памет. Тези размери може да се 
наложи да се променят и е удобно да са изнесени като константи. 
Освен това използването на константата READ_BUFFER_SIZE вместо 
някакво магическо число 8192 прави кода много по-ясен и разбираем.

 -----------------------------   Кога да не използваме константи?  -----------------------------   

-Съобщения за грешки и други съобщения към потребителя (примерно 
"въведете името си"): изнасянето им затруднява четенето на кода 
вместо да го улесни. 
-SQL заявки (ако използвате бази от данни, командите за извличане 
на информацията от базата данни се пише на езика SQL и пред
ставлява стринг). Изнасянето на SQL заявки като константи прави 
четенето на кода по-трудно и не се препоръчва.

- Заглавия на бутони, диалози, менюта и други компоненти от 
потребителския интерфейс също не се препоръчва да се изнасят като 
константи, тъй като това прави кода по-труден за четене.

Използвайте именувани константи, за да избегнете изпол
зването и повтарянето на магически числа и стрингове в 
кода и най-вече, за да подобрите неговата четимост. Ако 
въвеждането на именувана константа затруднява чети
мостта на програмата, по-добре оставете твърдо зададе
ната стойност в кода! 


 -----------------------------   Правилно използване на условни конструкции  -----------------------------  

Лошия пример е в учебника с вложени цикли, а това долу е добрия.

стр755
- кода трябва да е четим  
if (maxElem != Integer.MAX_VALUE) { 
	maxElem = findMax(arr, i); 
} 
 
private static int findMax(int[] arr, int i) { 
	 if (arr[i] < arr[i + 1]) { 
		int maxElem = max(arr[i + 1], arr[i + 2], arr[i + 3]); 
		return maxElem; 
	 } else { 
		int maxElem = max(arr[i], arr[i + 2], arr[i + 3]); 
		return maxElem; 
	 } 
} 
 
private static int max(int i, int j, int k) { 
	 if (i < j) { 
		  int maxElem = max(j, k); 
		  return maxElem; 
	 } else { 
		  int maxElem = max(i, k); 
		  return maxElem; 
	 } 
} 
 
private static int max(int i, int j) { 
	 if (i < j) { 
		return j; 
	 } else { 
		return i; 
	 } 
} 

 -----------------------------   Избиране на подходящ вид цикъл  -----------------------------  

При определен брой пъти for цикъл.

 Този цикъл се използва в прости случаи, 
когато не се налага да прекъсваме изпълнението. 

Ако е необходимо да следим някакви условия, при които да прекратим 
изпълнението на цикъла, тогава вероятно е по-добре да използваме while 
цикъл. while цикълът е подходящ в случаи, когато не знаем колко точно 
пъти трябва да се изпълни тялото цикъла. При него изпълнението 
продължава, докато не се достигне дадено условие за край. 

 -----------------------------   Не влагайте много цикли  -----------------------------  

 Такъв код лесно може 
да се подобри, като се отдели част от логиката в отделен метод. Съвре
менните среди за разработка могат да правят такава преработка на кода 
автоматично .

 -----------------------------   Защитно програмиране   -----------------------------  
Защитно програмиране (defensive programming) е термин обозначаващ 
практика, която е насочена към защита на кода от некоректни данни. 
Защитното програмиране пази кода от грешки, които никой не очаква. То 
се имплементира чрез проверка на коректността на всички входни данни. 
Това са данните, идващи от външни източници, входните параметри на 
методите, конфигурационни файлове и настройки, данни въведени от пот
ребителя, дори и данни от друг локален метод. 
Защитното програмиране изисква всички данни да се проверяват, дори да 
идват от източник, на когото се вярва. По този начин, ако в този източник 
има грешка (бъг), то тя ще бъде открита по-бързо. 
Защитното програмиране се имплементира чрез assertions, изключения и 
други средства за управление на грешки.

 -----------------------------   Assertions  -----------------------------   
Това е специална конструкция в Java, която позволява имплементацията на 
защитно програмиране. Появяват се в JDK 1.4. Ето един бърз пример: 

public int archive(PersonData user, boolean persistent) { 
	assert user != null; 
	// Do some processing 
	int resultFromProcessing = ... 
	assert resultFromProcessing >= 0 :
	"resultFromProcessing is negative. There is a bug"; 
	return resultFromProcessing; 
} 

От кода се виждат два различни начина на употреба на assert: 
assert <condition>; 
и 
assert <condition> : <message>; 

Във втория вариант има допълнителен обяснителен текст. 
Основната идея на тази конструкция е да достави код, който е по-четим и 
от който бъговете се изчистват по-бързо по време на разработка. Кон
струкцията се слага на места, на които имаме някакви ограничителни 
условия за дадена променлива. В нашия пример, ако методът archive се 
използва само вътрешно, то не би трябвало никой да го извика с null вместо 
с инстанция на PersonData.

Слагайки assert все едно казваме "тук със сигурност тази променлива не е 
null". Ако някой assert не мине (т.е. условието в него не е изпълнено), се 
генерира грешка от тип AssertionException. 

Assertions могат да се изключват. По замисъл те трябва да са включени само 
по време на разработка, докато се открият всички бъгове. Когато бъдат 
изключени всички проверки в тях спират да се изпълняват. Идеята на 
изключването е, че след края на разработката, тези проверки не са повече 
нужни и само забавят софтуера. 
Assertions по подразбиране са изключени. За да се включат, се подава 
специален параметър на виртуалната машина -ea: 

java –ea introjavabook.Storage 

Ако дадена проверка е смислено да продължи да съществува след края на 
разработката (примерно проверява входни данни на метод, които идват от 
потребителя), то тази проверка е неправилно имплементирана с assertions 
и трябва да бъде имплементирана с изключения.

Assertions се използват само на места, на които трябва 
дадено условие да бъде изпълнено и единствената при
чина да не е, е да има бъг в програмата.


 -----------------------------   Защитно програмиране с изключения  -----------------------------  

Изключенията (exceptions) предоставят мощен механизъм за централизи
рано управление на грешки и непредвидени ситуации. В главата "Обра
ботка на изключения" те са описани подробно. 

Разликата между изключенията и assertions е в това, че изключенията в 
защитното програмиране се използват най-вече за защитаване на публич
ния интерфейс на един компонент. Този механизъм се нарича fail-safe (в 
свободен превод "проваляй се грациозно" или "подготвен за грешки").

public int archive(PersonData user, boolean persistent) { 
if (user == null) 
throw new StorageException("null parameter"); 
// Do some processing 
int resultFromProcessing = ... 
assert resultFromProcessing >= 0 : 
"resultFromProcessing is negative. There is a bug"; 
return resultFromProcessing; 
} 
Вторият assert остава, тъй като той е предвиден за променлива създадена 
вътре в метода. 
Изключенията трябва да се използват, за да се уведомят другите части на 
кода за проблеми, които не трябва да бъдат игнорирани. Хвърлянето на 
изключение е оправдано само в ситуации, които наистина са изключителни 
и трябва да се обработят по някакъв начин.

Ако даден проблем може да се обработи локално, то обработката трябва да 
се направи в самия метод и изключение не трябва да се хвърля. Ако даден 
проблем не може да се обработи локално, той трябва да бъде прехвърлен 
към извикващия метод чрез throws декларация.


Трябва да се хвърлят изключения с подходящо ниво на абстракция. 
Пример: getEmplyeeInfo() може да хвърля EmployeeException, но не и 
FileNotFoundException. Погледнете последният пример, той хвърля 
StorageException, а не NullPointerException. 


Повече за добрите практики при управление на изключенията можете да 
прочетете от секцията "Добри практики при работа с изключения" на 
главата "Обработка на изключения".

 -----------------------------   Документация на кода  -----------------------------  

В Java има специална нотация за писане на коментари. Нарича се JavaDoc. 
Ето един пример: 

/** 
* A class representing a thread pool. It works with {@link 
* Thread}s that it keeps alive for reuse. 
*  
* Usage: 
* <code> 
*  
TreadPool pool = new ThreadPool(); 
* </code> 
*  
* @author Mihail Stoynov 
* @version 1.0 
* @see java.lang.Thread 
*/ 
public class ThreadPool { 
/** Some comment here */ 
public static final int MAX_POOL_SIZE = 16; 
} 


JavaDoc коментарите се различават от обикновените коментари. Те 
започват с /** вместо с /*. JavaDoc коментарите няма съкратен запис за 
разлика от обикновените коментари (//Text). Забележете възможността да 
пишете HTML тагове директно в документацията – той ще се появи на 
генерираните страници. JavaDoc позволява и група специални думи, които 
започват с @. За тях можете да научите повече от документацията на Java 
на сайта на Sun.

От JavaDoc документацията могат автоматично да се създават HTML 
страници със съдържанието на коментарите, което е много полезно: 


 -----------------------------   Самодокументиращ се код  -----------------------------  

Коментарите в кода не са основният източник на документация. Запомнете 
това! Добрият стил на програмиране е най-добрата документация! Само
документиращ се код е такъв, на който лесно се разбира основната му цел, 
без да е необходимо да има коментари.

Най-добрата документация на кода е да пишем качествен 
код. Лошият код не трябва да се коментира, а трябва да се 
пренапише, така че сам да описва себе си. Коментарите в 
програмата само допълват документацията на добре 
написания код. 

 -----------------------------   Характеристики на самодокументиращия се код  -----------------------------  

Характеристики на самодокументиращия се код са добра структура на 
програмата – подравняване, организация на кода, използване на ясни и 
лесни за разбиране конструкции, избягване на сложни изрази. Такива са 
още употребата на подходящи имена на променливи, методи и класове и 
употребата на именувани константи, вместо “магически" константи и
текстови полета. Реализацията трябва да е опростена максимално, така че 
всеки да я разбере. 

Самодокументиращ се код – важни въпроси 
Въпроси, които трябва да си зададем преди да отговорим на въпроса дали 
кодът е самодокументиращ се: 
-Подходящо ли е името на класа и показва ли основната му цел? 
-Става ли ясно от интерфейса как трябва да се използва класа? 
-Показва ли името на метода основната му цел? 
-Всеки метод реализира ли една добре определена задача? 
-Имената на променливите съответстват ли на тяхната употреба? 
-Групирани ли са свързаните един с друг оператори? 
-Само една задача ли изпълняват конструкциите за итерация 
(циклите)? 
-Има ли дълбоко влагане на условни конструкции? 
-Показва ли организацията на кода неговата логическата структура? 
-Дизайнът недвусмислен и ясен ли е? 
-Скрити ли са детайлите на имплементацията възможно най-много? 


  -----------------------------   "Ефективни" коментари  -----------------------------  

Коментарите понякога могат да навредят повече, отколкото да помогнат. 
Добрите коментари не повтарят кода и не го обясняват – те изясняват 
неговата идея. Коментарите трябва да обясняват на по-високо ниво какво 
се опитваме да постигнем. Писането на коментари помага да осмислим по
добре това, което искаме да реализираме. 

Ето един пример за лоши коментари, които повтарят кода и вместо да го 
направят по-лесно четим, го правят по-тежък за възприемане: 

Ако вместо да слагаме наивни коментари, ги ползваме, за да изясним 
неочевидните неща в кода, те могат да са много полезни. Вижте как бихме 
могли да коментираме същия код, така че да му подобрим четимостта: 

str 764
/** 
 * @return a list of all primes in given range [start, end]. 
 * A number num is prime if it can not be divided to any number 
 * in the range [2, sqrt(num)]. We check condition this for all 
 * numbers in the given range. 
 */ 
public static ArrayList<Integer> getPrimes(int start, int end) { 
	 ArrayList<Integer> primesList = new ArrayList<Integer>(); 
	 for (int num = start; num <= end; num++) { 
	  boolean prime = true; 
	  for (int div = 2; div <= Math.sqrt(num); div++) { 
	   if (num % div == 0) { 
		// Found a divider -> num is not prime 
		prime = false; 
		break; 
	   } 
	  } 
		if (prime) { 
			primesList.add(num); 
		} 
	} 
	return primesList; 
} 

В случая единственият неочевиден въпрос е защо пробваме да търсим 
делители в диапазона от 2 до sqrt(num). Ако се слага коментар, той трябва 
да изясни този въпрос. Останалото е очевидно от кода. Имената на 
променливите са ясни и сами говорят за себе си. Логиката на кода е 
очевидна и няма нужда от коментари. Достатъчно е да се опише за какво 
служи даденият метод и основната му идея (как работи) в едно изречение. 
При писането на "ефективни" коментари е добра практика да се използва 
псевдокод, когато е възможно. Коментарите трябва да се пишат, когато се 
създава самия код, а не след това. 
Продуктивността никога не е добра причина, за да не се пишат коментари. 
Трябва да се документира всичко, което не става ясно от кода. Поставянето 
на излишно много коментари е толкова вредно колкото и липсата на такива. 
Лошият код не става по-добър с повече коментари. За да стане добър код, 
просто трябва да се преработи. 


 -----------------------------   Преработка на кода (Refactoring)  -----------------------------  

Дадена програма се нуждае от преработка, при повторение на код. Повто
рението на код е опасно, защото когато трябва да се променя, трябва да се 
променя на няколко места и естествено някое от тях може да бъде 
пропуснато и така да се получи несъответствие. Избягването на повтарящ 
се код може да стане чрез изваждане на метод или преместване на код от 
клас-наследник в базов клас. 

Преработка се налага и при методи, които са нараснали с времето. 
Прекалената дължината на метод е добра причина да се замислим дали 
методът не може да се раздели логически на няколко по-малки и по-прости 
метода. 

При цикъл с прекалено дълбоко ниво на влагане трябва да се замислим 
дали не можем да извадим в отделен метод част от кода му. Обикновено 
това подобрява четимостта на кода и го прави по-лесен за разбиране. 

Преработката е наложителна при клас, който изпълнява несвързани отго
ворности (poor cohesion). Клас, който не предоставя достатъчно добро ниво 
на абстракция също трябва да се преработи. 

Дългият списък с параметри и публичните полета също трябва да са в 
графата "да се поправи". Тази графа трябва да допълни и когато една 
промяна налага да се променят паралелно още няколко класа. Прекалено 
свързани класове или недостатъчно свързани класове също трябва да се 
преработят.

 -----------------------------   Преработка на код на ниво данни  -----------------------------  
Добра практика е в кода да няма "магически" числа. Те трябва да бъдат 
заменени с константи. Променливите с неясни имена трябва да се преиме
нуват. Дългите условни изрази могат да бъдат преработени в отделни 
методи. За резултата от сложни изрази могат да се използват междинни 
променливи. Група данни, които се появяват заедно могат да се преработят 
в отделен клас. Свързаните константи е добре да се преместят в изброими 
типове (enumerations). 

Добра практика е всички задачи от един по-голям метод, които не са 
свързани с основната му цел, да се "преместят" в отделни методи (extract 
method). Сходни задачи трябва да се групират в общи класове, сходните 
класове – в общ пакет. Ако група класове имат обща функционалност, то 
тя може да се изнесе в базов клас. 

Не трябва да има циклични зависимости между класовете – те трябва да се 
премахват. Най-често по-общият клас има референция към по-специа
лизирания (връзка родител-деца). 

 -----------------------------   Глава 22. Как да решаваме задачи по програмиране? -----------------------------

 ----------------------------- Основни принципи при решаване на задачи по програмиране -----------------------------
 
 -----------------------------  Използвайте лист и химикал!   ----------------------------- 
 
 Захващането на лист и химикал и скицирането на примери и разсъждения 
по дадения проблем е нещо съвсем нормално и естествено – нещо, което 
всеки опитен математик, физик или софтуерен инженер прави, когато му 
поставят нетривиална задача. 

Важния извод е , че 
използването на някаква форма на чертеж, скица или визуализация на 
проблема е от решаваща полза за неговото решаване.

 ----------------------------- Правило -----------------------------
Който не ползва лист и химикал, ще бъде силно затруднен 
при решаването на задачи по програмиране. Винаги ски
цирайте идеите си на хартия или на дъската! 

 ----------------------------- Правило -----------------------------
 
 Наистина, изглежда старомодно, но ерата на хартията все още не е 
отминала! Най-лесният начин човек да си скицира идеите и разсъжденията 
е като хване лист и химикал, а без да скицирате идеите си, е много трудно 
да разсъждавате. 

Помислете например колко усилия ви трябват, за да умножавате 
петцифрени числа на ум и колко по-малко са усилията, ако имате лист и 
химикал.

 Когато трябва да проверите дали 
решението ви е вярно, ви трябва отново хартия, да си разпишете един 
пример. Когато трябва да измисляте случаи, които вашето решение 
изпуска, отново ви трябва нещо, на което да си разписвате и драскате 
примери и идеи. Затова ползвайте лист и химикал!


 ----------------------------- Измислете идеи и ги пробвайте! -----------------------------
 
 Решаването на дадена задача винаги започва от скицирането на някакъв 
пример върху лист хартия. Когато имате конкретен пример, можете да 
разсъждавате, а когато разсъждавате, ви хрумват идеи за решение на 
задачата.

Когато вече имате идея, ви трябват още примери, за да проверите дали 
идеята е добра. Тогава можете да нарисувате още няколко примера на 
хартия и да пробвате вашата идея върху тях. Уверете се, че идеята ви е 
вярна. Проследете идеята стъпка по стъпка, така, както ще я изпълни 
евентуална компютърна програма и вижте дали няма някакви проблеми. 

Опитайте се да "счупите" вашата идея за решение – да измислите пример, 
при който не работи (контра-пример). Ако не успеете, вероятно сте на прав 
път. Ако успеете, помислете как да се справите с неработещия пример: 
измислете "поправка" на вашата идея за алгоритъм или измислете напълно 
нова идея. 
За всичко това ви трябват лист, химикал и примери, които да измисляте и 
да си ги рисувате, след което да си пробвате върху тях различните идеи, 
които ви хрумват. 

 ----------------------------- Правило -----------------------------
Решаването на задачи по програмиране започва от измис
лянето на идеи и проверяването им. Това става най-лесно 
като хванете лист и химикал и скицирате разсъжденията 
си. Винаги проверявайте идеите си с подходящи примери! 
 ----------------------------- Правило -----------------------------
 
 Горните препоръки са много полезни и в още един случай: когато сте на 
интервю за работа. Всеки опитен интервюиращ може да потвърди, че когато 
даде алгоритмична задача на кандидат за работа, очаква от него да хване 
лист и химикал и да разсъждава на глас като предлага различни идеи, 
които му хрумват. Хващането на лист и химикал на интервю за работа дава 
признаци за мислене и правилен подход за решаване на проблеми. 
Разсъждаването на глас показва, че можете да мислите. Дори и да не 
стигнете до правилно решение подходът към решаване на задачи ще 
направи добро впечатление на интервюиращия! 

----------------------------- Разбивайте задачата на подзадачи! 

  Рецептата за решаване на сложни задачи е да се 
разбият логически на няколко по-прости (по възможност максимално 
независими една от друга). Ако и те се окажат сложни, можем да разбием 
и тях на няколко по-прости.

Тънкостта на решаване на алгоритмични задачи се крие в това да овладеете 
добре техниката на разбиването на задачата на по-прости подзадачи и, 
разбира се, да се научите да ви хрумват добри идеи, което става с много, 
много практика. 

 -----------------------------Правило-----------------------------
Сложните проблеми винаги могат да се разделят на 
няколко по-прости. Когато решавате задачи, разделяйте 
сложната задача на по-прости, задачи, които могат да се 
решат самостоятелно. 
 -----------------------------Правило-----------------------------
 
 
 ----------------------------- Разбъркване на тесте карти – пример ----------------------------- 
 ----------------------------- стр 772  -----------------------------
 
 Ако намерим 
начин да разбием сложната задача на множество простички стъпки, значи 
сме намерили начин да я решим. Именно в това се състои алгоритмичното 
мислене: в умението да разбиваме сложен проблем на серия по-прости 
проблеми, за които можем да намерим решение.

Проверете идеите си! 
 ----------------------------- стр 775  -----------------------------

Как да проверим идеята си? Обикновено това става с някакъв пример или 
с няколко примера. Трябва да подберете такива, примери, които в пълнота 
покриват различните случаи, които вашия алгоритъм трябва да преодолее. 
Примерите трябва хем да не са лесни за вашия алгоритъм, хем да са 
достатъчно прости, за да ги разпишете бързо и лесно. Такива примери 
наричаме "добри представители на общия случай".

Когато проверявате идеите си подбирайте подходящи 
примери. Те трябва хем да са прости и лесни за разпис
ване, хем да не са частен случай, при който вашата идея 
би могла да работи, но да е грешна в общия случай. 
Примерите, които избирате, трябва да са добри 
представители на общия случай – да покриват възможно 
повече случаи, без да са големи и сложни. 

----------------------------- примера с картите и тестването на кода стр 776 -----------------------------

Няма нужда да правим 6 разцепвания. Вижда се, че след 3 размествания се 
върнахме в изходна позиция. Това едва ли е случайно. Какво стана? 
Открихме проблем в алгоритъма. Изглежда, че нашата идея е грешна. Като 
се замислим малко, се вижда, че всяко единично разместване през 
случайната позиция k всъщност ротира наляво тестето карти k пъти и след 
общо N ротации стигаме до изходна позиция. Добре, че тествахме на ръка 
алгоритъма преди да сме написали програмата, нали? 

----------------------------- При проблем измислете нова идея! -----------------------------

Нормално е, след като намерим проблем в нашата идея, да измислим нова 
идея, която би трябвало да работи. Това може да стане по два начина: или 
да поправим старата си идея, като отстраним дефектите в нея, или да 
измислим напълно нова идея. Нека видим как това работи за нашата задача 
за разбъркване на карти. 

----------------------------- Правило -----------------------------
Измислянето на решение на задача по програмиране е 
итеративен процес, който включва последователно
измисляне на идеи, изпробването им и евентуално 
замяната им с по-добри идеи при откриване на проблем. 
Понякога още първата идея е правилна, а понякога 
пробваме и отхвърляме една по една много различни идеи 
докато стигнем до идея, която да ни свърши работа. 
----------------------------- Правило -----------------------------

В този момент ни хрумва нова като че ли по-добра идея. Не е ли по-лесно 
на всяка стъпка да вземем случайна карта и да я разместим с първата? 
Изглежда по-просто и по-лесно за реализация, а резултатът би трябвало 
пак да е случаен. Първоначално ще разменим карта от случайна позиция 
k1 с първата карта. Ще имаме случайна карта на първа позиция и първата 
карта ще бъде на позиция k1. На следващата стъпка ще изберем случайна 
карта на позиция k2 и ще я разменим с първата карта (картата от позиция 
k1). Така вече първата карта си е сменила позицията, картата от позиция 
k1 си е сменила позицията и картата от позиция k2 също си е сменила 
позицията. Изглежда, че на всяка стъпка по една карта си сменя позицията 
със случайна. След такива N стъпки можем да очакваме всяка карта средно 
по веднъж да си е сменила мястото и следователно картите би трябвало да 
са добре разбъркани. 


----------------------------- Подберете структурите от данни! -----------------------------

След като по горе в учебника по скоро сме помислили за разместването на картите,
 разписали сме го и сме го тествали. Идва ред да напишем кода.
 
Сега трябва да подберем подходящи 
структури от данни, с които да реализираме идеите си.

----------------------------- Правило -----------------------------
Преди да преминете към имплементация на вашата идея 
помислете за структурите от данни. Може да се окаже, че 
вашата идея не е толкова добра, колкото изглежда. Може 
да се окаже, че е трудна за реализация или неефективна. 
По-добре да откриете това сега, отколкото по-късно.  
----------------------------- Правило -----------------------------
 
----------------------------- В каква структура да пазим тестето карти? -----------------------------
 
 Имаме съвкупност от карти и наредбата на картите в тази 
структура е от значение. Следователно трябва да използваме структура, 
която съхранява съвкупност от елементи и запазва наредбата им.

Подходяща структура ли е масивът? За да си отговорим на този въпрос, 
трябва да помислим какво трябва да правим с тестето карти, записано в 
масив и да проверим дали всяка от необходимите ни операции може да се 
реализира ефективно с масив. 
Кои са операциите с тестето карти, които ще ни се наложи да реализираме 
за нашия алгоритъм? Нека ги изброим: - - - 
Избор на случайна карта. Понеже в масива имаме достъп до 
елементите по индекс, можем да изберем случайно място в него 
(вдясно от първата позиция) чрез избор на случайно число k в 
интервала от 1 до N-1. 
Размяна на карта на позиция k с първата карта (единично 
разместване). След като сме избрали случайна карта, трябва да я 
разменим с първата. И тази операция изглежда проста. Можем да 
направим размяната на три стъпки чрез временна променлива. 
Въвеждане на тестето / обхождане на картите от тестето / отпечатване 
на тестето – всички тези операции биха могли да ни потрябват, но 
изглежда тривиално да ги реализираме с масив. 
Изглежда, че масивът може да ни свърши работа са съхранение на тесте 
карти.

----------------------------- Можем ли да ползваме друга структура?

Все пак, нека помислим можем ли да изберем по-подходяща структура от 
масив. Нека помислим какви са възможностите ни:


- - - - - 
Свързан списък – нямаме директен достъп по номер на елемент и ще 
ни е трудно да избираме от списъка случайна карта. 
Статичен списък с променлива дължина (ArrayList) – изглежда, че 
притежава всички предимства на масивите и може да реализира 
всички операции, които ни трябват, по същия начин, както с масив. 
Печелим малко удобство – в ArrayList можем лесно да трием и 
добавяме, което може да улесни въвеждането на картите и някои 
други помощни операции. 
Стек / опашка – тестето карти няма поведение на FIFO / LIFO и 
следователно тези структури не са подходящи. 
Множество (TreeSet / HashSet) – в множествата няма наредба и това е 
съществена пречка, за да ги използваме. 
Хеш-таблица – структурата "тесте карти" не е от вида ключ-стойност 
и следователно хеш-таблицата не може да го съхранява и обработва 
ефективно. Освен това хеш-таблиците не запазват подредбата на 
елементите. 

Общо взето изчерпахме основните структури от данни, които съхраняват и 
обработват съвкупности от елементи и стигнахме до извода, че масив или 
ArrayList ще ни свършат работа, а ArrayList е по-гъвкав и удобен от 
обикновения масив. Взимаме решение да ползваме ArrayList за съхране
нието и обработката на тестето карти.

----------------------------- Правило -----------------------------
Изборът на структура данни започва с изброяване на клю
човите операции, които ще се извършват върху нея. След 
това се анализират възможните структури, които могат да 
бъдат използвани и от тях се избира тази, която най-лесно 
и ефективно реализира тези операции. Понякога се прави 
компромис между леснота на реализация и ефективност. 
----------------------------- Правило -----------------------------


----------------------------- Как да пазим другите информационни обекти? -----------------------------

Преди да навлезем в дълбоки разсъждения кое представяне е най-добро, 
нека се върнем на условието на задачата. То предполага, че тестето карти 
ни е дадено (като масив или списък) и трябва да го разместим. Какво точно
представлява една карта няма никакво значение за тази задача. Дори няма 
значение дали разместваме карти за игра, фигури за шах, кашони с домати 
или някакви други обекти. Имаме наредена последователност от обекти и 
трябва да я разбъркаме. Фактът, че разбъркваме карти, няма значение за 
нашата задача и няма нужда да губим време да мислим как точно да 
представим една карта. Нека просто се спрем на първата идея, която ни 
хрумва, примерно да си дефинираме клас Card с полета face и suit. Дори да 
изберем друго представяне (примерно число от 1 до 52), това не е 
съществено. Няма да дискутираме повече този въпрос.

----------------------------- Сортиране на числа – подбор на структурите данни -----------------------------

Преди да продължим нататък, нека разгледаме още един пример, при който 
имаме нужда от избор на структури от данни. Нека имаме задачата за 
сортиране по големина на съвкупност от числа. Нека сме избрали да 
използваме най-простия алгоритъм, за който сме се сетили: да взимаме 
докато може най-малкото число, да го отпечатваме и да го изтриваме. Тази 
идея лесно се разписва на хартия и лесно се убеждаваме, че е коректна. 
Каква структура от данни да ползваме за съхранение на числата? Отново, 
за да си отговорим на този въпрос, е необходимо помислим какви операции 
имаме да извършваме върху тези числа. Операциите са следните: - - 
Търсене на най-малка стойност в структурата. 
Изтриване на намерената най-малка стойност от структурата. 
Очевидно използването на масив не е разумно, защото не разполагаме с 
операцията "изтриване". Използването на ArrayList изглежда по-добре, 
защото и двете операции можем да реализираме сравнително просто и 
лесно. Структури като стек и опашка няма да ни помогнат, защото нямаме 
LIFO или FIFO поведение. От хеш-таблица няма особен смисъл, защото в 
нея няма бърз начин за намиране на най-малка стойност, въпреки че 
изтриването на елемент би могло да е по-ефективно. 
Стигаме до структурите HashSet и TreeSet. Множествата имат проблема, че 
не поддържат възможност за съхранение на еднакви елементи. Въпреки 
това, нека ги разгледаме. Структурата HashSet не представлява интерес, 
защото при нея отново нямаме лесен начин да намерим най-малкия 
елемент. Обаче структурата TreeSet изглежда обещаваща. Нека я 
разгледаме. 
Класът TreeSet според документацията на Java държи елементите си в 
балансирано дърво и поддържа операцията "изваждане на най-малкия 
елемент". Колко интересно! Хрумва ни нова идея: вкарваме всички 
елементи в TreeSet и изкарваме от него итеративно най-малкия елемент 
докато елементите свършат. Просто, лесно и ефективно. Имаме наготово 
двете операции, които ни интересуват (търсене на най-малък елемент и 
изтриването му от структурата) в методите first() и remove().

Докато си представяме конкретната имплементация и се ровим в докумен
тацията прочитаме нещо още по-интересно: класът TreeSet държи 
вътрешно елементите си подредени по големина. Ами нали това се иска в 
задачата: да наредим елементите по големина. Следователно, ако ги 
вкараме в TreeSet и след това обходим елементите му (чрез неговия 
итератор), те ще бъдат подредени по големина. Задачата е решена. 
Докато се радваме, се сещаме за един забравен проблем: TreeSet не 
поддържа еднакви елементи, т.е. ако имаме числото 5 няколко пъти, то ще 
се появи в множеството само веднъж. В крайна сметка при сортирането ще 
загубим безвъзвратно някои от елементите. 
Естествено е да потърсим решение на този проблем. Ако има начин да пазим 
колко пъти се среща всеки елементи от множеството, това ще ни реши 
проблема. Тогава се сещаме за класа TreeMap. Той съхранява множество 
ключове, които са подредени по големина и във всеки ключ можем да имаме 
стойност. В стойността можем да съхраняваме колко пъти се среща даден 
елемент. Изглежда това решава проблема ни и можем да го реализираме, 
макар и не толкова лесно, колкото с ArrayList или с TreeSet. 
Ако прочетем внимателно документацията за TreeMap, ще видим, че този 
клас вътрешно използва черно-червено дърво (каквото и да е това) и може 
някой ден да се досетим, че неусетно чрез разсъждения сме достигнали до 
добре 
известния 
алгоритъм 
"сортиране 
(http://en.wikipedia.org/wiki/Binary_tree_sort). 
чрез 
дърво" 
Видяхте до какви идеи ви довеждат разсъжденията за избор на подходящи 
структури от данни за имплементация на вашите идеи. Тръгвате от един 
алгоритъм и неусетно измисляте нов, по-добър. Това е нормално да се 
случи в процеса на обмисляне на алгоритъма и е добре да се случи в този 
момент, а не едва когато сте написали вече 300 реда код, който ще се 
наложи да преправяте. Това е още едно доказателство, че трябва да 
помислите за структурите от данни преди да почнете да пишете кода. 


----------------------------- Помислете за ефективността!  стр 783 -----------------------------

----------------------------- Правило -----------------------------
За ефективността трябва да се помисли още преди да се 
напише първи ред програмен код. Иначе рискувате да 
загубите много време за реализация на идея, която не 
върши работа.
----------------------------- Правило -----------------------------


Имаме идея за решаване на задачата (измислили сме алгоритъм). Идеята 
изглежда коректна (пробвали сме я с примери). Идеята изглежда, че може 
да се реализира (ще ползваме ArrayList за тестето карти и клас Card за
представянето на една карта). Обаче, нека помислим колко карти ще 
разбъркваме и дали избраната идея, реализирана с избраните структури от 
данни, ще работи достатъчно бързо. 

----------------------------- Как оценяваме бързината на даден алгоритъм? -----------------------------

За 52 карти нашият алгоритъм прави 52 единични размествания, нали така? 
Колко елементарни операции отнема едно единично разместване? 
Операциите са 4: избор на случайна карта; запазване на първата карта във 
временна променлива; запис на случайната карта на мястото на първата; 
запис на първата карта (от временната променлива) на мястото, където е 
била случайната карта. Колко операции прави общо нашият алгоритъм за 
52 карти? Операциите са приблизително 52 * 4 = 208. 

Въпреки, че в реалността рядко играем с повече от 1 или 2 тестета карти, 
нека се замислим колко време ще отнеме да разбъркаме голям брой карти, 
да кажем 50 000? Ще имаме 50 000 единични размествания по 4 операции 
за всяко от тях или общо 200 000 операции, които ще се изпълнят на 
момента, без да се усети каквото и да е забавяне. 

----------------------------- Ефективността е въпрос на компромис -----------------------------

В крайна сметка правим извода, че алгоритъмът, който сме измислили е 
ефективен и ще работи добре дори при голям брой карти. Имахме късмет. 
Обикновено нещата не са толкова прости и трябва да се прави компромис 
между бързодействие на алгоритъма и усилията, които влагаме, за да го 
измислим и имплементираме. Например, ако сортираме числа, можем да го 
направим за 5 минути с първия алгоритъм, за който се сетим, но можем да 
го направим и много по-ефективно, за което ще употребим много повече 
време (да търсим и да четем из дебелите книги и в Интернет). В този момент 
трябва да се прецени струва ли си усилията. Ако ще сортираме 20 числа, 
няма значене как ще го направим, все ще е бързо, дори с най-глупавия 
алгоритъм. Ако сортираме 20 000 числа вече алгоритъмът има значение, а 
ако сортираме 20 000 000 числа, задачата придобива съвсем друг 
характер. Времето, необходимо да реализираме ефективно сортиране на 
20 000 000 числа е далеч повече от времето да сортираме 20 числа, така 
че трябва да помислим струва ли си.

----------------------------- Правило -----------------------------
Ефективността е въпрос на компромис – понякога не си 
струва да усложняваме алгоритъма и да влагаме време и 
усилия, за да го направим по-бърз, а друг път бързината е 
ключова изискване и трябва да й обърнем сериозно 
внимание. 
----------------------------- Правило -----------------------------

----------------------------- Сортиране на числа – оценяване на ефективността -----------------------------

Да се върнем отново на въпроса за избор на структура от данни за 
съхранение на числата, които трябва да сортираме по големина в нараст
ващ ред. Дали да изберем ArrayList или TreeMap? Не е ли по-добре да 
ползваме някаква проста структура, която добре познаваме, отколкото 
някоя сложна, която изглежда, че ще ни свърши работата малко по-добре. 
Вие познавате ли добре черно-червените дървета (вътрешната имплемен
тация на TreeMap)? С какво са по-добри от ArrayList? Всъщност може да се 
окаже, че няма нужда да си отговаряте на този въпрос. 

Ако, обаче трябва да сортирате 300 000 числа, нещата са съвсем различни. 
Тогава ще трябва внимателно да проучите как работи класът TreeMap и 
колко бързо става добавянето и търсенето в него, след което ще трябва да 
оцените ориентировъчно колко операции ще са нужни за 300 000 доба
вяния на число и след това колко още операции ще отнеме обхождането. 
Ще трябва да прочетете документацията, където пише, че добавянето 
отнема средно log2(N) операции, където N е броят елементи в структурата. 
Чрез дълги и мъчителни сметки (за които ви трябват допълнителни умения) 
може да оцените грубо, че ще са необходими около 5-6 милиона стъпки за 
цялото сортиране, което е приемливо бързо.

По аналогичен път, можете да се убедите, че търсенето и изтриването в 
ArrayList с N елемента отнема N стъпки и следователно за 300 000 
елемента ще ни трябват приблизително 2 * 300 000 * 300 000 стъпки! 
Всъщност това число е силно закръглено нагоре, защото в началото нямате 
300 000 числа, а само 1, но грубата оценка е пак приблизително вярна. 
Получава се екстремално голям брой стъпки и простичкият алгоритъм няма 
да работи за такъв голям брой елементи (програмата мъчително ще увисне). 

Отново стигаме до въпроса с компромиса между сложния и простия 
алгоритъм. Единият е по-лесен за имплементиране, но е по-бавен. Другият
е по-ефективен, но е по-сложен за имплементиране и изисква да четем 
документация и дебели книги, за да разберем колко бързо ще работи. 
Въпрос на компромис.

----------------------------- Имплементирайте алгоритъма си! -----------------------------

Най-сетне стигаме до имплементация на нашата идея за решаване на 
задачата. Вече имаме работеща и проверена идея, подбрали сме подхо
дящи структури от данни и остава да напишем кода. Ако не сме направили 
това, трябва да се върнем на предните стъпки. 

----------------------------- Правило -----------------------------

Ако нямате измислена идея за решение, не почвайте да 
пишете код! Какво ще напишете, като нямате идея за 
решаване на задачата? Все едно да отидете на гарата и да 
се качите на някой влак, без да сте решили за къде ще 
пътувате. 

----------------------------- Правило -----------------------------

Ако не сте проверили дали идеите ви са верни, не 
почвайте да пишете код! Трябва ли да напишете 300 реда 
код и тогава да откриете, че идеята ви е тотално сбъркана 
и трябва да почнете отначало? 

----------------------------- Правило -----------------------------

Считаме, че би трябвало вече да сте овладели начални техники, свързани 
с писането на програмен код: как да работите със средата за разработка 
(Eclipse), как да ползвате компилатора, как да разчитате грешките, които 
той ви дава, как да ползвате подсказките (auto complete), как да 
генерирате методи, конструктори и свойства, как да поправяте грешки и 
как да изпълнявате и дебъгвате програмата.



 Затова съветите, които 
следват, са свързани не със самото писане на програмни редове код, а с 
цялостния подход при имплементиране на алгоритми.

----------------------------- Пишете стъпка по стъпка! -----------------------------

Как да пишем стъпка по стъпка? Това зависи от конкретната задача и от 
начина, по който сме я разделили на подзадачи. Например, ако задачата 
се състои от 3 независими части, напишете първо едната част, компили
райте я, тествайте я с някакви примерни входни данни и след като се 
убедите, че работи, преминете към следващите части. След това напишете 
втората част, компилирайте я, тествайте я и когато е готова и тя, преминете 
към третата част. Когато сте написали и последната част и сте се убедили, 
че работи, преминете към обстойно тестване на цялата програма.

Защо да пишем на части? Когато пишете на части, стъпка по стъпка, вие 
намалявате обема код, над който се концентрирате във всеки един момент. 
По този начин намалявате сложността на проблема, като го решавате на 
части. Спомнете си: големият и сложен проблем винаги може да се раздели 
на няколко по-малки и по-прости проблема, за които лесно ще намерите 
решение. 

- да отстранявам поблемите по рано да не ги оставям за напред

Правило
Пишете програмата на части, а не наведнъж. Напишете 
някаква логически отделена част, компилирайте я, 
отстранете грешките, тествайте я и когато тя работи, 
преминете към следващата част.
Правило


----------------------------- стр 790 -----------------------------

Стъпка 3 – Единично разместване

Търсете в Google! 
Трябва да формулираме по подходящ 
начин нашето търсене. В случая търсим примерен Java код, който връща 
случайно число в даден интервал. Можем да пробваме следното търсене:
java random number example 


Стъпка 4 – Разместване на тестето 

Стъпка 5 – Вход от конзолата

Ако задачата изисква вход от конзолата, реализирайте го 
най-накрая, след като всичко останало работи. Докато
пишете програмата, тествайте с твърдо кодирани пример
ни данни, за да не въвеждате входа всеки път. Така ще 
спестите много време и нерви.


Сортиране на числа – стъпка по стъпка

За задачата със сортиране на числа в нарастващ ред нещата не стоят по
различно. Отново правилният подход към имплементацията изисква да 
работим на стъпки. Нека видим накратко кои са стъпките. Няма да пишем 
кода, но ще набележим основните моменти, през които трябва да преми
нете. Да предположим, че реализираме идеята за сортиране чрез ArrayList, 
в който последователно намираме най-малкото число, отпечатваме го и го 
изтриваме. Ето какви биха могли да са стъпките: 
Стъпка 1. Измисляме подходящ пример, с който ще си тестваме. 
Създаваме ArrayList<Integer> и го запълваме с числата от нашия 
пример. Реализираме отпечатване на числата. 
Стартираме програмата и тестваме. 
Стъпка 2. Реализираме метод, който намира най-малкото число в 
масива и връща позицията му. 
Тестваме метода за търсене на най-малко число. Пробваме различни 
поредици числа, за да се убедим, че търсенето работи коректно 
(слагаме най-малкия елемент в началото, в края, в средата; пробваме и 
когато най-малкия елемент се повтаря няколко пъти). 
Стъпка 3. Реализираме метод, който намира най-малкото число, 
отпечатва го и го изтрива. 
Тестваме с нашия пример дали методът работи коректно. 
Стъпка 4. Реализираме метода, който сортира числата. Той изпълнява 
предходния метод N пъти (където е броят на числата). 
Задължително тестваме дали всичко работи както трябва. 
Стъпка 5. Ако е необходим вход от конзолата, реализираме го.

Виждате, че подходът с разбиването на стъпки е приложим при всякакви 
задачи. Просто трябва да съобразим кои са нашите елементарни стъпки при 
имплементацията и да ги изпълняваме една след друга, като не забравяме 
да тестваме всяко парче код възможно най-рано. След всяка стъпка е 
хубаво да стартираме програмата, за да се убедим, че до този момент 
всичко работи правилно. Така ще откриваме евентуални проблеми още при 
възникването им и ще ги отстраняваме бързо и лесно.


Тествайте решението си!

1. Аз съм разбрал добре условието на задачата. 
2. Аз съм измислил алгоритъм за решаването на задачата. 
3. Аз съм тествал на лист хартия моя алгоритъм и съм се уверил, че е 
правилен. 
4. Аз съм помислил за структурите от данни и за ефективността на моя 
алгоритъм. 
5. Аз съм написал програма, която реализира коректно моя алгоритъм. 
6. Аз съм тествал обстойно моята програма с подходящи примери, за да 
се уверя, че работи коректно, дори в необичайни ситуации.


Опитните програмисти знаят, че ако напишат код и той не е тестван, това 
означава, че той още не е завършен. В повечето софтуерни фирми е 
недопустимо да се предаде код, който не е тестван. В софтуерната 
индустрия дори е възприета концепцията за "unit testing" – автоматизирано 
тестване на отделните единици от кода (методи, класове и цели модули). 
Unit testing означава да пишем програма, която тества нашата програма 
дали работи коректно. В някои фирми дори първо се измислят тестовите 
сценарии, пишат се тестовете за програмата и най-накрая се пише самата 
програма. Темата за unit testing е много сериозна и обемна, но с нея ще се 
запознаете по-късно, когато навлезете в дълбините на професията 
"софтуерен инженер". Засега, нека се фокусираме върху ръчното тестване,


Как да тестваме? 

Една програма е коректна, ако работи коректно за всеки валиден набор от 
входни данни. Тестването е процес, който цели да установи наличие на 
дефекти в програмата, ако има такива.


Тестването може да установи само наличие на дефекти. 
То не може да докаже, че дадена програма е коректна! 
Програмите, които са тествани добре имат много по-малко 
дефекти, отколкото програмите, които изобщо не са тест
вани или не са тествани качествено. 

Тестването е добре да започва от един пример, с който обхващаме типичния 
случай в нашата задача. Той най-често е същият пример, който сме 
тествали на хартия и за който очакваме нашият алгоритъм да работи 
коректно. След написване на кода обикновено следва отстраняване на 
поредица от дребни грешки и най-накрая нашият пример тръгва. След това 
е нормално да тестваме програмата с по-голям и по-сложен пример, за да 
видим как се държи тя в по-сложни ситуации. Следва тестване на 
граничните случаи и тестване за бързодействие. В зависимост от слож
ността на конкретната задача могат да се изпълнят от един-два до няколко 
десетки теста, за да се покрият всички основни случаи на употреба. 


Тестване с добър представител на общия случай 

Както вече споменахме, нормално е тестването да започне с тестов пример, 
който е добър представител на общия случай. Това е тест, който хем е 
достатъчно прост, за да бъде проигран ръчно на хартия, хем е достатъчно 
общ, за да покрие общия случай на употреба на програмата, а не някой
частен случай. Следвайки този подход най-естественото нещо, което някой 
програмист може да направи е следното:

1. Да измисли пример, който е добър представител на общия случай. 
2. Да тества примера на ръка (на хартия). 
3. Да очаква примера да тръгне успешно и от имплементацията на 
неговия алгоритъм. 
4. Да се убеди, че примерът му работи коректно след написване на 
програмата и отстраняване на дребните грешки, които възникват при 
писането на кода.

Какво още да тестваме? 

- - - 
Сериозен тест за обичайния случай. Целта на този тест е да провери 
дали за по-голям и по-сложен пример вашата програма работи 
коректно. За нашата задача с разбъркването на картите такъв тест 
може да е тесте от 52 карти. 
Тестове за граничните случаи. Те проверяват дали вашата програма 
работи коректно при необичаен вход на границата на допустимото. За 
нашата задача такъв пример е разбъркването на тесте, което се 
състои само от една карта. 
Тестове за бързодействие. Тези тестове поставят програмата в 
екстремални условия като й подават големи по размерност входни 
данни и проверяват бързодействието. 


Сериозен тест на обичайния случай 

 Ами много просто, възможно е програмата да е грешна, но да 
работи по случайност за нашия случай. 
Как да подготвим по-сериозен тест? Това зависи много от самата задача. 
Тестът хем трябва да е с по-голям обем данни, отколкото ръчния тест, но 
все пак трябва да можем да проверим изхода от програмата дали е 
коректен. 

За нашия пример с разбъркването на карти в случаен ред е нормално да 
тестваме с пълно тесте от 52 карти. Лесно можем да произведем такъв 
входен тест с два вложени цикъла. След изпълнение на програмата лесно 
можем да проверим дали резултатът е коректен – трябва картите да са 
разбъркани и разбъркването да е случайно. Необходимо е още при две 
последователни изпълнения на този тест да се получи тотално различно 
разбъркване. Ето как изглежда кода, реализиращ такъв тест: 

Нека вземем друга задача: сортиране на числа. Как да си направим 
сериозен тест за обичайния случай? Ами най-лесното е да генерираме 
поредица от 100 или дори 1000 случайни числа и да ги сортираме. 
Проверката за коректност е лесна: трябва числата да са подредени по 
големина. Друг тест, който е удачен при сортирането на числа е да вземем 
числата от 1000 до 1 в намаляващ ред и да ги сортираме. Трябва да получим 
същите числа, но сортирани в нарастващ ред от 1 до 1000. Би могло да се 
каже, че това е най-трудния възможен тест за тази задача и ако той работи 
за голям брой числа, значи програмата се очаква да работи добре. 
Нека разгледаме и другите тестове, които е добре винаги да правим.

Гранични случаи

Граничните ситуации се получават при входни данни на границата на 
нормалното и допустимото. При тях често пъти програмата гърми, защото 
не очаква толкова малки или големи или необичайни данни, но те все пак 
са допустими по условие или не са допустими, но не са предвидени.


Граничен случай: разбъркване на една карта

Ясно е какъв е проблемът: генерирането на случайно число се счупи, 
защото му се подава отрицателен диапазон. Нашата програма работи добре 
при нормален брой карти, но не работи за една карта. Открихме лесен за 
отстраняване дефект, който бихме пропуснали с лека ръка, ако се бяхме 
разгледали внимателно граничните случаи. След като знаем какъв е 
проблемът поправката на кода е тривиална: 

public static void shuffleCards(ArrayList<Card> cards) { 
 if (cards.size() > 1) { 
  for (int i=1; i<=cards.size(); i++) { 
   performSingleExchange(cards); 
  } 
 } 
} 

Граничен случай: разбъркване на две карти 

Изглежда пак нещо не е наред. Ако разгледаме кода или го пуснем през 
дебъгера, ще се убедим, че всеки път се прави точно едно разместване на 
първата карта с втората и при две карти няма как да се получи случайно 
разместване. Как да решим проблема? Веднага можем да се сетим за 
няколко решения: - Правим единичното разместване N+K брой пъти, където K е случайно 
число между 0 и 1. - При разместванията допускаме случайната позиция, на която отива 
първата карта да включва и нулевата позиция. - Разглеждаме случая с 2 карти като специален и пишем отделен метод 
специално за него. 

Тестваме отново разбъркването на две карти и този път изглежда, че 
програмата работи коректно. 
Щом има проблем за 2 карти, може да има проблем и за 3 карти, нали? Ако 
тестваме програмата за 3 карти, ще се убедим, че тя работи коректно. След 
няколко стартирания получаваме всички възможни разбърквания на трите 
карти, което показва, че случайното разбъркване може да получи всички 
пермутации на трите карти. Този път не открихме дефекти и програмата 
няма нужда от промяна.

Граничен случай: разбъркване на нула карти STR 804

При грешни входни данни програмата не трябва да връща 
грешен резултат, а трябва или да върне верен резултат 
или да съобщи, че входните данни са грешни. 

Повторно тестване след корекциите (regression 
testing)

Повторно тестване след корекциите (regression 
testing) 
Често пъти при корекции на грешки се получават нови грешки, които преди 
не са съществували. Например, ако поправим грешката за 2 карти чрез 
промяна на правилата за размяна на единична карта, това би могло да 
доведе до грешен резултат при или повече 3 карти. При всяка промяна, 
която би могла да засегне други случаи на употреба, е редно да пускаме 
отново тестовете, които сме правили до момента, за да сме сигурни, че 
промяната не поврежда вече работещите случаи. За тази цел е добре да 
запазваме тестовете на програмата, които сме изпълнявали, а не да ги 
изтриваме. 
Идеята за повторяемост на тестовете лежи в основата на концепцията unit 
testing, но тази тема, както вече споменахме е за по-напреднали и затова 
я оставаме за по-нататък във времето (и пространството). 


Когато сте открили и сте поправили грешка в кода, 
отнасяща се за някой специфичен тест, уверете се, че 
поправката не засяга всички останали тестове. За целта е 
препоръчително да запазвате всички тестове, които 
изпълнявате.


Тестове за производителност

 трябва да се 
стремите да не пишете софтуер, който работи бавно, освен, ако нямате 
добре причина за това.


Как тестваме бързодействието (производителността) на програмата. 
Първият въпрос, който трябва да си зададем, когато стигнем до тестване на 
бързодействието, е имаме ли изисквания за скорост. Ако имаме какви са 
те? Ако нямаме какви ориентировъчни критерии за бързодействие трябва 
да спазим? 

Разбъркване на карти – тестове за производителност 

Нормално е да тестваме програмата и с много повече карти, примерно с 
52 000, защото в някой специален случай някой може да реши да разбърква 
много карти и да има проблем. Лесно можем да си направим такъв пример 
като добавим 1000 пъти нашите 52 карти и ги разбъркаме. Нека пуснем 
един такъв пример:


ArrayList<Card> cards = new ArrayList<Card>(); 
String[] allFaces = new String[] {"2", "3", "4", "5", 
"6", "7", "8", "9", "10", "J", "Q", "K", "A"}; 
Suit[] allSuits = new Suit[] { 
Suit.CLUB, Suit.DIAMOND, Suit.HEART, Suit.SPADE}; 
for (int count = 1; count<=1000; count++) { 
	for (String face : allFaces) { 
		for (Suit suit : allSuits) {
			Card card = new Card(face, suit); 
			cards.add(card); 
    } 
   } 
  } 
   
  CardsShuffle.shuffleCards(cards); 
  CardsShuffle.printCards(cards); 
  
  
  има забавяне при изпълнение
  
  Би трябвало при 52 000 карти да направим 
приблизително толкова единични размествания, а това би трябвало да 
отнеме частица от секундата. Защо имаме секунди забавяне? Опитните 
програмисти веднага ще се сетят, че печатаме големи обеми информация 
на конзолата, а това е бавна операция. Ако коментираме реда, в който 
отпечатваме резултата и измерим времето за изпълнение на разбъркването 
на картите, ще се убедим, че програмата работи достатъчно бързо дори и 
за 52 000 карти. Ето как можем да замерим времето:

public static void main(String[] args) { 
  ... 
  long oldTime = System.currentTimeMillis(); 
  CardsShuffle.shuffleCards(cards); 
  long newTime = System.currentTimeMillis(); 
  System.out.printf("Execution time: %d ms",  
   newTime-oldTime); 
  //CardsShuffle.printCards(cards); 
 } 
 
 Можем да видим точно колко време отнема изпълнението на метода за 
разбъркване на картите:

Execution time: 31 ms 

Изглежда напълно приемливо. Нямаме проблем с бързодействието.

Сортиране на числа – тестове за производителност 

public class SortNumbers { 
 public static void main(String[] args) { 
  int[] numbers = new int[10000]; 
  Random rnd = new Random(); 
  for (int i=0; i<numbers.length; i++) { 
   numbers[i] = rnd.nextInt(2 * numbers.length); 
  } 
   
  sortNumbers(numbers); 
   
  System.out.println(Arrays.toString(numbers)); 
 } 
 
 private static void sortNumbers(int[] numbers) { 
  for (int i=0; i<numbers.length-1; i++) { 
   int minIndex = i; 
   for (int j=i+1; j<numbers.length; j++) { 
    if (numbers[j] < numbers[minIndex]) { 
     minIndex = j; 
    } 
   } 
   int oldNumber = numbers[i]; 
   numbers[i] = numbers[minIndex]; 
   numbers[minIndex] = oldNumber; 
  } 
   
 }
 } 
 
 за 10 000 числа е за под сикунда но за 300 000 зависва.
 Тук сортираме с пряка селекция алгоритъма.
 
 Ако имаме в реалния свят проблем свързан със сортиране на 
 цените от акции на стоковата борса на фирма за програмисти,
 тогава ще има много числа и за целта трябва да се намери по добър алгортъм.
 
 Как да правим ефективно сортиране на цели числа можем да прочетем в 
десетки сайтове в Интернет и в класическите книги по алгоритми. 
Конкретно за тази задача подходящо е да използваме алгоритъма за 
сортиране "radix sort" (http://en.wikipedia.org/wiki/Radix_sort), но тази 
дискусия е извън темата и ще я пропуснем.

Нека припомним доброто старо правило за ефективността:

----------------------------- Правило -----------------------------
Винаги трябва да правим компромис между времето, за 
което ще напишем програмата и бързодействието, което 
искаме да постигнем. Иначе може да изгубим време да 
решаваме проблем, който не съществува или да дадем 
решение, което не върши работа. 
----------------------------- Правило -----------------------------

Трябва да имаме предвид и че за някои задачи изобщо не съществуват 
бързи алгоритми и ще трябва да се примирим с ниската производителност. 
Например за задачата за намиране на всички прости делители на цяло 
число (вж. http://en.wikipedia.org/wiki/Integer_factorization) няма известно 
бързо решение. 

За някои задачи нямаме нужда от бързина, защото очакваме входните 
данни да са достатъчно малки и тогава е безумно да търсим сложни 
алгоритми с цел бързодействие. Например задачата за сортиране на 
оценките на студентите от даден курс може да се реши с произволен 

алгоритъм за сортиране и при всички случаи ще работи бързо, тъй като 
броят на студентите се очаква да е достатъчно малък. 

Генерални изводи

Преди да започнете да четете настоящата тема сигурно сте си мислили, че 
това ще е най-скучната и безсмислена до момента, но вярвам, че сега 
мислите по съвсем различен начин. Всички си мислят, че знаят как да 
решават задачи по програмиране и че за това няма "рецепта" (просто 
трябва да го можеш), но въобще не е така. Има си рецепта и ние ви я 
показахме в действие!

 Първата 
стъпка към придобиване на умения за решаване на такива сложни задачи 
е да се научите да подхождате към задачата систематично и да усвоите 
рецептата за решаване на задачи, която ви демонстрирахме в действие. 
Това, разбира се съвсем няма да ви е достатъчно, но е силна крачка напред! 

За решаването на задачи по програмиране си има 
рецепта! Ползвайте систематичен подход и ще имате 
много по-голям успех, отколкото, ако карате по усет. Дори 
професионалистите с десетки години опит ползват в 
голяма степен описания от нас подход. Ползвайте го и вие 
и ще се убедите, че помага!

стигнал съм до стр 832

Входният файл чете символ по символ с класа InputStreamReader. За 
съжаление не можем да ползваме любимият ни клас Scanner, защото той 
няма метод за четене на единичен символ. 

да науча и сравня предимства и недостатъци на конструкциите в java  и технологии 
като array , arrayList, list i dr

стъпки за решаване на проблема

Задача 1: Извличане на текста от HTML 
документ

Измисляне на идея за решение 

Проверка на идеята

Изясняване на условието на задачата

Нова идея за решаване на задачата

Разбиваме задачата на подзадачи

Какво структури от данни да ползваме?
Да помислим за ефективността

Стъпка 1 – прочитане на входния файл

Стъпка 2 – премахване на таговете

Стъпка 3 – премахване на празните редове

Стъпка 4 – записване на резултата във файл

Тестване на решението 

Как да оправим проблема с тагове на два реда? 

Първата идея, която ни хрумва, е да заредим в паметта целия входен файл 
и да го обработваме като един голям стринг вместо ред по ред. Това е идея, 
която изглежда ще работи, но ще работи бавно и ще консумира голямо 
количество памет. Нека потърсим друга идея. 
Очевидно не можем да четем файла ред по ред. Можем ли да го четем 
символ по символ? Ако можем, как ще обработваме таговете? Хрумва ни, че 
ако четем файла символ по символ, можем във всеки един момент да знаем 
дали сме в таг или сме извън таг и ако сме извън таг, можем да печатаме 
всичко, което прочетем. Ще се получи нещо такова: 

Входният файл чете символ по символ с класа InputStreamReader. За 
съжаление не можем да ползваме любимият ни клас Scanner, защото той 
няма метод за четене на единичен символ. 

Тестване на новото решение